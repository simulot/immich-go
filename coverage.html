
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>folder: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/simulot/immich-go/adapters/folder/options.go (0.0%)</option>
				
				<option value="file1">github.com/simulot/immich-go/adapters/folder/picasa.go (0.0%)</option>
				
				<option value="file2">github.com/simulot/immich-go/adapters/folder/readFolder.go (69.0%)</option>
				
				<option value="file3">github.com/simulot/immich-go/adapters/folder/writeFolder.go (0.0%)</option>
				
				<option value="file4">github.com/simulot/immich-go/adapters/fromimmich/fromimmich.go (0.0%)</option>
				
				<option value="file5">github.com/simulot/immich-go/adapters/fromimmich/options.go (0.0%)</option>
				
				<option value="file6">github.com/simulot/immich-go/adapters/googlePhotos/googlephotos.go (65.8%)</option>
				
				<option value="file7">github.com/simulot/immich-go/adapters/googlePhotos/json.go (84.6%)</option>
				
				<option value="file8">github.com/simulot/immich-go/adapters/googlePhotos/logs.go (10.0%)</option>
				
				<option value="file9">github.com/simulot/immich-go/adapters/googlePhotos/matchers.go (100.0%)</option>
				
				<option value="file10">github.com/simulot/immich-go/adapters/googlePhotos/options.go (0.0%)</option>
				
				<option value="file11">github.com/simulot/immich-go/app/app.go (0.0%)</option>
				
				<option value="file12">github.com/simulot/immich-go/app/client.go (0.0%)</option>
				
				<option value="file13">github.com/simulot/immich-go/app/cmd/archive/archive.go (0.0%)</option>
				
				<option value="file14">github.com/simulot/immich-go/app/cmd/archive/run.go (0.0%)</option>
				
				<option value="file15">github.com/simulot/immich-go/app/cmd/commands.go (0.0%)</option>
				
				<option value="file16">github.com/simulot/immich-go/app/cmd/stack/stack.go (0.0%)</option>
				
				<option value="file17">github.com/simulot/immich-go/app/cmd/upload/advice.go (0.0%)</option>
				
				<option value="file18">github.com/simulot/immich-go/app/cmd/upload/assets.go (0.0%)</option>
				
				<option value="file19">github.com/simulot/immich-go/app/cmd/upload/from-folder.go (0.0%)</option>
				
				<option value="file20">github.com/simulot/immich-go/app/cmd/upload/from-immich.go (0.0%)</option>
				
				<option value="file21">github.com/simulot/immich-go/app/cmd/upload/fromGooglePhotos.go (0.0%)</option>
				
				<option value="file22">github.com/simulot/immich-go/app/cmd/upload/noui.go (0.0%)</option>
				
				<option value="file23">github.com/simulot/immich-go/app/cmd/upload/run.go (0.0%)</option>
				
				<option value="file24">github.com/simulot/immich-go/app/cmd/upload/ui.go (0.0%)</option>
				
				<option value="file25">github.com/simulot/immich-go/app/cmd/upload/upload.go (0.0%)</option>
				
				<option value="file26">github.com/simulot/immich-go/app/log.go (0.0%)</option>
				
				<option value="file27">github.com/simulot/immich-go/app/version.go (0.0%)</option>
				
				<option value="file28">github.com/simulot/immich-go/coverageTester/tester.go (0.0%)</option>
				
				<option value="file29">github.com/simulot/immich-go/immich/albums.go (0.0%)</option>
				
				<option value="file30">github.com/simulot/immich-go/immich/asset.go (6.5%)</option>
				
				<option value="file31">github.com/simulot/immich-go/immich/call.go (65.6%)</option>
				
				<option value="file32">github.com/simulot/immich-go/immich/client.go (28.0%)</option>
				
				<option value="file33">github.com/simulot/immich-go/immich/immich.go (63.2%)</option>
				
				<option value="file34">github.com/simulot/immich-go/immich/job.go (0.0%)</option>
				
				<option value="file35">github.com/simulot/immich-go/immich/media.go (0.0%)</option>
				
				<option value="file36">github.com/simulot/immich-go/immich/metadata.go (0.0%)</option>
				
				<option value="file37">github.com/simulot/immich-go/immich/ping.go (85.3%)</option>
				
				<option value="file38">github.com/simulot/immich-go/immich/stacks.go (0.0%)</option>
				
				<option value="file39">github.com/simulot/immich-go/immich/tag.go (0.0%)</option>
				
				<option value="file40">github.com/simulot/immich-go/immich/trace.go (0.0%)</option>
				
				<option value="file41">github.com/simulot/immich-go/immich/upload.go (0.0%)</option>
				
				<option value="file42">github.com/simulot/immich-go/internal/assets/album.go (0.0%)</option>
				
				<option value="file43">github.com/simulot/immich-go/internal/assets/asset.go (0.0%)</option>
				
				<option value="file44">github.com/simulot/immich-go/internal/assets/assetFile.go (0.0%)</option>
				
				<option value="file45">github.com/simulot/immich-go/internal/assets/group.go (0.0%)</option>
				
				<option value="file46">github.com/simulot/immich-go/internal/assets/metadata.go (0.0%)</option>
				
				<option value="file47">github.com/simulot/immich-go/internal/assets/tag.go (0.0%)</option>
				
				<option value="file48">github.com/simulot/immich-go/internal/bulktags/bulktag.go (81.4%)</option>
				
				<option value="file49">github.com/simulot/immich-go/internal/cliFlags/dateFromNames.go (0.0%)</option>
				
				<option value="file50">github.com/simulot/immich-go/internal/cliFlags/daterange.go (66.7%)</option>
				
				<option value="file51">github.com/simulot/immich-go/internal/cliFlags/extensionList.go (28.6%)</option>
				
				<option value="file52">github.com/simulot/immich-go/internal/configuration/config.go (0.0%)</option>
				
				<option value="file53">github.com/simulot/immich-go/internal/docker/docker.go (0.0%)</option>
				
				<option value="file54">github.com/simulot/immich-go/internal/docker/local.go (0.0%)</option>
				
				<option value="file55">github.com/simulot/immich-go/internal/docker/ssh.go (0.0%)</option>
				
				<option value="file56">github.com/simulot/immich-go/internal/e2eTests/e2e/e2e.go (0.0%)</option>
				
				<option value="file57">github.com/simulot/immich-go/internal/e2eTests/metadata/reader/main.go (0.0%)</option>
				
				<option value="file58">github.com/simulot/immich-go/internal/exif/direct.go (61.9%)</option>
				
				<option value="file59">github.com/simulot/immich-go/internal/exif/metadata.go (0.0%)</option>
				
				<option value="file60">github.com/simulot/immich-go/internal/exif/quicktime.go (52.9%)</option>
				
				<option value="file61">github.com/simulot/immich-go/internal/exif/search.go (100.0%)</option>
				
				<option value="file62">github.com/simulot/immich-go/internal/exif/sidecars/jsonsidecar/json.go (0.0%)</option>
				
				<option value="file63">github.com/simulot/immich-go/internal/exif/sidecars/xmpsidecar/bool.go (0.0%)</option>
				
				<option value="file64">github.com/simulot/immich-go/internal/exif/sidecars/xmpsidecar/gps.go (46.2%)</option>
				
				<option value="file65">github.com/simulot/immich-go/internal/exif/sidecars/xmpsidecar/int.go (42.9%)</option>
				
				<option value="file66">github.com/simulot/immich-go/internal/exif/sidecars/xmpsidecar/read.go (92.3%)</option>
				
				<option value="file67">github.com/simulot/immich-go/internal/exif/sidecars/xmpsidecar/time.go (50.0%)</option>
				
				<option value="file68">github.com/simulot/immich-go/internal/fakeImmich/immich.go (0.0%)</option>
				
				<option value="file69">github.com/simulot/immich-go/internal/fakefs/fakefs.go (58.6%)</option>
				
				<option value="file70">github.com/simulot/immich-go/internal/fakefs/metadata.go (0.0%)</option>
				
				<option value="file71">github.com/simulot/immich-go/internal/fakefs/ziplist.go (64.6%)</option>
				
				<option value="file72">github.com/simulot/immich-go/internal/fileevent/fileevents.go (0.0%)</option>
				
				<option value="file73">github.com/simulot/immich-go/internal/filenames/huawei.go (100.0%)</option>
				
				<option value="file74">github.com/simulot/immich-go/internal/filenames/infoCollector.go (87.5%)</option>
				
				<option value="file75">github.com/simulot/immich-go/internal/filenames/namesdate.go (88.2%)</option>
				
				<option value="file76">github.com/simulot/immich-go/internal/filenames/nexus.go (100.0%)</option>
				
				<option value="file77">github.com/simulot/immich-go/internal/filenames/pixel.go (92.9%)</option>
				
				<option value="file78">github.com/simulot/immich-go/internal/filenames/samsung.go (100.0%)</option>
				
				<option value="file79">github.com/simulot/immich-go/internal/filenames/sony_xperia.go (100.0%)</option>
				
				<option value="file80">github.com/simulot/immich-go/internal/filetypes/supported.go (0.0%)</option>
				
				<option value="file81">github.com/simulot/immich-go/internal/filters/filterBursts.go (60.4%)</option>
				
				<option value="file82">github.com/simulot/immich-go/internal/filters/filterHeicJPEG.go (42.0%)</option>
				
				<option value="file83">github.com/simulot/immich-go/internal/filters/filterRawJPEG.go (43.5%)</option>
				
				<option value="file84">github.com/simulot/immich-go/internal/filters/filters.go (0.0%)</option>
				
				<option value="file85">github.com/simulot/immich-go/internal/fshelper/cachereader/cachereader.go (83.3%)</option>
				
				<option value="file86">github.com/simulot/immich-go/internal/fshelper/debugfiles/debugFiles.go (0.0%)</option>
				
				<option value="file87">github.com/simulot/immich-go/internal/fshelper/extendedFS.go (0.0%)</option>
				
				<option value="file88">github.com/simulot/immich-go/internal/fshelper/filename.go (0.0%)</option>
				
				<option value="file89">github.com/simulot/immich-go/internal/fshelper/globwalkfs.go (74.7%)</option>
				
				<option value="file90">github.com/simulot/immich-go/internal/fshelper/hash/base64.go (0.0%)</option>
				
				<option value="file91">github.com/simulot/immich-go/internal/fshelper/hash/sha1.go (0.0%)</option>
				
				<option value="file92">github.com/simulot/immich-go/internal/fshelper/hasmeta.go (100.0%)</option>
				
				<option value="file93">github.com/simulot/immich-go/internal/fshelper/osfs/osfs.go (0.0%)</option>
				
				<option value="file94">github.com/simulot/immich-go/internal/fshelper/parseArgs.go (0.0%)</option>
				
				<option value="file95">github.com/simulot/immich-go/internal/fshelper/readjson.go (0.0%)</option>
				
				<option value="file96">github.com/simulot/immich-go/internal/fshelper/teereadercloser.go (0.0%)</option>
				
				<option value="file97">github.com/simulot/immich-go/internal/fshelper/zipName/zip.go (0.0%)</option>
				
				<option value="file98">github.com/simulot/immich-go/internal/gen/maps.go (0.0%)</option>
				
				<option value="file99">github.com/simulot/immich-go/internal/gen/slices.go (0.0%)</option>
				
				<option value="file100">github.com/simulot/immich-go/internal/gen/syncmap/syncmap.go (0.0%)</option>
				
				<option value="file101">github.com/simulot/immich-go/internal/groups/burst/burst.go (86.7%)</option>
				
				<option value="file102">github.com/simulot/immich-go/internal/groups/epsonfastfoto/epsonfastfoto.go (80.6%)</option>
				
				<option value="file103">github.com/simulot/immich-go/internal/groups/groups.go (97.1%)</option>
				
				<option value="file104">github.com/simulot/immich-go/internal/groups/series/series.go (84.1%)</option>
				
				<option value="file105">github.com/simulot/immich-go/internal/immichfs/immich.go (41.4%)</option>
				
				<option value="file106">github.com/simulot/immich-go/internal/journal/journal.go (0.0%)</option>
				
				<option value="file107">github.com/simulot/immich-go/internal/journal/log.go (0.0%)</option>
				
				<option value="file108">github.com/simulot/immich-go/internal/journal/nologger.go (0.0%)</option>
				
				<option value="file109">github.com/simulot/immich-go/internal/loghelper/loghelp.go (0.0%)</option>
				
				<option value="file110">github.com/simulot/immich-go/internal/namematcher/list.go (73.7%)</option>
				
				<option value="file111">github.com/simulot/immich-go/internal/tester/cmd/main.go (0.0%)</option>
				
				<option value="file112">github.com/simulot/immich-go/internal/tester/docker.go (0.0%)</option>
				
				<option value="file113">github.com/simulot/immich-go/internal/tester/tester.go (0.0%)</option>
				
				<option value="file114">github.com/simulot/immich-go/internal/ui/ask.go (0.0%)</option>
				
				<option value="file115">github.com/simulot/immich-go/internal/ui/size.go (0.0%)</option>
				
				<option value="file116">github.com/simulot/immich-go/internal/worker/worker.go (100.0%)</option>
				
				<option value="file117">github.com/simulot/immich-go/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package folder

import (
        "fmt"
        "strings"
        "time"

        cliflags "github.com/simulot/immich-go/internal/cliFlags"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/filetypes"
        "github.com/simulot/immich-go/internal/filters"
        "github.com/simulot/immich-go/internal/namematcher"
        "github.com/spf13/cobra"
)

// ImportFolderOptions represents the flags used for importing assets from a file system.
type ImportFolderOptions struct {
        // UsePathAsAlbumName determines whether to create albums based on the full path to the asset.
        UsePathAsAlbumName AlbumFolderMode

        // AlbumNamePathSeparator specifies how multiple (sub) folders are joined when creating album names.
        AlbumNamePathSeparator string

        // ImportIntoAlbum is the name of the album where all assets will be added.
        ImportIntoAlbum string

        // BannedFiles is a list of file name patterns to be excluded from the import process.
        BannedFiles namematcher.List

        // Recursive indicates whether to explore the folder and all its sub-folders.
        Recursive bool

        // InclusionFlags controls the file extensions to be included in the import process.
        InclusionFlags cliflags.InclusionFlags

        // // ExifToolFlags specifies options for the exif.
        // ExifToolFlags exif.ExifToolFlags

        // IgnoreSideCarFiles indicates whether to ignore XMP files during the import process.
        IgnoreSideCarFiles bool

        // Stack jpg/raw
        StackJpgWithRaw bool

        // Stack burst
        StackBurstPhotos bool

        // SupportedMedia is the server's actual list of supported media types.
        SupportedMedia filetypes.SupportedMedia

        // InfoCollector is used to extract information from the file name.
        InfoCollector *filenames.InfoCollector

        // ManageHEICJPG determines whether to manage HEIC to JPG conversion options.
        ManageHEICJPG filters.HeicJpgFlag

        // ManageRawJPG determines how to manage raw and JPEG files.
        ManageRawJPG filters.RawJPGFlag

        // BurstFlag determines how to manage burst photos.
        ManageBurst filters.BurstFlag

        // ManageEpsonFastFoto enables the management of Epson FastFoto files.
        ManageEpsonFastFoto bool

        // Tags is a list of tags to be added to the imported assets.
        Tags []string

        // Folder as tags
        FolderAsTags bool

        // SessionTag indicates whether to add a session tag to the imported assets.
        SessionTag bool
        session    string // Session tag value

        // TakeDateFromFilename indicates whether to take the date from the filename if the date isn't available in the image.
        TakeDateFromFilename bool

        // Use picasa albums
        PicasaAlbum bool

        // local time zone
        TZ *time.Location
}

func (o *ImportFolderOptions) AddFromFolderFlags(cmd *cobra.Command, parent *cobra.Command) <span class="cov0" title="0">{
        o.ManageHEICJPG = filters.HeicJpgNothing
        o.ManageRawJPG = filters.RawJPGNothing
        o.ManageBurst = filters.BurstNothing
        o.Recursive = true
        o.SupportedMedia = filetypes.DefaultSupportedMedia
        o.UsePathAsAlbumName = FolderModeNone
        o.BannedFiles, _ = namematcher.New(
                `@eaDir/`,
                `@__thumb/`,          // QNAP
                `SYNOFILE_THUMB_*.*`, // SYNOLOGY
                `Lightroom Catalog/`, // LR
                `thumbnails/`,        // Android photo
                `.DS_Store/`,         // Mac OS custom attributes
                `/._*`,               // MacOS resource files
                `.photostructure/`,   // PhotoStructure
        )
        cmd.Flags().StringVar(&amp;o.ImportIntoAlbum, "into-album", "", "Specify an album to import all files into")
        cmd.Flags().Var(&amp;o.UsePathAsAlbumName, "folder-as-album", "Import all files in albums defined by the folder structure. Can be set to 'FOLDER' to use the folder name as the album name, or 'PATH' to use the full path as the album name")
        cmd.Flags().StringVar(&amp;o.AlbumNamePathSeparator, "album-path-joiner", " / ", "Specify a string to use when joining multiple folder names to create an album name (e.g. ' ',' - ')")
        cmd.Flags().BoolVar(&amp;o.Recursive, "recursive", true, "Explore the folder and all its sub-folders")
        cmd.Flags().Var(&amp;o.BannedFiles, "ban-file", "Exclude a file based on a pattern (case-insensitive). Can be specified multiple times.")
        cmd.Flags().BoolVar(&amp;o.IgnoreSideCarFiles, "ignore-sidecar-files", false, "Don't upload sidecar with the photo.")

        cmd.Flags().StringSliceVar(&amp;o.Tags, "tag", nil, "Add tags to the imported assets. Can be specified multiple times. Hierarchy is supported using a / separator (e.g. 'tag1/subtag1')")
        cmd.Flags().BoolVar(&amp;o.FolderAsTags, "folder-as-tags", false, "Use the folder structure as tags, (ex: the file  holiday/summer 2024/file.jpg will have the tag holiday/summer 2024)")
        cmd.Flags().BoolVar(&amp;o.SessionTag, "session-tag", false, "Tag uploaded photos with a tag \"{immich-go}/YYYY-MM-DD HH-MM-SS\"")

        cliflags.AddInclusionFlags(cmd, &amp;o.InclusionFlags)
        cmd.Flags().BoolVar(&amp;o.TakeDateFromFilename, "date-from-name", true, "Use the date from the filename if the date isn't available in the metadata (Only for jpg, mp4, heic, dng, cr2, cr3, arw, raf, nef, mov)")

        // exif.AddExifToolFlags(cmd, &amp;o.ExifToolFlags) // disabled for now

        // upload specific flags, not for archive to folder
        if parent != nil &amp;&amp; parent.Name() == "upload" </span><span class="cov0" title="0">{
                cmd.Flags().Var(&amp;o.ManageHEICJPG, "manage-heic-jpeg", "Manage coupled HEIC and JPEG files. Possible values: KeepHeic, KeepJPG, StackCoverHeic, StackCoverJPG")
                cmd.Flags().Var(&amp;o.ManageRawJPG, "manage-raw-jpeg", "Manage coupled RAW and JPEG files. Possible values: KeepRaw, KeepJPG, StackCoverRaw, StackCoverJPG")
                cmd.Flags().Var(&amp;o.ManageBurst, "manage-burst", "Manage burst photos. Possible values: Stack, StackKeepRaw, StackKeepJPEG")
                cmd.Flags().BoolVar(&amp;o.ManageEpsonFastFoto, "manage-epson-fastfoto", false, "Manage Epson FastFoto file (default: false)")
                cmd.Flags().BoolVar(&amp;o.PicasaAlbum, "album-picasa", false, "Use Picasa album name found in .picasa.ini file (default: false)")
        }</span>
}

// AlbumFolderMode represents the mode in which album folders are organized.
// Implement the interface pflag.Value

type AlbumFolderMode string

const (
        FolderModeNone   AlbumFolderMode = "NONE"
        FolderModeFolder AlbumFolderMode = "FOLDER"
        FolderModePath   AlbumFolderMode = "PATH"
)

func (m AlbumFolderMode) String() string <span class="cov0" title="0">{
        return string(m)
}</span>

func (m *AlbumFolderMode) Set(v string) error <span class="cov0" title="0">{
        v = strings.TrimSpace(strings.ToUpper(v))
        switch v </span>{
        case string(FolderModeFolder), string(FolderModePath):<span class="cov0" title="0">
                *m = AlbumFolderMode(v)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid value for folder mode, expected %s, %s or %s", FolderModeFolder, FolderModePath, FolderModeNone)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m AlbumFolderMode) Type() string <span class="cov0" title="0">{
        return "folderMode"
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package folder

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "strings"
)

type PicasaAlbum struct {
        Name        string
        Description string
}

func ReadPicasaIni(fsys fs.FS, filename string) (PicasaAlbum, error) <span class="cov0" title="0">{
        file, err := fsys.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return PicasaAlbum{}, err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        a, err := parsePicasaIni(file)
        if err != nil </span><span class="cov0" title="0">{
                return PicasaAlbum{}, fmt.Errorf("error parsing picasa ini file: %w", err)
        }</span>
        <span class="cov0" title="0">return a, nil</span>
}

// parsePicasaIni parses the content of an INI file.
func parsePicasaIni(r io.Reader) (PicasaAlbum, error) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(r)
        var currentSection string
        var Album PicasaAlbum

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if len(line) == 0 || strings.HasPrefix(line, ";") || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        // Skip empty lines and comments
                        continue</span>
                }

                <span class="cov0" title="0">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov0" title="0">{
                        // New section
                        currentSection = line[1 : len(line)-1]
                }</span> else<span class="cov0" title="0"> if currentSection == "Picasa" </span><span class="cov0" title="0">{
                        // Key-value pair
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                return PicasaAlbum{}, errors.New("invalid line: " + line)
                        }</span>
                        <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                        value := strings.TrimSpace(parts[1])
                        switch key </span>{
                        case "name":<span class="cov0" title="0">
                                Album.Name = value</span>
                        case "description":<span class="cov0" title="0">
                                Album.Description = value</span>
                        }
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return PicasaAlbum{}, err
        }</span>

        <span class="cov0" title="0">return Album, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package folder

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io/fs"
        "path"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/simulot/immich-go/coverageTester"
        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/exif"
        "github.com/simulot/immich-go/internal/exif/sidecars/jsonsidecar"
        "github.com/simulot/immich-go/internal/exif/sidecars/xmpsidecar"
        "github.com/simulot/immich-go/internal/fileevent"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/filetypes"
        "github.com/simulot/immich-go/internal/filters"
        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/simulot/immich-go/internal/gen"
        "github.com/simulot/immich-go/internal/groups"
        "github.com/simulot/immich-go/internal/groups/burst"
        "github.com/simulot/immich-go/internal/groups/epsonfastfoto"
        "github.com/simulot/immich-go/internal/groups/series"
        "github.com/simulot/immich-go/internal/worker"
)

type LocalAssetBrowser struct {
        fsyss                   []fs.FS
        log                     *fileevent.Recorder
        flags                   *ImportFolderOptions
        pool                    *worker.Pool
        wg                      sync.WaitGroup
        groupers                []groups.Grouper
        requiresDateInformation bool                              // true if we need to read the date from the file for the options
        picasaAlbums            *gen.SyncMap[string, PicasaAlbum] // ap[string]PicasaAlbum
}

func NewLocalFiles(ctx context.Context, l *fileevent.Recorder, flags *ImportFolderOptions, fsyss ...fs.FS) (*LocalAssetBrowser, error) <span class="cov8" title="1">{

        coverageTester.WriteUniqueLine("NewLocalFiles - Branch 0/7 Covered")

        if flags.ImportIntoAlbum != "" &amp;&amp; flags.UsePathAsAlbumName != FolderModeNone </span><span class="cov0" title="0">{

                coverageTester.WriteUniqueLine("NewLocalFiles - Branch 1/7 Covered")
                return nil, errors.New("cannot use both --into-album and --folder-as-album")
        }</span>

        <span class="cov8" title="1">la := LocalAssetBrowser{
                fsyss: fsyss,
                flags: flags,
                log:   l,
                pool:  worker.NewPool(10), // TODO: Make this configurable
                requiresDateInformation: flags.InclusionFlags.DateRange.IsSet() ||
                        flags.TakeDateFromFilename || flags.StackBurstPhotos ||
                        flags.ManageHEICJPG != filters.HeicJpgNothing || flags.ManageRawJPG != filters.RawJPGNothing,
        }

        if flags.PicasaAlbum </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("NewLocalFiles - Branch 2/7 Covered")
                la.picasaAlbums = gen.NewSyncMap[string, PicasaAlbum]() // make(map[string]PicasaAlbum)
        }</span>

        <span class="cov8" title="1">if flags.InfoCollector == nil </span><span class="cov8" title="1">{
                coverageTester.WriteUniqueLine("NewLocalFiles - Branch 3/7 Covered")
                flags.InfoCollector = filenames.NewInfoCollector(flags.TZ, flags.SupportedMedia)
        }</span>

        <span class="cov8" title="1">if flags.InclusionFlags.DateRange.IsSet() </span><span class="cov8" title="1">{
                coverageTester.WriteUniqueLine("NewLocalFiles - Branch 4/7 Covered")
                flags.InclusionFlags.DateRange.SetTZ(flags.TZ)
        }</span>

        <span class="cov8" title="1">if flags.SessionTag </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("NewLocalFiles - Branch 5/7 Covered")
                flags.session = fmt.Sprintf("{immich-go}/%s", time.Now().Format("2006-01-02 15:04:05"))
        }</span>

        // if flags.ExifToolFlags.UseExifTool {
        //         err := exif.NewExifTool(&amp;flags.ExifToolFlags)
        //         if err != nil {
        //                 return nil, err
        //         }
        // }

        <span class="cov8" title="1">if flags.ManageEpsonFastFoto </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("NewLocalFiles - Branch 6/7 Covered")
                g := epsonfastfoto.Group{}
                la.groupers = append(la.groupers, g.Group)
        }</span>
        <span class="cov8" title="1">if flags.ManageBurst != filters.BurstNothing </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("NewLocalFiles - Branch 7/7 Covered")
                la.groupers = append(la.groupers, burst.Group)
        }</span>
        <span class="cov8" title="1">la.groupers = append(la.groupers, series.Group)

        return &amp;la, nil</span>
}

func (la *LocalAssetBrowser) Browse(ctx context.Context) chan *assets.Group <span class="cov8" title="1">{
        gOut := make(chan *assets.Group)
        go func() </span><span class="cov8" title="1">{
                defer close(gOut)
                for _, fsys := range la.fsyss </span><span class="cov8" title="1">{
                        la.concurrentParseDir(ctx, fsys, ".", gOut)
                }</span>
                <span class="cov8" title="1">la.wg.Wait()
                la.pool.Stop()</span>
        }()
        <span class="cov8" title="1">return gOut</span>
}

func (la *LocalAssetBrowser) concurrentParseDir(ctx context.Context, fsys fs.FS, dir string, gOut chan *assets.Group) <span class="cov8" title="1">{
        la.wg.Add(1)
        ctx, cancel := context.WithCancelCause(ctx)
        go la.pool.Submit(func() </span><span class="cov8" title="1">{
                defer la.wg.Done()
                err := la.parseDir(ctx, fsys, dir, gOut)
                if err != nil </span><span class="cov0" title="0">{
                        la.log.Log().Error(err.Error())
                        cancel(err)
                }</span>
        })
}

func (la *LocalAssetBrowser) parseDir(ctx context.Context, fsys fs.FS, dir string, gOut chan *assets.Group) error <span class="cov8" title="1">{
        coverageTester.WriteUniqueLine("parseDir - Branch 0/53 Covered")

        fsName := ""
        if fsys, ok := fsys.(interface{ Name() string }); ok </span><span class="cov8" title="1">{
                coverageTester.WriteUniqueLine("parseDir - Branch 1/53 Covered")
                fsName = fsys.Name()
        }</span>

        <span class="cov8" title="1">var as []*assets.Asset
        var entries []fs.DirEntry
        var err error

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                coverageTester.WriteUniqueLine("parseDir - Branch 2/53 Covered")
                return ctx.Err()</span>
        default:<span class="cov8" title="1">
                entries, err = fs.ReadDir(fsys, dir)
                if err != nil </span><span class="cov0" title="0">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 3/53 Covered")
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                base := entry.Name()
                name := path.Join(dir, base)
                if entry.IsDir() </span><span class="cov8" title="1">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 4/53 Covered")
                        continue</span>
                }

                <span class="cov8" title="1">if la.flags.BannedFiles.Match(name) </span><span class="cov8" title="1">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 5/53 Covered")
                        la.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(fsys, entry.Name()), "reason", "banned file")
                        continue</span>
                }

                <span class="cov8" title="1">if la.flags.SupportedMedia.IsUseLess(name) </span><span class="cov8" title="1">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 6/53 Covered")
                        la.log.Record(ctx, fileevent.DiscoveredUseless, fshelper.FSName(fsys, entry.Name()))
                        continue</span>
                }

                <span class="cov8" title="1">if la.flags.PicasaAlbum &amp;&amp; (strings.ToLower(base) == ".picasa.ini" || strings.ToLower(base) == "picasa.ini") </span><span class="cov0" title="0">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 7/53 Covered")
                        a, err := ReadPicasaIni(fsys, name)
                        if err != nil </span><span class="cov0" title="0">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 8/53 Covered")
                                la.log.Record(ctx, fileevent.Error, fshelper.FSName(fsys, name), "error", err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                coverageTester.WriteUniqueLine("parseDir - Branch 9/53 Covered")
                                la.picasaAlbums.Store(dir, a) // la.picasaAlbums[dir] = a
                                la.log.Log().Info("Picasa album detected", "file", fshelper.FSName(fsys, path.Join(dir, name)), "album", a.Name)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">ext := filepath.Ext(base)
                mediaType := la.flags.SupportedMedia.TypeFromExt(ext)

                if mediaType == filetypes.TypeUnknown </span><span class="cov0" title="0">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 10/53 Covered")
                        la.log.Record(ctx, fileevent.DiscoveredUnsupported, fshelper.FSName(fsys, name), "reason", "unsupported file type")
                        continue</span>
                }

                <span class="cov8" title="1">switch mediaType </span>{
                case filetypes.TypeUseless:<span class="cov8" title="1">
                        coverageTester.WriteUniqueLine("parseDir - Branch 11/53 Covered")
                        la.log.Record(ctx, fileevent.DiscoveredUseless, fshelper.FSName(fsys, name))
                        continue</span>
                case filetypes.TypeImage:<span class="cov8" title="1">
                        coverageTester.WriteUniqueLine("parseDir - Branch 12/53 Covered")
                        la.log.Record(ctx, fileevent.DiscoveredImage, fshelper.FSName(fsys, name))</span>
                case filetypes.TypeVideo:<span class="cov8" title="1">
                        coverageTester.WriteUniqueLine("parseDir - Branch 13/53 Covered")
                        la.log.Record(ctx, fileevent.DiscoveredVideo, fshelper.FSName(fsys, name))</span>
                case filetypes.TypeSidecar:<span class="cov0" title="0">
                        coverageTester.WriteUniqueLine("parseDir - Branch 14/53 Covered")
                        if la.flags.IgnoreSideCarFiles </span><span class="cov0" title="0">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 15/53 Covered")
                                la.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(fsys, name), "reason", "sidecar file ignored")
                                continue</span>
                        }
                        <span class="cov0" title="0">la.log.Record(ctx, fileevent.DiscoveredSidecar, fshelper.FSName(fsys, name))
                        continue</span>
                }

                <span class="cov8" title="1">if !la.flags.InclusionFlags.IncludedExtensions.Include(ext) </span><span class="cov8" title="1">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 16/53 Covered")
                        la.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(fsys, name), "reason", "extension not included")
                        continue</span>
                }

                <span class="cov8" title="1">if la.flags.InclusionFlags.ExcludedExtensions.Exclude(ext) </span><span class="cov8" title="1">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 17/53 Covered")
                        la.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(fsys, name), "reason", "extension excluded")
                        continue</span>
                }

                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        coverageTester.WriteUniqueLine("parseDir - Branch 18/53 Covered")
                        return ctx.Err()</span>
                default:<span class="cov8" title="1">
                        // we have a file to process
                        a, err := la.assetFromFile(ctx, fsys, name)
                        if err != nil </span><span class="cov0" title="0">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 19/53 Covered")
                                la.log.Record(ctx, fileevent.Error, fshelper.FSName(fsys, name), "error", err.Error())
                                return err
                        }</span>
                        <span class="cov8" title="1">if a != nil </span><span class="cov8" title="1">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 20/53 Covered")
                                as = append(as, a)
                        }</span>
                }
        }

        // process the left over dirs
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                base := entry.Name()
                name := path.Join(dir, base)
                if entry.IsDir() </span><span class="cov8" title="1">{
                        coverageTester.WriteUniqueLine("parseDir - Branch 21/53 Covered")
                        if la.flags.BannedFiles.Match(name) </span><span class="cov8" title="1">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 22/53 Covered")
                                la.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(fsys, name), "reason", "banned folder")
                                continue</span> // Skip this folder, no error
                        }
                        <span class="cov8" title="1">if la.flags.Recursive &amp;&amp; entry.Name() != "." </span><span class="cov8" title="1">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 23/53 Covered")
                                la.concurrentParseDir(ctx, fsys, name, gOut)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
        }

        <span class="cov8" title="1">in := make(chan *assets.Asset)
        go func() </span><span class="cov8" title="1">{
                defer close(in)

                sort.Slice(as, func(i, j int) bool </span><span class="cov8" title="1">{
                        // Sort by radical first
                        radicalI := as[i].Radical
                        radicalJ := as[j].Radical
                        if radicalI != radicalJ </span><span class="cov8" title="1">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 24/53 Covered")
                                return radicalI &lt; radicalJ
                        }</span>
                        // If radicals are the same, sort by date
                        <span class="cov8" title="1">return as[i].CaptureDate.Before(as[j].CaptureDate)</span>
                })

                <span class="cov8" title="1">for _, a := range as </span><span class="cov8" title="1">{
                        // check the presence of a JSON file
                        jsonName, err := checkExistSideCar(fsys, a.File.Name(), ".json")
                        if err == nil &amp;&amp; jsonName != "" </span><span class="cov0" title="0">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 25/53 Covered")
                                buf, err := fs.ReadFile(fsys, jsonName)
                                if err != nil </span><span class="cov0" title="0">{
                                        coverageTester.WriteUniqueLine("parseDir - Branch 26/53 Covered")
                                        la.log.Record(ctx, fileevent.Error, nil, "error", err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        if bytes.Contains(buf, []byte("immich-go version")) </span><span class="cov0" title="0">{
                                                coverageTester.WriteUniqueLine("parseDir - Branch 27/53 Covered")
                                                md := &amp;assets.Metadata{}
                                                err = jsonsidecar.Read(bytes.NewReader(buf), md)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        coverageTester.WriteUniqueLine("parseDir - Branch 28/53 Covered")
                                                        la.log.Record(ctx, fileevent.Error, nil, "error", err.Error())
                                                }</span> else<span class="cov0" title="0"> {
                                                        md.File = fshelper.FSName(fsys, jsonName)
                                                        a.FromApplication = a.UseMetadata(md) // Force the use of the metadata coming from immich export
                                                        a.OriginalFileName = md.FileName      // Force the name of the file to be the one from the JSON file
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                la.log.Log().Warn("JSON file detected but not from immich-go", "file", fshelper.FSName(fsys, jsonName))
                                        }</span>
                                }
                        }
                        // check the presence of a XMP file
                        <span class="cov8" title="1">xmpName, err := checkExistSideCar(fsys, a.File.Name(), ".xmp")
                        if err == nil &amp;&amp; xmpName != "" </span><span class="cov0" title="0">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 29/53 Covered")
                                buf, err := fs.ReadFile(fsys, xmpName)
                                if err != nil </span><span class="cov0" title="0">{
                                        coverageTester.WriteUniqueLine("parseDir - Branch 30/53 Covered")
                                        la.log.Record(ctx, fileevent.Error, nil, "error", err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        md := &amp;assets.Metadata{}
                                        err = xmpsidecar.ReadXMP(bytes.NewReader(buf), md)
                                        if err != nil </span><span class="cov0" title="0">{
                                                coverageTester.WriteUniqueLine("parseDir - Branch 31/53 Covered")
                                                la.log.Record(ctx, fileevent.Error, nil, "error", err.Error())
                                        }</span> else<span class="cov0" title="0"> {
                                                md.File = fshelper.FSName(fsys, xmpName)
                                                a.FromSideCar = a.UseMetadata(md)
                                        }</span>
                                }
                        }

                        // Read metadata from the file only id needed (date range or take date from filename)
                        <span class="cov8" title="1">if la.requiresDateInformation </span><span class="cov8" title="1">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 32/53 Covered")
                                if a.CaptureDate.IsZero() </span><span class="cov8" title="1">{
                                        coverageTester.WriteUniqueLine("parseDir - Branch 33/53 Covered")
                                        // no date in XMP, JSON, try reading the metadata
                                        f, err := a.OpenFile()
                                        if err == nil </span><span class="cov8" title="1">{
                                                coverageTester.WriteUniqueLine("parseDir - Branch 34/53 Covered")
                                                md, err := exif.GetMetaData(f, a.Ext, la.flags.TZ)
                                                if err != nil </span><span class="cov8" title="1">{
                                                        coverageTester.WriteUniqueLine("parseDir - Branch 35/53 Covered")
                                                        la.log.Record(ctx, fileevent.INFO, a.File, "warning", err.Error())
                                                }</span> else<span class="cov8" title="1"> {
                                                        a.FromSourceFile = a.UseMetadata(md)
                                                }</span>
                                                <span class="cov8" title="1">if (md == nil || md.DateTaken.IsZero()) &amp;&amp; !a.NameInfo.Taken.IsZero() &amp;&amp; la.flags.TakeDateFromFilename </span><span class="cov8" title="1">{
                                                        coverageTester.WriteUniqueLine("parseDir - Branch 36/53 Covered")
                                                        // no exif, but we have a date in the filename and the TakeDateFromFilename is set
                                                        a.FromApplication = &amp;assets.Metadata{
                                                                DateTaken: a.NameInfo.Taken,
                                                        }
                                                        a.CaptureDate = a.FromApplication.DateTaken
                                                }</span>
                                                <span class="cov8" title="1">f.Close()</span>
                                        }
                                }
                        }

                        <span class="cov8" title="1">if !la.flags.InclusionFlags.DateRange.InRange(a.CaptureDate) </span><span class="cov8" title="1">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 37/53 Covered")
                                a.Close()
                                la.log.Record(ctx, fileevent.DiscoveredDiscarded, a.File, "reason", "asset outside date range")
                                continue</span>
                        }

                        // Add tags
                        <span class="cov8" title="1">if len(la.flags.Tags) &gt; 0 </span><span class="cov8" title="1">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 38/53 Covered")
                                for _, t := range la.flags.Tags </span><span class="cov8" title="1">{
                                        a.AddTag(t)
                                }</span>
                        }

                        // Add folder as tags
                        <span class="cov8" title="1">if la.flags.FolderAsTags </span><span class="cov8" title="1">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 39/53 Covered")
                                t := fsName
                                if dir != "." </span><span class="cov8" title="1">{
                                        coverageTester.WriteUniqueLine("parseDir - Branch 40/53 Covered")
                                        t = path.Join(t, dir)
                                }</span>
                                <span class="cov8" title="1">if t != "" </span><span class="cov8" title="1">{
                                        coverageTester.WriteUniqueLine("parseDir - Branch 41/53 Covered")
                                        a.AddTag(t)
                                }</span>
                        }

                        // Manage albums
                        <span class="cov8" title="1">if la.flags.ImportIntoAlbum != "" </span><span class="cov0" title="0">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 42/53 Covered")
                                a.Albums = []assets.Album{{Title: la.flags.ImportIntoAlbum}}
                        }</span> else<span class="cov8" title="1"> {
                                done := false
                                if la.flags.PicasaAlbum </span><span class="cov0" title="0">{
                                        coverageTester.WriteUniqueLine("parseDir - Branch 43/53 Covered")
                                        if album, ok := la.picasaAlbums.Load(dir); ok </span><span class="cov0" title="0">{
                                                coverageTester.WriteUniqueLine("parseDir - Branch 44/53 Covered")
                                                a.Albums = []assets.Album{{Title: album.Name, Description: album.Description}}
                                                done = true
                                        }</span>
                                }
                                <span class="cov8" title="1">if !done &amp;&amp; la.flags.UsePathAsAlbumName != FolderModeNone &amp;&amp; la.flags.UsePathAsAlbumName != "" </span><span class="cov8" title="1">{
                                        coverageTester.WriteUniqueLine("parseDir - Branch 45/53 Covered")
                                        Album := ""
                                        switch la.flags.UsePathAsAlbumName </span>{
                                        case FolderModeFolder:<span class="cov8" title="1">
                                                coverageTester.WriteUniqueLine("parseDir - Branch 46/53 Covered")
                                                if dir == "." </span><span class="cov8" title="1">{
                                                        coverageTester.WriteUniqueLine("parseDir - Branch 47/53 Covered")
                                                        Album = fsName
                                                }</span> else<span class="cov8" title="1"> {
                                                        Album = filepath.Base(dir)
                                                }</span>
                                        case FolderModePath:<span class="cov8" title="1">
                                                coverageTester.WriteUniqueLine("parseDir - Branch 48/53 Covered")
                                                parts := []string{}
                                                if fsName != "" </span><span class="cov8" title="1">{
                                                        coverageTester.WriteUniqueLine("parseDir - Branch 49/53 Covered")
                                                        parts = append(parts, fsName)
                                                }</span>
                                                <span class="cov8" title="1">if dir != "." </span><span class="cov8" title="1">{
                                                        coverageTester.WriteUniqueLine("parseDir - Branch 50/53 Covered")
                                                        parts = append(parts, strings.Split(dir, "/")...)
                                                        // parts = append(parts, strings.Split(dir, string(filepath.Separator))...)
                                                }</span>
                                                <span class="cov8" title="1">Album = strings.Join(parts, la.flags.AlbumNamePathSeparator)</span>
                                        }
                                        <span class="cov8" title="1">a.Albums = []assets.Album{{Title: Album}}</span>
                                }
                        }

                        <span class="cov8" title="1">if la.flags.SessionTag </span><span class="cov0" title="0">{
                                coverageTester.WriteUniqueLine("parseDir - Branch 51/53 Covered")
                                a.AddTag(la.flags.session)
                        }</span>
                        <span class="cov8" title="1">select </span>{
                        case in &lt;- a:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                coverageTester.WriteUniqueLine("parseDir - Branch 52/53 Covered")
                                return</span>
                        }
                }
        }()

        <span class="cov8" title="1">gs := groups.NewGrouperPipeline(ctx, la.groupers...).PipeGrouper(ctx, in)
        for g := range gs </span><span class="cov8" title="1">{
                select </span>{
                case gOut &lt;- g:<span class="cov8" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        coverageTester.WriteUniqueLine("parseDir - Branch 53/53 Covered")
                        return ctx.Err()</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func checkExistSideCar(fsys fs.FS, name string, ext string) (string, error) <span class="cov8" title="1">{
        ext2 := ""
        for _, r := range ext </span><span class="cov8" title="1">{
                if r == '.' </span><span class="cov8" title="1">{
                        ext2 += "."
                        continue</span>
                }
                <span class="cov8" title="1">ext2 += "[" + strings.ToLower(string(r)) + strings.ToUpper(string(r)) + "]"</span>
        }

        <span class="cov8" title="1">base := name
        l, err := fs.Glob(fsys, base+ext2)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(l) &gt; 0 </span><span class="cov0" title="0">{
                return l[0], nil
        }</span>

        <span class="cov8" title="1">ext = path.Ext(base)
        if !filetypes.DefaultSupportedMedia.IsMedia(ext) </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">base = strings.TrimSuffix(base, ext)

        l, err = fs.Glob(fsys, base+ext2)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(l) &gt; 0 </span><span class="cov0" title="0">{
                return l[0], nil
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

func (la *LocalAssetBrowser) assetFromFile(_ context.Context, fsys fs.FS, name string) (*assets.Asset, error) <span class="cov8" title="1">{
        a := &amp;assets.Asset{
                File:             fshelper.FSName(fsys, name),
                OriginalFileName: filepath.Base(name),
        }
        i, err := fs.Stat(fsys, name)
        if err != nil </span><span class="cov0" title="0">{
                a.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">a.FileSize = int(i.Size())
        a.FileDate = i.ModTime()

        n := path.Dir(name) + "/" + a.OriginalFileName
        if fsys, ok := fsys.(interface{ Name() string }); ok </span><span class="cov8" title="1">{
                n = path.Join(fsys.Name(), n)
        }</span>

        <span class="cov8" title="1">a.SetNameInfo(la.flags.InfoCollector.GetInfo(n))
        return a, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package folder

import (
        "context"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path"

        "github.com/simulot/immich-go/coverageTester"
        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/exif/sidecars/jsonsidecar"
        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/simulot/immich-go/internal/fshelper/debugfiles"
)

// type minimalFSWriter interface {
//         fs.FS
//         fshelper.FSCanWrite
// }

type closer interface {
        Close() error
}
type LocalAssetWriter struct {
        WriteToFS  fs.FS
        createdDir map[string]struct{}
}

func NewLocalAssetWriter(fsys fs.FS, writeToPath string) (*LocalAssetWriter, error) <span class="cov0" title="0">{
        if _, ok := fsys.(fshelper.FSCanWrite); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("FS does not support writing")
        }</span>
        <span class="cov0" title="0">return &amp;LocalAssetWriter{
                WriteToFS:  fsys,
                createdDir: make(map[string]struct{}),
        }, nil</span>
}

func (w *LocalAssetWriter) WriteGroup(ctx context.Context, group *assets.Group) error <span class="cov0" title="0">{
        var err error

        if fsys, ok := w.WriteToFS.(closer); ok </span><span class="cov0" title="0">{
                defer fsys.Close()
        }</span>
        <span class="cov0" title="0">for _, a := range group.Assets </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return errors.Join(err, ctx.Err())</span>
                default:<span class="cov0" title="0">
                        err = errors.Join(err, w.WriteAsset(ctx, a))</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func (w *LocalAssetWriter) WriteAsset(ctx context.Context, a *assets.Asset) error <span class="cov0" title="0">{

        coverageTester.WriteUniqueLine("WriteAsset - Branch 0 (Main) Covered")

        base := a.Base
        dir := w.pathOfAsset(a)
        if _, ok := w.createdDir[dir]; !ok </span><span class="cov0" title="0">{ // Branch 1
                coverageTester.WriteUniqueLine("WriteAsset - Branch 1 Covered of 16 possible")

                err := fshelper.MkdirAll(w.WriteToFS, dir, 0o755)
                if err != nil </span><span class="cov0" title="0">{ // Branch 2
                        coverageTester.WriteUniqueLine("WriteAsset - Branch 2 Covered of 16 possible")
                        return err
                }</span>
                <span class="cov0" title="0">w.createdDir[dir] = struct{}{}</span>
        }
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0"> // Branch 3
                coverageTester.WriteUniqueLine("WriteAsset - Branch 3 Covered of 16 possible")
                return ctx.Err()</span>
        default:<span class="cov0" title="0">
                r, err := a.OpenFile()
                if err != nil </span><span class="cov0" title="0">{ // Branch 4
                        coverageTester.WriteUniqueLine("WriteAsset - Branch 4 Covered of 16 possible")
                        return err
                }</span>
                <span class="cov0" title="0">defer r.Close()

                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0"> // Branch 5
                        coverageTester.WriteUniqueLine("WriteAsset - Branch 5 Covered of 16 possible")
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        // Add an index to the file name if it already exists, or the XMP or JSON
                        index := 0
                        ext := path.Ext(base)
                        radical := base[:len(base)-len(ext)]
                        for </span><span class="cov0" title="0">{ // Branch 6
                                coverageTester.WriteUniqueLine("WriteAsset - Branch 6 Covered of 16  possible")
                                if index &gt; 0 </span><span class="cov0" title="0">{ // Branch 7
                                        coverageTester.WriteUniqueLine("WriteAsset - Branch 7 Covered of 16 possible")
                                        base = fmt.Sprintf("%s~%d%s", radical, index, path.Ext(base))
                                }</span>
                                <span class="cov0" title="0">_, err := fs.Stat(w.WriteToFS, path.Join(dir, base))
                                if err == nil </span><span class="cov0" title="0">{ // Branch 8
                                        coverageTester.WriteUniqueLine("WriteAsset - Branch 8 Covered of 16 possible")
                                        index++
                                        continue</span>
                                }
                                <span class="cov0" title="0">_, err = fs.Stat(w.WriteToFS, path.Join(dir, base+".XMP"))
                                if err == nil </span><span class="cov0" title="0">{ // Branch 9
                                        coverageTester.WriteUniqueLine("WriteAsset - Branch 9 Covered of 16 possible")
                                        index++
                                        continue</span>
                                }
                                <span class="cov0" title="0">_, err = fs.Stat(w.WriteToFS, path.Join(dir, base+".JSON"))
                                if err == nil </span><span class="cov0" title="0">{ // Branch 10
                                        coverageTester.WriteUniqueLine("WriteAsset - Branch 10 Covered of 16 possible")
                                        index++
                                        continue</span>
                                }
                                <span class="cov0" title="0">break</span>
                        }

                        // write the asset
                        <span class="cov0" title="0">err = fshelper.WriteFile(w.WriteToFS, path.Join(dir, base), r)
                        if err != nil </span><span class="cov0" title="0">{ // Branch 11
                                coverageTester.WriteUniqueLine("WriteAsset - Branch 11 Covered of 16 possible")
                                return err
                        }</span>
                        // XMP?
                        <span class="cov0" title="0">if a.FromSideCar != nil </span><span class="cov0" title="0">{ // Branch 12
                                coverageTester.WriteUniqueLine("WriteAsset - Branch 12 Covered of 16 possible")
                                // Sidecar file is set, copy it
                                var scr fs.File
                                scr, err = a.FromSideCar.File.Open()
                                if err != nil </span><span class="cov0" title="0">{ // Branch 13
                                        coverageTester.WriteUniqueLine("WriteAsset - Branch 13 Covered of 16 possible")
                                        return err
                                }</span>
                                <span class="cov0" title="0">debugfiles.TrackOpenFile(scr, a.FromSideCar.File.Name())
                                defer scr.Close()
                                defer debugfiles.TrackCloseFile(scr)
                                var scw fshelper.WFile
                                scw, err = fshelper.OpenFile(w.WriteToFS, path.Join(dir, base+".XMP"), os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o644)
                                if err != nil </span><span class="cov0" title="0">{ // Branch 14
                                        coverageTester.WriteUniqueLine("WriteAsset - Branch 14 Covered of 16 possible")
                                        return err
                                }</span>
                                <span class="cov0" title="0">_, err = io.Copy(scw, scr)
                                scw.Close()</span>
                        }

                        // Having metadata from an Application or immich-go JSON?
                        <span class="cov0" title="0">if a.FromApplication != nil </span><span class="cov0" title="0">{ // Branch 15
                                coverageTester.WriteUniqueLine("WriteAsset - Branch 15 Covered of 16 possible")
                                var scw fshelper.WFile
                                scw, err = fshelper.OpenFile(w.WriteToFS, path.Join(dir, base+".JSON"), os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o644)
                                if err != nil </span><span class="cov0" title="0">{ // Branch 16
                                        coverageTester.WriteUniqueLine("WriteAsset - Branch 16 Covered of 16 possible")
                                        return err
                                }</span>
                                <span class="cov0" title="0">err = jsonsidecar.Write(a.FromApplication, scw)
                                scw.Close()</span>
                        }

                        <span class="cov0" title="0">return err</span>
                }
        }
}

func (w *LocalAssetWriter) pathOfAsset(a *assets.Asset) string <span class="cov0" title="0">{
        d := a.CaptureDate
        if d.IsZero() </span><span class="cov0" title="0">{
                return "no-date"
        }</span>
        <span class="cov0" title="0">p := path.Join(fmt.Sprintf("%04d", d.Year()), fmt.Sprintf("%04d-%02d", d.Year(), d.Month()))
        return p</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package fromimmich

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/coverageTester"
        "github.com/simulot/immich-go/immich"
        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/fileevent"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/simulot/immich-go/internal/immichfs"
)

type FromImmich struct {
        flags *FromImmichFlags
        // client *app.Client
        ifs *immichfs.ImmichFS
        ic  *filenames.InfoCollector

        mustFetchAlbums bool // True if we need to fetch the asset's albums in 2nd step
        errCount        int  // Count the number of errors, to stop after 5
}

func NewFromImmich(ctx context.Context, app *app.Application, jnl *fileevent.Recorder, flags *FromImmichFlags) (*FromImmich, error) <span class="cov0" title="0">{
        client := &amp;flags.client
        err := client.Initialize(ctx, app)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = client.Open(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ifs := immichfs.NewImmichFS(ctx, flags.client.Server, client.Immich)
        f := FromImmich{
                flags: flags,
                ifs:   ifs,
                ic:    filenames.NewInfoCollector(time.Local, client.Immich.SupportedMedia()),
        }
        return &amp;f, nil</span>
}

func (f *FromImmich) Browse(ctx context.Context) chan *assets.Group <span class="cov0" title="0">{
        gOut := make(chan *assets.Group)
        go func() </span><span class="cov0" title="0">{
                defer close(gOut)
                var err error
                switch </span>{
                case len(f.flags.Albums) &gt; 0:<span class="cov0" title="0">
                        err = f.getAssetsFromAlbums(ctx, gOut)</span>
                default:<span class="cov0" title="0">
                        err = f.getAssets(ctx, gOut)</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        f.flags.client.ClientLog.Error(fmt.Sprintf("Error while getting Immich assets: %v", err))
                }</span>
        }()
        <span class="cov0" title="0">return gOut</span>
}

const timeFormat = "2006-01-02T15:04:05.000Z"

func (f *FromImmich) getAssets(ctx context.Context, grpChan chan *assets.Group) error <span class="cov0" title="0">{
        query := immich.SearchMetadataQuery{
                Make:  f.flags.Make,
                Model: f.flags.Model,
                // WithExif:     true,
                WithArchived: f.flags.WithArchived,
        }

        f.mustFetchAlbums = true
        if f.flags.DateRange.IsSet() </span><span class="cov0" title="0">{
                query.TakenAfter = f.flags.DateRange.After.Format(timeFormat)
                query.TakenBefore = f.flags.DateRange.Before.Format(timeFormat)
        }</span>

        <span class="cov0" title="0">return f.flags.client.Immich.GetAllAssetsWithFilter(ctx, &amp;query, func(a *immich.Asset) error </span><span class="cov0" title="0">{
                if f.flags.Favorite &amp;&amp; !a.IsFavorite </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if !f.flags.WithTrashed &amp;&amp; a.IsTrashed </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return f.filterAsset(ctx, a, grpChan)</span>
        })
}

func (f *FromImmich) getAssetsFromAlbums(ctx context.Context, grpChan chan *assets.Group) error <span class="cov0" title="0">{
        f.mustFetchAlbums = false

        assets := map[string]*immich.Asset{} // List of assets to get by ID

        albums, err := f.flags.client.Immich.GetAllAlbums(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return f.logError(err)
        }</span>
        <span class="cov0" title="0">for _, album := range albums </span><span class="cov0" title="0">{
                for _, albumName := range f.flags.Albums </span><span class="cov0" title="0">{
                        if album.Title == albumName </span><span class="cov0" title="0">{
                                al, err := f.flags.client.Immich.GetAlbumInfo(ctx, album.ID, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return f.logError(err)
                                }</span>
                                <span class="cov0" title="0">for _, a := range al.Assets </span><span class="cov0" title="0">{
                                        if _, ok := assets[a.ID]; !ok </span><span class="cov0" title="0">{
                                                a.Albums = append(a.Albums, immich.AlbumSimplified{
                                                        AlbumName: album.Title,
                                                })
                                                assets[a.ID] = a
                                        }</span> else<span class="cov0" title="0"> {
                                                assets[a.ID].Albums = append(assets[a.ID].Albums, immich.AlbumSimplified{
                                                        AlbumName: album.Title,
                                                })
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">for _, a := range assets </span><span class="cov0" title="0">{
                err = f.filterAsset(ctx, a, grpChan)
                if err != nil </span><span class="cov0" title="0">{
                        return f.logError(err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (f *FromImmich) filterAsset(ctx context.Context, a *immich.Asset, grpChan chan *assets.Group) error <span class="cov0" title="0">{
        var err error
        if f.flags.Favorite &amp;&amp; !a.IsFavorite </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("Branch 1")
                return nil
        }</span>

        <span class="cov0" title="0">if !f.flags.WithTrashed &amp;&amp; a.IsTrashed </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("Branch 2")
                return nil
        }</span>

        <span class="cov0" title="0">albums := immich.AlbumsFromAlbumSimplified(a.Albums)

        if f.mustFetchAlbums &amp;&amp; len(albums) == 0 </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("Branch 3")
                albums, err = f.flags.client.Immich.GetAssetAlbums(ctx, a.ID)
                if err != nil </span><span class="cov0" title="0">{
                        coverageTester.WriteUniqueLine("Branch 4")
                        return f.logError(err)
                }</span>
        }
        <span class="cov0" title="0">if len(f.flags.Albums) &gt; 0 &amp;&amp; len(albums) &gt; 0 </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("Branch 5")
                keepMe := false
                newAlbumList := []assets.Album{}
                for _, album := range f.flags.Albums </span><span class="cov0" title="0">{
                        coverageTester.WriteUniqueLine("Branch 6")
                        for _, aAlbum := range albums </span><span class="cov0" title="0">{
                                coverageTester.WriteUniqueLine("Branch 7")
                                if album == aAlbum.Title </span><span class="cov0" title="0">{
                                        coverageTester.WriteUniqueLine("Branch 8")
                                        keepMe = true
                                        newAlbumList = append(newAlbumList, aAlbum)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if !keepMe </span><span class="cov0" title="0">{
                        coverageTester.WriteUniqueLine("Branch 9")
                        return nil
                }</span>
                <span class="cov0" title="0">albums = newAlbumList</span>
        }

        // Some information are missing in the metadata result,
        // so we need to get the asset details

        <span class="cov0" title="0">a, err = f.flags.client.Immich.GetAssetInfo(ctx, a.ID)
        if err != nil </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("Branch 10")
                return f.logError(err)
        }</span>
        <span class="cov0" title="0">asset := a.AsAsset()
        asset.SetNameInfo(f.ic.GetInfo(asset.OriginalFileName))
        asset.File = fshelper.FSName(f.ifs, a.ID)

        asset.FromApplication = &amp;assets.Metadata{
                FileName:    a.OriginalFileName,
                Latitude:    a.ExifInfo.Latitude,
                Longitude:   a.ExifInfo.Longitude,
                Description: a.ExifInfo.Description,
                DateTaken:   a.ExifInfo.DateTimeOriginal.Time,
                Trashed:     a.IsTrashed,
                Archived:    a.IsArchived,
                Favorited:   a.IsFavorite,
                Rating:      byte(a.Rating),
                Albums:      albums,
                Tags:        asset.Tags,
        }

        if f.flags.MinimalRating &gt; 0 &amp;&amp; a.Rating &lt; f.flags.MinimalRating </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("Branch 11")
                return nil
        }</span>

        <span class="cov0" title="0">if f.flags.DateRange.IsSet() </span><span class="cov0" title="0">{
                coverageTester.WriteUniqueLine("Branch 12")
                if asset.CaptureDate.Before(f.flags.DateRange.After) || asset.CaptureDate.After(f.flags.DateRange.Before) </span><span class="cov0" title="0">{
                        coverageTester.WriteUniqueLine("Branch 13")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">g := assets.NewGroup(assets.GroupByNone, asset)
        select </span>{
        case grpChan &lt;- g:<span class="cov0" title="0">
                coverageTester.WriteUniqueLine("Branch 14")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                coverageTester.WriteUniqueLine("Branch 15")
                return ctx.Err()</span>
        }
        <span class="cov0" title="0">coverageTester.WriteUniqueLine("Branch 16")
        return nil</span>
}

func (f *FromImmich) logError(err error) error <span class="cov0" title="0">{
        f.flags.client.ClientLog.Error(fmt.Sprintf("Error while getting Immich assets: %v", err))
        f.errCount++
        if f.errCount &gt; 5 </span><span class="cov0" title="0">{
                err := errors.New("too many errors, aborting")
                f.flags.client.ClientLog.Error(err.Error())
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package fromimmich

import (
        "time"

        "github.com/simulot/immich-go/app"
        cliflags "github.com/simulot/immich-go/internal/cliFlags"
        "github.com/spf13/cobra"
)

type FromImmichFlags struct {
        DateRange     cliflags.DateRange // get assets only within this date range  (fromat: YYYY-MM-DD,YYYY-MM-DD)
        Albums        []string           // get assets only from those albums
        Tags          []string           // get assets only with those tags
        WithArchived  bool               // get archived assets too
        WithTrashed   bool               // get trashed assets too
        Favorite      bool               // get only favorite assets
        MinimalRating int                // get only assets with a rating greater or equal to this value
        Make          string             // get only assets with this make
        Model         string             // get only assets with this model
        client        app.Client         // client to use for the import
}

func (o *FromImmichFlags) AddFromImmichFlags(cmd *cobra.Command, parent *cobra.Command) <span class="cov0" title="0">{
        // cmd.Flags().StringVar(&amp;o.Make, "from-make", "", "Get only assets with this make")
        // cmd.Flags().StringVar(&amp;o.Model, "from-model", "", "Get only assets with this model")
        cmd.Flags().StringSliceVar(&amp;o.Albums, "from-album", nil, "Get assets only from those albums, can be used multiple times")
        // cmd.Flags().StringSliceVar(&amp;o.Tags, "from-tags", nil, "Get assets only with those tags")
        cmd.Flags().Var(&amp;o.DateRange, "from-date-range", "Get assets only within this date range (fromat: YYYY[-MM[-DD[,YYYY-MM-DD]]])")
        // cmd.Flags().BoolVar(&amp;o.WithArchived, "from-archived", false, "Get archived assets too")
        // cmd.Flags().BoolVar(&amp;o.WithTrashed, "from-trashed", false, "Get trashed assets too")
        // cmd.Flags().BoolVar(&amp;o.Favorite, "from-favorite", false, "Get only favorite assets")
        // cmd.Flags().IntVar(&amp;o.MinimalRating, "from-minimal-rating", 0, "Get only assets with a rating greater or equal to this value")

        cmd.Flags().StringVar(&amp;o.client.Server, "from-server", o.client.Server, "Immich server address (example http://your-ip:2283 or https://your-domain)")
        cmd.Flags().StringVar(&amp;o.client.APIKey, "from-api-key", "", "API Key")
        cmd.Flags().BoolVar(&amp;o.client.APITrace, "from-api-trace", false, "Enable trace of api calls")
        cmd.Flags().BoolVar(&amp;o.client.SkipSSL, "from-skip-verify-ssl", false, "Skip SSL verification")
        cmd.Flags().DurationVar(&amp;o.client.ClientTimeout, "from-client-timeout", 5*time.Minute, "Set server calls timeout")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package gp

import (
        "bytes"
        "context"
        "fmt"
        "io/fs"
        "log/slog"
        "path"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/fileevent"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/filetypes"
        "github.com/simulot/immich-go/internal/filters"
        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/simulot/immich-go/internal/gen"
        "github.com/simulot/immich-go/internal/groups"
        "github.com/simulot/immich-go/internal/groups/burst"
        "github.com/simulot/immich-go/internal/groups/epsonfastfoto"
        "github.com/simulot/immich-go/internal/groups/series"
)

type Takeout struct {
        fsyss       []fs.FS
        catalogs    map[string]directoryCatalog                // file catalogs by directory in the set of the all takeout parts
        albums      map[string]assets.Album                    // track album names by folder
        fileTracker *gen.SyncMap[fileKeyTracker, trackingInfo] // map[fileKeyTracker]trackingInfo // key is base name + file size,  value is list of file paths
        // debugLinkedFiles []linkedFiles
        log      *fileevent.Recorder
        flags    *ImportFlags // command-line flags
        groupers []groups.Grouper
}

type fileKeyTracker struct {
        baseName string
        size     int64
}

type trackingInfo struct {
        paths    []string
        count    int
        metadata *assets.Metadata
        status   fileevent.Code
}

func trackerKeySortFunc(a, b fileKeyTracker) int <span class="cov0" title="0">{
        cmp := strings.Compare(a.baseName, b.baseName)
        if cmp != 0 </span><span class="cov0" title="0">{
                return cmp
        }</span>
        <span class="cov0" title="0">return int(a.size) - int(b.size)</span>
}

// directoryCatalog captures all files in a given directory
type directoryCatalog struct {
        jsons          map[string]*assets.Metadata // metadata in the catalog by base name
        unMatchedFiles map[string]*assetFile       // files to be matched map  by base name
        matchedFiles   map[string]*assets.Asset    // files matched by base name
}

// assetFile keep information collected during pass one
type assetFile struct {
        fsys   fs.FS            // Remember in which part of the archive the file is located
        base   string           // Remember the original file name
        length int              // file length in bytes
        date   time.Time        // file modification date
        md     *assets.Metadata // will point to the associated metadata
}

// Implement slog.LogValuer for assetFile
func (af assetFile) LogValue() slog.Value <span class="cov0" title="0">{
        return slog.GroupValue(
                slog.String("base", af.base),
                slog.Int("length", af.length),
                slog.Time("date", af.date),
        )
}</span>

func NewTakeout(ctx context.Context, l *fileevent.Recorder, flags *ImportFlags, fsyss ...fs.FS) (*Takeout, error) <span class="cov8" title="1">{
        to := Takeout{
                fsyss:       fsyss,
                catalogs:    map[string]directoryCatalog{},
                albums:      map[string]assets.Album{},
                fileTracker: gen.NewSyncMap[fileKeyTracker, trackingInfo](), // map[fileKeyTracker]trackingInfo{},
                log:         l,
                flags:       flags,
        }
        if flags.InfoCollector == nil </span><span class="cov0" title="0">{
                flags.InfoCollector = filenames.NewInfoCollector(flags.TZ, flags.SupportedMedia)
        }</span>
        // if flags.ExifToolFlags.UseExifTool {
        //         err := exif.NewExifTool(&amp;flags.ExifToolFlags)
        //         if err != nil {
        //                 return nil, err
        //         }
        // }
        <span class="cov8" title="1">if flags.SessionTag </span><span class="cov0" title="0">{
                flags.session = fmt.Sprintf("{immich-go}/%s", time.Now().Format("2006-01-02 15:04:05"))
        }</span>

        <span class="cov8" title="1">if flags.ManageEpsonFastFoto </span><span class="cov0" title="0">{
                g := epsonfastfoto.Group{}
                to.groupers = append(to.groupers, g.Group)
        }</span>
        <span class="cov8" title="1">if flags.ManageBurst != filters.BurstNothing </span><span class="cov0" title="0">{
                to.groupers = append(to.groupers, burst.Group)
        }</span>
        <span class="cov8" title="1">to.groupers = append(to.groupers, series.Group)

        return &amp;to, nil</span>
}

// Prepare scans all files in all walker to build the file catalog of the archive
// metadata files content is read and kept
// return a channel of asset groups after the puzzle is solved

func (to *Takeout) Browse(ctx context.Context) chan *assets.Group <span class="cov8" title="1">{
        ctx, cancel := context.WithCancelCause(ctx)
        gOut := make(chan *assets.Group)
        go func() </span><span class="cov8" title="1">{
                defer close(gOut)

                for _, w := range to.fsyss </span><span class="cov8" title="1">{
                        err := to.passOneFsWalk(ctx, w)
                        if err != nil </span><span class="cov0" title="0">{
                                cancel(err)
                                return
                        }</span>
                }
                <span class="cov8" title="1">err := to.solvePuzzle(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        cancel(err)
                        return
                }</span>
                <span class="cov8" title="1">err = to.passTwo(ctx, gOut)
                cancel(err)</span>
        }()
        <span class="cov8" title="1">return gOut</span>
}

func (to *Takeout) passOneFsWalk(ctx context.Context, w fs.FS) error <span class="cov8" title="1">{
        err := fs.WalkDir(w, ".", func(name string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1">

                        if d.IsDir() </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">dir, base := path.Split(name)
                        dir = strings.TrimSuffix(dir, "/")
                        ext := strings.ToLower(path.Ext(base))

                        // Exclude files to be ignored before processing
                        if to.flags.BannedFiles.Match(name) </span><span class="cov0" title="0">{
                                to.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(w, name), "reason", "banned file")
                                return nil
                        }</span>

                        <span class="cov8" title="1">if to.flags.SupportedMedia.IsUseLess(name) </span><span class="cov0" title="0">{
                                to.log.Record(ctx, fileevent.DiscoveredUseless, fshelper.FSName(w, name))
                                return nil
                        }</span>

                        <span class="cov8" title="1">if !to.flags.InclusionFlags.IncludedExtensions.Include(ext) </span><span class="cov0" title="0">{
                                to.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(w, name), "reason", "file extension not selected")
                                return nil
                        }</span>
                        <span class="cov8" title="1">if to.flags.InclusionFlags.ExcludedExtensions.Exclude(ext) </span><span class="cov0" title="0">{
                                to.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(w, name), "reason", "file extension not allowed")
                                return nil
                        }</span>

                        <span class="cov8" title="1">dirCatalog, ok := to.catalogs[dir]
                        if !ok </span><span class="cov8" title="1">{
                                dirCatalog.jsons = map[string]*assets.Metadata{}
                                dirCatalog.unMatchedFiles = map[string]*assetFile{}
                                dirCatalog.matchedFiles = map[string]*assets.Asset{}
                        }</span>
                        <span class="cov8" title="1">finfo, err := d.Info()
                        if err != nil </span><span class="cov0" title="0">{
                                to.log.Record(ctx, fileevent.Error, fshelper.FSName(w, name), "error", err.Error())
                                return err
                        }</span>
                        <span class="cov8" title="1">switch ext </span>{
                        case ".json":<span class="cov8" title="1">
                                var md *assets.Metadata
                                b, err := fs.ReadFile(w, name)
                                if err != nil </span><span class="cov0" title="0">{
                                        to.log.Record(ctx, fileevent.Error, fshelper.FSName(w, name), "error", err.Error())
                                        return nil
                                }</span>
                                <span class="cov8" title="1">if bytes.Contains(b, []byte("immich-go version:")) </span><span class="cov0" title="0">{
                                        md, err = assets.UnMarshalMetadata(b)
                                        if err != nil </span><span class="cov0" title="0">{
                                                to.log.Record(ctx, fileevent.DiscoveredUnsupported, fshelper.FSName(w, name), "reason", "unknown JSONfile")
                                        }</span>
                                        <span class="cov0" title="0">md.FileName = base
                                        to.log.Record(ctx, fileevent.DiscoveredSidecar, fshelper.FSName(w, name), "type", "immich-go metadata", "title", md.FileName)
                                        md.File = fshelper.FSName(w, name)</span>
                                } else<span class="cov8" title="1"> {
                                        md, err := fshelper.UnmarshalJSON[GoogleMetaData](b)
                                        if err == nil </span><span class="cov8" title="1">{
                                                switch </span>{
                                                case md.isAsset():<span class="cov8" title="1">
                                                        md := md.AsMetadata(fshelper.FSName(w, name), to.flags.PeopleTag) // Keep metadata
                                                        dirCatalog.jsons[base] = md
                                                        to.log.Log().Debug("Asset JSON", "metadata", md)
                                                        to.log.Record(ctx, fileevent.DiscoveredSidecar, fshelper.FSName(w, name), "type", "asset metadata", "title", md.FileName, "date", md.DateTaken)</span>
                                                case md.isAlbum():<span class="cov8" title="1">
                                                        to.log.Log().Debug("Album JSON", "metadata", md)
                                                        if !to.flags.KeepUntitled &amp;&amp; md.Title == "" </span><span class="cov0" title="0">{
                                                                to.log.Record(ctx, fileevent.DiscoveredUnsupported, fshelper.FSName(w, name), "reason", "discard untitled album")
                                                                return nil
                                                        }</span>
                                                        <span class="cov8" title="1">a := to.albums[dir]
                                                        a.Title = md.Title
                                                        if a.Title == "" </span><span class="cov0" title="0">{
                                                                a.Title = filepath.Base(dir)
                                                        }</span>
                                                        <span class="cov8" title="1">if e := md.Enrichments; e != nil </span><span class="cov0" title="0">{
                                                                a.Description = e.Text
                                                                a.Latitude = e.Latitude
                                                                a.Longitude = e.Longitude
                                                        }</span>
                                                        <span class="cov8" title="1">to.albums[dir] = a
                                                        to.log.Record(ctx, fileevent.DiscoveredSidecar, fshelper.FSName(w, name), "type", "album metadata", "title", md.Title)</span>
                                                default:<span class="cov0" title="0">
                                                        to.log.Record(ctx, fileevent.DiscoveredUnsupported, fshelper.FSName(w, name), "reason", "unknown JSONfile")
                                                        return nil</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                to.log.Record(ctx, fileevent.DiscoveredUnsupported, fshelper.FSName(w, name), "reason", "unknown JSONfile")
                                                return nil
                                        }</span>
                                }
                        default:<span class="cov8" title="1">

                                t := to.flags.SupportedMedia.TypeFromExt(ext)
                                switch t </span>{
                                case filetypes.TypeUseless:<span class="cov8" title="1">
                                        to.log.Record(ctx, fileevent.DiscoveredUseless, fshelper.FSName(w, name), "reason", "useless file")
                                        return nil</span>
                                case filetypes.TypeUnknown:<span class="cov0" title="0">
                                        to.log.Record(ctx, fileevent.DiscoveredUnsupported, fshelper.FSName(w, name), "reason", "unsupported file type")
                                        return nil</span>
                                case filetypes.TypeVideo:<span class="cov8" title="1">
                                        to.log.Record(ctx, fileevent.DiscoveredVideo, fshelper.FSName(w, name))
                                        if strings.Contains(name, "Failed Videos") </span><span class="cov0" title="0">{
                                                to.log.Record(ctx, fileevent.DiscoveredDiscarded, fshelper.FSName(w, name), "reason", "can't upload failed videos")
                                                return nil
                                        }</span>
                                case filetypes.TypeImage:<span class="cov8" title="1">
                                        to.log.Record(ctx, fileevent.DiscoveredImage, fshelper.FSName(w, name))</span>
                                }

                                <span class="cov8" title="1">key := fileKeyTracker{
                                        baseName: base,
                                        size:     finfo.Size(),
                                }
                                tracking, _ := to.fileTracker.Load(key) // tracking := to.fileTracker[key]
                                tracking.paths = append(tracking.paths, dir)
                                tracking.count++
                                to.fileTracker.Store(key, tracking) // to.fileTracker[key] = tracking

                                if a, ok := dirCatalog.unMatchedFiles[base]; ok </span><span class="cov0" title="0">{
                                        to.logMessage(ctx, fileevent.AnalysisLocalDuplicate, a, "duplicated in the directory")
                                        return nil
                                }</span>

                                <span class="cov8" title="1">dirCatalog.unMatchedFiles[base] = &amp;assetFile{
                                        fsys:   w,
                                        base:   base,
                                        length: int(finfo.Size()),
                                        date:   finfo.ModTime(),
                                }</span>
                        }
                        <span class="cov8" title="1">to.catalogs[dir] = dirCatalog
                        return nil</span>
                }
        })
        <span class="cov8" title="1">return err</span>
}

// solvePuzzle prepares metadata with information collected during pass one for each accepted files
//
// JSON files give important information about the relative photos / movies:
//   - The original name (useful when it as been truncated)
//   - The date of capture (useful when the files doesn't have this date)
//   - The GPS coordinates (will be useful in a future release)
//
// Each JSON is checked. JSON is duplicated in albums folder.
// --Associated files with the JSON can be found in the JSON's folder, or in the Year photos.--
// ++JSON and files are located in the same folder
///
// Once associated and sent to the main program, files are tagged for not been associated with an other one JSON.
// Association is done with the help of a set of matcher functions. Each one implement a rule
//
// 1 JSON can be associated with 1+ files that have a part of their name in common.
// -   the file is named after the JSON name
// -   the file name can be 1 UTF-16 char shorter () than the JSON name
// -   the file name is longer than 46 UTF-16 chars () is truncated. But the truncation can creates duplicates, then a number is added.
// -   if there are several files with same original name, the first instance kept as it is, the next has a sequence number.
//       File is renamed as IMG_1234(1).JPG and the JSON is renamed as IMG_1234.JPG(1).JSON
// -   of course those rules are likely to collide. They have to be applied from the most common to the least one.
// -   sometimes the file isn't in the same folder than the json... It can be found in Year's photos folder
//
// --The duplicates files (same name, same length in bytes) found in the local source are discarded before been presented to the immich server.
// ++ Duplicates are presented to the next layer to allow the album handling
//
// To solve the puzzle, each directory is checked with all matchers in the order of the most common to the least.

type matcherFn func(jsonName string, fileName string, sm filetypes.SupportedMedia) bool

// matchers is a list of matcherFn from the most likely to be used to the least one
var matchers = []struct {
        name string
        fn   matcherFn
}{
        {name: "matchFastTrack", fn: matchFastTrack},
        {name: "matchNormal", fn: matchNormal},
        {name: "matchForgottenDuplicates", fn: matchForgottenDuplicates},
        {name: "matchEditedName", fn: matchEditedName},
}

func (to *Takeout) solvePuzzle(ctx context.Context) error <span class="cov8" title="1">{
        dirs := gen.MapKeysSorted(to.catalogs)
        for _, dir := range dirs </span><span class="cov8" title="1">{
                cat := to.catalogs[dir]
                jsons := gen.MapKeysSorted(cat.jsons)
                for _, matcher := range matchers </span><span class="cov8" title="1">{
                        for _, json := range jsons </span><span class="cov8" title="1">{
                                md := cat.jsons[json]
                                for f := range cat.unMatchedFiles </span><span class="cov8" title="1">{
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return ctx.Err()</span>
                                        default:<span class="cov8" title="1">
                                                if matcher.fn(json, f, to.flags.SupportedMedia) </span><span class="cov8" title="1">{
                                                        i := cat.unMatchedFiles[f]
                                                        i.md = md
                                                        a := to.makeAsset(ctx, dir, i, md)
                                                        cat.matchedFiles[f] = a
                                                        to.log.Record(ctx, fileevent.AnalysisAssociatedMetadata, fshelper.FSName(i.fsys, path.Join(dir, i.base)), "json", json, "matcher", matcher.name)
                                                        delete(cat.unMatchedFiles, f)
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">to.catalogs[dir] = cat
                if len(cat.unMatchedFiles) &gt; 0 </span><span class="cov8" title="1">{
                        files := gen.MapKeys(cat.unMatchedFiles)
                        sort.Strings(files)
                        for _, f := range files </span><span class="cov8" title="1">{
                                i := cat.unMatchedFiles[f]
                                to.log.Record(ctx, fileevent.AnalysisMissingAssociatedMetadata, fshelper.FSName(i.fsys, path.Join(dir, i.base)))
                                if to.flags.KeepJSONLess </span><span class="cov0" title="0">{
                                        a := to.makeAsset(ctx, dir, i, nil)
                                        cat.matchedFiles[f] = a
                                        delete(cat.unMatchedFiles, f)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Browse return a channel of assets
// Each asset is a group of files that are associated with each other

func (to *Takeout) passTwo(ctx context.Context, gOut chan *assets.Group) error <span class="cov8" title="1">{
        dirs := gen.MapKeys(to.catalogs)
        sort.Strings(dirs)
        for _, dir := range dirs </span><span class="cov8" title="1">{
                if len(to.catalogs[dir].matchedFiles) &gt; 0 </span><span class="cov8" title="1">{
                        err := to.handleDir(ctx, dir, gOut)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// type linkedFiles struct {
//         dir   string
//         base  string
//         video *assetFile
//         image *assetFile
// }

func (to *Takeout) handleDir(ctx context.Context, dir string, gOut chan *assets.Group) error <span class="cov8" title="1">{
        catalog := to.catalogs[dir]

        dirEntries := make([]*assets.Asset, 0, len(catalog.matchedFiles))

        for name := range catalog.matchedFiles </span><span class="cov8" title="1">{
                a := catalog.matchedFiles[name]
                key := fileKeyTracker{baseName: name, size: int64(a.FileSize)}
                track, _ := to.fileTracker.Load(key) // track := to.fileTracker[key]
                if track.status == fileevent.Uploaded </span><span class="cov8" title="1">{
                        a.Close()
                        to.logMessage(ctx, fileevent.AnalysisLocalDuplicate, a.File, "local duplicate")
                        continue</span>
                }

                // Filter on metadata
                <span class="cov8" title="1">if code := to.filterOnMetadata(ctx, a); code != fileevent.Code(0) </span><span class="cov0" title="0">{
                        a.Close()
                        continue</span>
                }
                <span class="cov8" title="1">dirEntries = append(dirEntries, a)</span>
        }

        <span class="cov8" title="1">in := make(chan *assets.Asset)
        go func() </span><span class="cov8" title="1">{
                defer close(in)

                sort.Slice(dirEntries, func(i, j int) bool </span><span class="cov8" title="1">{
                        // Sort by radical first
                        radicalI := dirEntries[i].Radical
                        radicalJ := dirEntries[j].Radical
                        if radicalI != radicalJ </span><span class="cov8" title="1">{
                                return radicalI &lt; radicalJ
                        }</span>
                        // If radicals are the same, sort by date
                        <span class="cov8" title="1">return dirEntries[i].CaptureDate.Before(dirEntries[j].CaptureDate)</span>
                })

                <span class="cov8" title="1">for _, a := range dirEntries </span><span class="cov8" title="1">{
                        if to.flags.CreateAlbums </span><span class="cov8" title="1">{
                                if to.flags.ImportIntoAlbum != "" </span><span class="cov0" title="0">{
                                        // Force this album
                                        a.Albums = []assets.Album{{Title: to.flags.ImportIntoAlbum}}
                                }</span> else<span class="cov8" title="1"> {
                                        // check if its duplicates are in some albums, and push them all at once
                                        key := fileKeyTracker{baseName: filepath.Base(a.File.Name()), size: int64(a.FileSize)}
                                        track, _ := to.fileTracker.Load(key) // track := to.fileTracker[key]
                                        for _, p := range track.paths </span><span class="cov8" title="1">{
                                                if album, ok := to.albums[p]; ok </span><span class="cov8" title="1">{
                                                        title := album.Title
                                                        if title == "" </span><span class="cov0" title="0">{
                                                                if !to.flags.KeepUntitled </span><span class="cov0" title="0">{
                                                                        continue</span>
                                                                }
                                                                <span class="cov0" title="0">title = filepath.Base(p)</span>
                                                        }
                                                        <span class="cov8" title="1">a.Albums = append(a.Albums, assets.Album{
                                                                Title:       title,
                                                                Description: album.Description,
                                                                Latitude:    album.Latitude,
                                                                Longitude:   album.Longitude,
                                                        })</span>
                                                }
                                        }
                                }

                                // Force this album for partners photos
                                <span class="cov8" title="1">if to.flags.PartnerSharedAlbum != "" &amp;&amp; a.FromPartner </span><span class="cov0" title="0">{
                                        a.Albums = append(a.Albums, assets.Album{Title: to.flags.PartnerSharedAlbum})
                                }</span>
                                <span class="cov8" title="1">if a.FromApplication != nil </span><span class="cov8" title="1">{
                                        a.FromApplication.Albums = a.Albums
                                }</span>
                        }
                        // If the asset has no GPS information, but the album has, use the album's location
                        <span class="cov8" title="1">if a.Latitude == 0 &amp;&amp; a.Longitude == 0 </span><span class="cov8" title="1">{
                                for _, album := range a.Albums </span><span class="cov8" title="1">{
                                        if album.Latitude != 0 || album.Longitude != 0 </span><span class="cov0" title="0">{
                                                // when there isn't GPS information on the photo, but the album has a location,  use that location
                                                a.Latitude = album.Latitude
                                                a.Longitude = album.Longitude
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if to.flags.SessionTag </span><span class="cov0" title="0">{
                                a.AddTag(to.flags.session)
                        }</span>
                        <span class="cov8" title="1">if to.flags.Tags != nil </span><span class="cov0" title="0">{
                                for _, tag := range to.flags.Tags </span><span class="cov0" title="0">{
                                        a.AddTag(tag)
                                }</span>
                        }
                        <span class="cov8" title="1">if to.flags.TakeoutTag </span><span class="cov0" title="0">{
                                a.AddTag(to.flags.TakeoutName)
                        }</span>

                        <span class="cov8" title="1">select </span>{
                        case in &lt;- a:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov8" title="1">gs := groups.NewGrouperPipeline(ctx, to.groupers...).PipeGrouper(ctx, in)
        for g := range gs </span><span class="cov8" title="1">{
                select </span>{
                case gOut &lt;- g:<span class="cov8" title="1">
                        for _, a := range g.Assets </span><span class="cov8" title="1">{
                                key := fileKeyTracker{
                                        baseName: path.Base(a.File.Name()),
                                        size:     int64(a.FileSize),
                                }
                                track, _ := to.fileTracker.Load(key) // track := to.fileTracker[key]
                                track.status = fileevent.Uploaded
                                to.fileTracker.Store(key, track) // to.fileTracker[key] = track
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// makeAsset makes a localAssetFile based on the google metadata
func (to *Takeout) makeAsset(_ context.Context, dir string, f *assetFile, md *assets.Metadata) *assets.Asset <span class="cov8" title="1">{
        file := path.Join(dir, f.base)
        a := &amp;assets.Asset{
                File:             fshelper.FSName(f.fsys, file), // File as named in the archive
                FileSize:         f.length,
                OriginalFileName: f.base,
                FileDate:         f.date,
        }

        // get the original file name from metadata
        if md != nil &amp;&amp; md.FileName != "" </span><span class="cov8" title="1">{
                a.OriginalFileName = md.FileName

                title := md.FileName
                // trim superfluous extensions
                titleExt := path.Ext(title)
                fileExt := path.Ext(file)

                if titleExt != fileExt </span><span class="cov8" title="1">{
                        title = strings.TrimSuffix(title, titleExt)
                        titleExt = path.Ext(title)
                        if titleExt != fileExt </span><span class="cov8" title="1">{
                                title = strings.TrimSuffix(title, titleExt) + fileExt
                        }</span>
                }
                <span class="cov8" title="1">a.FromApplication = a.UseMetadata(md)
                a.OriginalFileName = title</span>
        }
        <span class="cov8" title="1">a.SetNameInfo(to.flags.InfoCollector.GetInfo(a.OriginalFileName))
        return a</span>
}

func (to *Takeout) filterOnMetadata(ctx context.Context, a *assets.Asset) fileevent.Code <span class="cov8" title="1">{
        if !to.flags.KeepArchived &amp;&amp; a.Archived </span><span class="cov0" title="0">{
                to.logMessage(ctx, fileevent.DiscoveredDiscarded, a, "discarding archived file")
                a.Close()
                return fileevent.DiscoveredDiscarded
        }</span>
        <span class="cov8" title="1">if !to.flags.KeepPartner &amp;&amp; a.FromPartner </span><span class="cov0" title="0">{
                to.logMessage(ctx, fileevent.DiscoveredDiscarded, a, "discarding partner file")
                a.Close()
                return fileevent.DiscoveredDiscarded
        }</span>
        <span class="cov8" title="1">if !to.flags.KeepTrashed &amp;&amp; a.Trashed </span><span class="cov0" title="0">{
                to.logMessage(ctx, fileevent.DiscoveredDiscarded, a, "discarding trashed file")
                a.Close()
                return fileevent.DiscoveredDiscarded
        }</span>

        <span class="cov8" title="1">if to.flags.InclusionFlags.DateRange.IsSet() &amp;&amp; !to.flags.InclusionFlags.DateRange.InRange(a.CaptureDate) </span><span class="cov0" title="0">{
                to.logMessage(ctx, fileevent.DiscoveredDiscarded, a, "discarding files out of date range")
                a.Close()
                return fileevent.DiscoveredDiscarded
        }</span>
        <span class="cov8" title="1">if to.flags.ImportFromAlbum != "" </span><span class="cov0" title="0">{
                keep := false
                dir := path.Dir(a.File.Name())
                if dir == "." </span><span class="cov0" title="0">{
                        dir = ""
                }</span>
                <span class="cov0" title="0">if album, ok := to.albums[dir]; ok </span><span class="cov0" title="0">{
                        keep = keep || album.Title == to.flags.ImportFromAlbum
                }</span>
                <span class="cov0" title="0">if !keep </span><span class="cov0" title="0">{
                        to.logMessage(ctx, fileevent.DiscoveredDiscarded, a, "discarding files not in the specified album")
                        a.Close()
                        return fileevent.DiscoveredDiscarded
                }</span>
        }
        <span class="cov8" title="1">return fileevent.Code(0)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package gp

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "strconv"
        "time"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/fshelper"
)

type GoogleMetaData struct {
        Title              string             `json:"title"`
        Description        string             `json:"description"`
        Category           string             `json:"category"`
        Date               *googTimeObject    `json:"date,omitempty"`
        PhotoTakenTime     *googTimeObject    `json:"photoTakenTime"`
        GeoDataExif        *googGeoData       `json:"geoDataExif"`
        GeoData            *googGeoData       `json:"geoData"`
        Trashed            bool               `json:"trashed,omitempty"`
        Archived           bool               `json:"archived,omitempty"`
        URLPresent         googIsPresent      `json:"url,omitempty"`         // true when the file is an asset metadata
        Favorited          bool               `json:"favorited,omitempty"`   // true when starred in GP
        Enrichments        *googleEnrichments `json:"enrichments,omitempty"` // Album enrichments
        People             []Person           `json:"people,omitempty"`      // People tags
        GooglePhotosOrigin struct {
                FromPartnerSharing googIsPresent `json:"fromPartnerSharing,omitempty"` // true when this is a partner's asset
        } `json:"googlePhotosOrigin"`
}

type Person struct {
        Name string `json:"name"`
}

func (gmd *GoogleMetaData) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // test the presence of the key albumData
        type md GoogleMetaData
        type album struct {
                AlbumData *md `json:"albumData"`
        }

        var t album
        err := json.Unmarshal(data, &amp;t)
        if err == nil &amp;&amp; t.AlbumData != nil </span><span class="cov8" title="1">{
                *gmd = GoogleMetaData(*(t.AlbumData))
                return nil
        }</span>

        <span class="cov8" title="1">var gg md
        err = json.Unmarshal(data, &amp;gg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*gmd = GoogleMetaData(gg)
        return nil</span>
}

func (gmd GoogleMetaData) LogValue() slog.Value <span class="cov8" title="1">{
        return slog.GroupValue(
                slog.String("Title", gmd.Title),
                slog.String("Description", gmd.Description),
                slog.String("Category", gmd.Category),
                slog.Any("Date", gmd.Date),
                slog.Any("PhotoTakenTime", gmd.PhotoTakenTime),
                slog.Any("GeoDataExif", gmd.GeoDataExif),
                slog.Any("GeoData", gmd.GeoData),
                slog.Bool("Trashed", gmd.Trashed),
                slog.Bool("Archived", gmd.Archived),
                slog.Bool("URLPresent", bool(gmd.URLPresent)),
                slog.Bool("Favorited", gmd.Favorited),
                slog.Any("Enrichments", gmd.Enrichments),
                slog.Any("People", gmd.People),
                slog.Bool("FromPartnerSharing", bool(gmd.GooglePhotosOrigin.FromPartnerSharing)),
        )
}</span>

func (gmd GoogleMetaData) AsMetadata(name fshelper.FSAndName, tagPeople bool) *assets.Metadata <span class="cov8" title="1">{
        md := assets.Metadata{
                File:        name,
                FileName:    gmd.Title,
                Description: gmd.Description,
                Trashed:     gmd.Trashed,
                Archived:    gmd.Archived,
                Favorited:   gmd.Favorited,
                FromPartner: gmd.isPartner(),
        }
        if gmd.GeoDataExif != nil </span><span class="cov0" title="0">{
                md.Latitude, md.Longitude = gmd.GeoDataExif.Latitude, gmd.GeoDataExif.Longitude
                if md.Latitude == 0 &amp;&amp; md.Longitude == 0 &amp;&amp; gmd.GeoData != nil </span><span class="cov0" title="0">{
                        md.Latitude, md.Longitude = gmd.GeoData.Latitude, gmd.GeoData.Longitude
                }</span>
        }
        <span class="cov8" title="1">if gmd.PhotoTakenTime != nil &amp;&amp; gmd.PhotoTakenTime.Timestamp != "" &amp;&amp; gmd.PhotoTakenTime.Timestamp != "0" </span><span class="cov8" title="1">{
                md.DateTaken = gmd.PhotoTakenTime.Time()
        }</span>
        <span class="cov8" title="1">if tagPeople </span><span class="cov0" title="0">{
                for _, p := range gmd.People </span><span class="cov0" title="0">{
                        md.AddTag("People/" + p.Name)
                }</span>
        }
        <span class="cov8" title="1">return &amp;md</span>
}

func (gmd *GoogleMetaData) isAlbum() bool <span class="cov8" title="1">{
        if gmd == nil || gmd.isAsset() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return gmd.Title != ""</span>
}

func (gmd *GoogleMetaData) isAsset() bool <span class="cov8" title="1">{
        if gmd == nil || gmd.PhotoTakenTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return gmd.PhotoTakenTime.Timestamp != ""</span>
}

func (gmd *GoogleMetaData) isPartner() bool <span class="cov8" title="1">{
        if gmd == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return bool(gmd.GooglePhotosOrigin.FromPartnerSharing)</span>
}

// Key return an expected unique key for the asset
// based on the title and the timestamp
func (gmd GoogleMetaData) Key() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s,%s", gmd.Title, gmd.PhotoTakenTime.Timestamp)
}</span>

// googIsPresent is set when the field is present. The content of the field is not relevant
type googIsPresent bool

func (p *googIsPresent) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        var bl bool
        err := json.Unmarshal(b, &amp;bl)
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">*p = len(b) &gt; 0
        return nil</span>
}

func (p googIsPresent) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        if p </span><span class="cov8" title="1">{
                return json.Marshal("present")
        }</span>
        <span class="cov0" title="0">return json.Marshal(struct{}{})</span>
}

// googGeoData contains GPS coordinates
type googGeoData struct {
        Latitude  float64 `json:"latitude"`
        Longitude float64 `json:"longitude"`
        Altitude  float64 `json:"altitude"`
}

func (ggd *googGeoData) LogValue() slog.Value <span class="cov8" title="1">{
        if ggd == nil </span><span class="cov8" title="1">{
                return slog.Value{}
        }</span>
        <span class="cov8" title="1">return slog.GroupValue(
                slog.Float64("Latitude", ggd.Latitude),
                slog.Float64("Longitude", ggd.Longitude),
                slog.Float64("Altitude", ggd.Altitude),
        )</span>
}

// googTimeObject to handle the epoch timestamp
type googTimeObject struct {
        Timestamp string `json:"timestamp"`
        // Formatted string    `json:"formatted"`
}

func (gt *googTimeObject) LogValue() slog.Value <span class="cov8" title="1">{
        if gt == nil </span><span class="cov8" title="1">{
                return slog.Value{}
        }</span>
        <span class="cov8" title="1">return slog.TimeValue(gt.Time())</span>
}

// Time return the time.Time of the epoch
func (gt googTimeObject) Time() time.Time <span class="cov8" title="1">{
        ts, _ := strconv.ParseInt(gt.Timestamp, 10, 64)
        if ts == 0 </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov8" title="1">t := time.Unix(ts, 0)
        return t.In(time.Local)</span>
}

type googleEnrichments struct {
        Text      string
        Latitude  float64
        Longitude float64
}

func (ge *googleEnrichments) LogValue() slog.Value <span class="cov8" title="1">{
        if ge == nil </span><span class="cov8" title="1">{
                return slog.Value{}
        }</span>
        <span class="cov8" title="1">return slog.GroupValue(
                slog.String("Text", ge.Text),
                slog.Float64("Latitude", ge.Latitude),
                slog.Float64("Longitude", ge.Longitude),
        )</span>
}

func (ge *googleEnrichments) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        type googleEnrichment struct {
                NarrativeEnrichment struct {
                        Text string `json:"text"`
                } `json:"narrativeEnrichment,omitempty"`
                LocationEnrichment struct {
                        Location []struct {
                                Name        string `json:"name"`
                                Description string `json:"description"`
                                LatitudeE7  int    `json:"latitudeE7"`
                                LongitudeE7 int    `json:"longitudeE7"`
                        } `json:"location"`
                } `json:"locationEnrichment,omitempty"`
        }

        var enrichments []googleEnrichment

        err := json.Unmarshal(b, &amp;enrichments)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, e := range enrichments </span><span class="cov8" title="1">{
                if e.NarrativeEnrichment.Text != "" </span><span class="cov8" title="1">{
                        ge.Text = addString(ge.Text, "\n", e.NarrativeEnrichment.Text)
                }</span>
                <span class="cov8" title="1">if e.LocationEnrichment.Location != nil </span><span class="cov8" title="1">{
                        for _, l := range e.LocationEnrichment.Location </span><span class="cov8" title="1">{
                                if l.Name != "" </span><span class="cov8" title="1">{
                                        ge.Text = addString(ge.Text, "\n", l.Name)
                                }</span>
                                <span class="cov8" title="1">if l.Description != "" </span><span class="cov8" title="1">{
                                        ge.Text = addString(ge.Text, " - ", l.Description)
                                }</span>
                                <span class="cov8" title="1">ge.Latitude = float64(l.LatitudeE7) / 10e6
                                ge.Longitude = float64(l.LongitudeE7) / 10e6</span>
                        }
                }
        }
        <span class="cov8" title="1">return err</span>
}

func addString(s string, sep string, t string) string <span class="cov8" title="1">{
        if s != "" </span><span class="cov8" title="1">{
                return s + sep + t
        }</span>
        <span class="cov8" title="1">return t</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package gp

import (
        "context"
        "encoding/csv"
        "io"
        "log/slog"
        "slices"
        "strconv"
        "strings"

        "github.com/simulot/immich-go/internal/fileevent"
)

// logMessage for the photo and the movie attached to the photo
func (to *Takeout) logMessage(ctx context.Context, code fileevent.Code, a slog.LogValuer, reason string) <span class="cov8" title="1">{
        t := "reason"
        if code == fileevent.Error </span><span class="cov0" title="0">{
                t = "error"
        }</span>
        <span class="cov8" title="1">to.log.Record(ctx, code, a, t, reason)</span>
}

func (to *Takeout) DebugFileTracker(w io.Writer) <span class="cov0" title="0">{
        csv := csv.NewWriter(w)
        _ = csv.Write([]string{"File", "Size", "Count", "Duplicated", "Uploaded", "Status", "Date", "Albums", "Paths"})

        keys := to.fileTracker.Keys()

        slices.SortFunc(keys, trackerKeySortFunc)
        line := make([]string, 9)
        for _, k := range keys </span><span class="cov0" title="0">{
                track, _ := to.fileTracker.Load(k)
                line[0] = k.baseName
                line[1] = strconv.Itoa(int(k.size))     // Size
                line[2] = strconv.Itoa(track.count)     // Count
                line[3] = strconv.Itoa(track.count - 1) // Duplicated
                if track.status == fileevent.Uploaded </span><span class="cov0" title="0">{
                        line[4] = "1" // Uploaded
                }</span> else<span class="cov0" title="0"> {
                        line[4] = "0"
                }</span>
                <span class="cov0" title="0">line[5] = track.status.String()
                if track.metadata != nil </span><span class="cov0" title="0">{
                        albums := make([]string, 0, len(track.metadata.Albums))
                        for _, a := range track.metadata.Albums </span><span class="cov0" title="0">{
                                albums = append(albums, a.Title)
                        }</span>
                        <span class="cov0" title="0">line[6] = track.metadata.DateTaken.Format("2006-01-02 15:04:05 -0700") // Date
                        line[7] = strings.Join(albums, ",")</span>                                    // Albums
                } else<span class="cov0" title="0"> {
                        line[6] = ""
                        line[7] = ""
                }</span>
                <span class="cov0" title="0">line[8] = strings.Join(track.paths, ",") // Paths
                _ = csv.Write(line)</span>
        }
        <span class="cov0" title="0">csv.Flush()</span>
}

/*
func (to *Takeout) DebugUploadedFiles(w io.Writer) {
        csv := csv.NewWriter(w)
        _ = csv.Write([]string{"File", "Size"})

        slices.SortFunc(to.debugUploadedFile, trackerKeySortFunc)
        line := make([]string, 2)
        for _, k := range to.debugUploadedFile {
                line[0] = k.baseName
                line[1] = strconv.Itoa(int(k.size))
                _ = csv.Write(line)
        }
        csv.Flush()
}
*/
</pre>
		
		<pre class="file" id="file9" style="display: none">package gp

import (
        "path"
        "strconv"
        "strings"
        "unicode/utf8"

        "github.com/simulot/immich-go/internal/filetypes"
)

func matchFastTrack(jsonName string, fileName string, _ filetypes.SupportedMedia) bool <span class="cov8" title="1">{
        //  fast track: if the file name is the same as the JSON name
        jsonName = strings.TrimSuffix(jsonName, path.Ext(jsonName))
        return jsonName == fileName
}</span>

func matchNormal(jsonName string, fileName string, _ filetypes.SupportedMedia) bool <span class="cov8" title="1">{
        // Extract the index from the file name
        fileName, fileIndex := getFileIndex(fileName)
        // Extract the index from the JSON name
        jsonName, jsonIndex := getFileIndex(jsonName)

        // Check if the indexes are the same
        if fileIndex != jsonIndex </span><span class="cov8" title="1">{
                return false
        }</span>

        // supplemental-metadata  check
        <span class="cov8" title="1">p2 := strings.LastIndex(jsonName, ".")
        if p2 &gt; 1 </span><span class="cov8" title="1">{
                p1 := strings.LastIndex(jsonName[:p2], ".")
                if p1 &gt; 1 </span><span class="cov8" title="1">{
                        if strings.HasPrefix("supplemental-metadata", jsonName[p1+1:p2]) </span><span class="cov8" title="1">{ //nolint:all
                                jsonName = jsonName[:p1] + jsonName[p2:]
                        }</span>
                }
        }

        // Check if the file name is the same as the JSON name
        <span class="cov8" title="1">jsonName = strings.TrimSuffix(jsonName, path.Ext(jsonName))
        if jsonName == fileName </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(fileName) &gt; 46 </span><span class="cov8" title="1">{
                if utf8.RuneCountInString(fileName) &gt; 46 </span><span class="cov8" title="1">{
                        fileName = string([]rune(fileName)[:46])
                        if fileName == jsonName </span><span class="cov8" title="1">{
                                return true
                        }</span>
                } else<span class="cov8" title="1"> {
                        fileName = strings.TrimSuffix(fileName, path.Ext(fileName))
                        _, size := utf8.DecodeLastRuneInString(fileName)
                        fileName = fileName[:len(fileName)-size]
                        if fileName == jsonName </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// matchEditedName
//   PXL_20220405_090123740.PORTRAIT.jpg.json
//   PXL_20220405_090123740.PORTRAIT.jpg
//   PXL_20220405_090123740.PORTRAIT-modifi.jpg
// but not DSC_0104.JPG.json with DSC_0104(1).JPG

func matchEditedName(jsonName string, fileName string, sm filetypes.SupportedMedia) bool <span class="cov8" title="1">{
        if _, index := getFileIndex(fileName); index != "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">base := strings.TrimSuffix(jsonName, path.Ext(jsonName))
        p1 := strings.LastIndex(base, ".")
        if p1 &gt; 1 </span><span class="cov8" title="1">{
                if strings.HasPrefix("supplemental-metadata", base[p1+1:]) </span><span class="cov8" title="1">{ //nolint:all
                        base = jsonName[:p1]
                }</span>
        }

        <span class="cov8" title="1">ext := path.Ext(base)
        if ext != "" &amp;&amp; sm.IsMedia(ext) </span><span class="cov8" title="1">{
                base = strings.TrimSuffix(base, ext)
                fileName = strings.TrimSuffix(fileName, path.Ext(fileName))
        }</span>
        <span class="cov8" title="1">return strings.HasPrefix(fileName, base)</span>
}

// matchForgottenDuplicates
// "original_1d4caa6f-16c6-4c3d-901b-9387de10e528_.json"
// original_1d4caa6f-16c6-4c3d-901b-9387de10e528_P.jpg
// original_1d4caa6f-16c6-4c3d-901b-9387de10e528_P(1).jpg

func matchForgottenDuplicates(jsonName string, fileName string, sm filetypes.SupportedMedia) bool <span class="cov8" title="1">{
        jsonName = strings.TrimSuffix(jsonName, path.Ext(jsonName))
        fileName = strings.TrimSuffix(fileName, path.Ext(fileName))
        if strings.HasPrefix(fileName, jsonName) </span><span class="cov8" title="1">{
                a, b := utf8.RuneCountInString(jsonName), utf8.RuneCountInString(fileName)
                if b-a &lt; 10 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func getFileIndex(name string) (string, string) <span class="cov8" title="1">{
        // Extract the index from the file name
        p1File := strings.LastIndex(name, "(")
        if p1File &gt;= 0 </span><span class="cov8" title="1">{
                p2File := strings.LastIndex(name, ")")
                if p2File &gt;= 0 &amp;&amp; p2File &gt; p1File </span><span class="cov8" title="1">{
                        fileIndex := name[p1File+1 : p2File]
                        if _, err := strconv.Atoi(fileIndex); err == nil </span><span class="cov8" title="1">{
                                return name[:p1File] + name[p2File+1:], fileIndex
                        }</span>
                }
        }
        <span class="cov8" title="1">return name, ""</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package gp provides functionality for importing Google Photos takeout into Immich.

package gp

import (
        "time"

        cliflags "github.com/simulot/immich-go/internal/cliFlags"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/filetypes"
        "github.com/simulot/immich-go/internal/filters"
        "github.com/simulot/immich-go/internal/namematcher"
        "github.com/spf13/cobra"
)

// ImportFlags represents the command-line flags for the Google Photos takeout import command.
type ImportFlags struct {
        // CreateAlbums determines whether to create albums in Immich that match the albums in the Google Photos takeout.
        CreateAlbums bool

        // ImportFromAlbum specifies the name of the Google Photos album to import from. If empty, all albums will be imported.
        ImportFromAlbum string

        // ImportIntoAlbum specifies the name of the album to import assets into.
        ImportIntoAlbum string

        // PartnerSharedAlbum specifies the name of the album to add partner's photos to.
        PartnerSharedAlbum string

        // KeepTrashed determines whether to import photos that are marked as trashed in Google Photos.
        KeepTrashed bool

        // KeepPartner determines whether to import photos from the partner's Google Photos account.
        KeepPartner bool

        // KeepUntitled determines whether to include photos from albums without a title in the import process.
        KeepUntitled bool

        // KeepArchived determines whether to import archived Google Photos.
        KeepArchived bool

        // KeepJSONLess determines whether to import photos that do not have a matching JSON file in the takeout.
        KeepJSONLess bool

        // Flags  for controlling the extensions of the files to be uploaded
        InclusionFlags cliflags.InclusionFlags

        // List of banned files
        BannedFiles namematcher.List // List of banned file name patterns

        // SupportedMedia represents the server's actual list of supported media. This is not a flag.
        SupportedMedia filetypes.SupportedMedia

        // InfoCollector collects information about filenames.
        InfoCollector *filenames.InfoCollector

        // ManageHEICJPG determines whether to manage HEIC to JPG conversion options.
        ManageHEICJPG filters.HeicJpgFlag

        // ManageRawJPG determines how to manage raw and JPEG files.
        ManageRawJPG filters.RawJPGFlag

        // BurstFlag determines how to manage burst photos.
        ManageBurst filters.BurstFlag

        // ManageEpsonFastFoto enables the management of Epson FastFoto files.
        ManageEpsonFastFoto bool

        // Tags is a list of tags to be added to the imported assets.
        Tags []string

        // SessionTag indicates whether to add a session tag to the imported assets.
        SessionTag bool
        session    string // Session tag value

        // Add the takeout file name as tag
        TakeoutTag  bool
        TakeoutName string

        // PeopleTag indicates whether to add a people tag to the imported assets.
        PeopleTag bool
        // Timezone
        TZ *time.Location
}

func (o *ImportFlags) AddFromGooglePhotosFlags(cmd *cobra.Command, parent *cobra.Command) <span class="cov0" title="0">{
        o.BannedFiles, _ = namematcher.New(
                `@eaDir/`,
                `@__thumb/`,          // QNAP
                `SYNOFILE_THUMB_*.*`, // SYNOLOGY
                `Lightroom Catalog/`, // LR
                `thumbnails/`,        // Android photo
                `.DS_Store/`,         // Mac OS custom attributes
                `/._*`,               // MacOS resource files
                `.photostructure/`,   // PhotoStructure
        )
        cmd.Flags().BoolVar(&amp;o.CreateAlbums, "sync-albums", true, "Automatically create albums in Immich that match the albums in your Google Photos takeout")
        cmd.Flags().StringVar(&amp;o.ImportFromAlbum, "from-album-name", "", "Only import photos from the specified Google Photos album")
        cmd.Flags().BoolVar(&amp;o.KeepUntitled, "include-untitled-albums", false, "Include photos from albums without a title in the import process")
        cmd.Flags().BoolVarP(&amp;o.KeepTrashed, "include-trashed", "t", false, "Import photos that are marked as trashed in Google Photos")
        cmd.Flags().BoolVarP(&amp;o.KeepPartner, "include-partner", "p", true, "Import photos from your partner's Google Photos account")
        cmd.Flags().StringVar(&amp;o.PartnerSharedAlbum, "partner-shared-album", "", "Add partner's photo to the specified album name")
        cmd.Flags().BoolVarP(&amp;o.KeepArchived, "include-archived", "a", true, "Import archived Google Photos")
        cmd.Flags().BoolVarP(&amp;o.KeepJSONLess, "include-unmatched", "u", false, "Import photos that do not have a matching JSON file in the takeout")
        cmd.Flags().Var(&amp;o.BannedFiles, "ban-file", "Exclude a file based on a pattern (case-insensitive). Can be specified multiple times.")
        cmd.Flags().StringSliceVar(&amp;o.Tags, "tag", nil, "Add tags to the imported assets. Can be specified multiple times. Hierarchy is supported using a / separator (e.g. 'tag1/subtag1')")
        cmd.Flags().BoolVar(&amp;o.SessionTag, "session-tag", false, "Tag uploaded photos with a tag \"{immich-go}/YYYY-MM-DD HH-MM-SS\"")
        cmd.Flags().BoolVar(&amp;o.TakeoutTag, "takeout-tag", true, "Tag uploaded photos with a tag \"{takeout}/takeout-YYYYMMDDTHHMMSSZ\"")
        cmd.Flags().BoolVar(&amp;o.PeopleTag, "people-tag", true, "Tag uploaded photos with tags \"people/name\" found in the JSON file")

        // exif.AddExifToolFlags(cmd, &amp;o.ExifToolFlags)
        o.SupportedMedia = filetypes.DefaultSupportedMedia

        if parent != nil &amp;&amp; parent.Name() == "upload" </span><span class="cov0" title="0">{
                cmd.Flags().Var(&amp;o.ManageHEICJPG, "manage-heic-jpeg", "Manage coupled HEIC and JPEG files. Possible values: KeepHeic, KeepJPG, StackCoverHeic, StackCoverJPG")
                cmd.Flags().Var(&amp;o.ManageRawJPG, "manage-raw-jpeg", "Manage coupled RAW and JPEG files. Possible values: KeepRaw, KeepJPG, StackCoverRaw, StackCoverJPG")
                cmd.Flags().Var(&amp;o.ManageBurst, "manage-burst", "Manage burst photos. Possible values: Stack, StackKeepRaw, StackKeepJPEG")
                cmd.Flags().BoolVar(&amp;o.ManageEpsonFastFoto, "manage-epson-fastfoto", false, "Manage Epson FastFoto file (default: false)")
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package app

import (
        "context"
        "time"

        "github.com/simulot/immich-go/internal/fileevent"
        "github.com/spf13/cobra"
)

type (
        RunE        func(cmd *cobra.Command, args []string) error
        RunEAdaptor func(ctx context.Context, cmd *cobra.Command, app *Application) error
)

// Application holds configuration used by commands
type Application struct {
        client Client
        log    *Log
        jnl    *fileevent.Recorder
        tz     *time.Location

        // TODO manage configuration file
        // ConfigurationFile string // Path to the configuration file to use
}

func New(ctx context.Context, cmd *cobra.Command) *Application <span class="cov0" title="0">{
        // application's context
        app := &amp;Application{
                log: &amp;Log{},
                tz:  time.Local,
        }
        // app.PersistentFlags().StringVar(&amp;app.ConfigurationFile, "use-configuration", app.ConfigurationFile, "Specifies the configuration to use")
        AddLogFlags(ctx, cmd, app)
        return app
}</span>

func (app *Application) GetTZ() *time.Location <span class="cov0" title="0">{
        if app.tz == nil </span><span class="cov0" title="0">{
                app.tz = time.Local
        }</span>
        <span class="cov0" title="0">return app.tz</span>
}

func (app *Application) SetTZ(tz *time.Location) <span class="cov0" title="0">{
        app.tz = tz
}</span>

func (app *Application) Client() *Client <span class="cov0" title="0">{
        return &amp;app.client
}</span>

func (app *Application) Jnl() *fileevent.Recorder <span class="cov0" title="0">{
        return app.jnl
}</span>

func (app *Application) SetJnl(jnl *fileevent.Recorder) <span class="cov0" title="0">{
        app.jnl = jnl
}</span>

func (app *Application) Log() *Log <span class="cov0" title="0">{
        return app.log
}</span>

func (app *Application) SetLog(log *Log) <span class="cov0" title="0">{
        app.log = log
}</span>

func ChainRunEFunctions(prev RunE, fn RunEAdaptor, ctx context.Context, cmd *cobra.Command, app *Application) RunE <span class="cov0" title="0">{
        if prev == nil </span><span class="cov0" title="0">{
                return func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return fn(ctx, cmd, app)
                }</span>
        }
        <span class="cov0" title="0">return func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                if prev != nil </span><span class="cov0" title="0">{
                        err := prev(cmd, args)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return fn(ctx, cmd, app)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/simulot/immich-go/immich"
        "github.com/simulot/immich-go/internal/configuration"
        "github.com/spf13/cobra"
)

// add server flags to the command cmd
func AddClientFlags(ctx context.Context, cmd *cobra.Command, app *Application, dryRun bool) <span class="cov0" title="0">{
        client := app.Client()
        client.DeviceUUID, _ = os.Hostname()

        cmd.PersistentFlags().StringVarP(&amp;client.Server, "server", "s", client.Server, "Immich server address (example http://your-ip:2283 or https://your-domain)")
        cmd.PersistentFlags().StringVarP(&amp;client.APIKey, "api-key", "k", "", "API Key")
        cmd.PersistentFlags().BoolVar(&amp;client.APITrace, "api-trace", false, "Enable trace of api calls")
        cmd.PersistentFlags().BoolVar(&amp;client.SkipSSL, "skip-verify-ssl", false, "Skip SSL verification")
        cmd.PersistentFlags().DurationVar(&amp;client.ClientTimeout, "client-timeout", 5*time.Minute, "Set server calls timeout")
        cmd.PersistentFlags().StringVar(&amp;client.DeviceUUID, "device-uuid", client.DeviceUUID, "Set a device UUID")
        cmd.PersistentFlags().BoolVar(&amp;client.DryRun, "dry-run", dryRun, "Simulate all actions")
        cmd.PersistentFlags().StringVar(&amp;client.TimeZone, "time-zone", client.TimeZone, "Override the system time zone")

        cmd.PersistentPreRunE = ChainRunEFunctions(cmd.PersistentPreRunE, OpenClient, ctx, cmd, app)
        cmd.PersistentPostRunE = ChainRunEFunctions(cmd.PersistentPostRunE, CloseClient, ctx, cmd, app)
}</span>

func OpenClient(ctx context.Context, cmd *cobra.Command, app *Application) error <span class="cov0" title="0">{
        var err error
        client := app.Client()
        log := app.Log()

        if client.Server != "" </span><span class="cov0" title="0">{
                client.Server = strings.TrimSuffix(client.Server, "/")
        }</span>
        <span class="cov0" title="0">if client.TimeZone != "" </span><span class="cov0" title="0">{
                // Load the specified timezone
                client.TZ, err = time.LoadLocation(client.TimeZone)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Plug the journal on the Log
        <span class="cov0" title="0">if log.File != "" </span><span class="cov0" title="0">{
                if log.mainWriter == nil </span><span class="cov0" title="0">{
                        err := configuration.MakeDirForFile(log.File)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">f, err := os.OpenFile(log.File, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o664)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">err = log.sLevel.UnmarshalText([]byte(strings.ToUpper(log.Level)))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">log.setHandlers(f, nil)
                        // prepare the trace file name
                        client.APITraceWriterName = strings.TrimSuffix(log.File, filepath.Ext(log.File)) + ".trace.log"</span>
                }
        }

        <span class="cov0" title="0">err = client.Initialize(ctx, app)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = client.Open(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if client.APITrace </span><span class="cov0" title="0">{
                if client.APITraceWriter == nil </span><span class="cov0" title="0">{
                        client.APITraceWriter, err = os.OpenFile(client.APITraceWriterName, os.O_CREATE|os.O_WRONLY, 0o664)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">client.Immich.EnableAppTrace(client.APITraceWriter)</span>
                }
                <span class="cov0" title="0">app.log.Message("Check the API-TRACE file: %s", client.APITraceWriterName)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func CloseClient(ctx context.Context, cmd *cobra.Command, app *Application) error <span class="cov0" title="0">{
        if app.Client() != nil </span><span class="cov0" title="0">{
                if app.Client().APITraceWriter != nil </span><span class="cov0" title="0">{
                        app.Client().APITraceWriter.Close()
                        app.log.Message("Check the API-TRACE file: %s", app.Client().APITraceWriterName)
                }</span>
                <span class="cov0" title="0">return app.Client().Close()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type Client struct {
        Server string // Immich server address (http://&lt;your-ip&gt;:2283/api or https://&lt;your-domain&gt;/api)
        // API                string                 // Immich api endpoint (http://container_ip:3301)
        APIKey             string                 // API Key
        APITrace           bool                   // Enable API call traces
        SkipSSL            bool                   // Skip SSL Verification
        ClientTimeout      time.Duration          // Set the client request timeout
        DeviceUUID         string                 // Set a device UUID
        DryRun             bool                   // Protect the server from changes
        TimeZone           string                 // Override default TZ
        TZ                 *time.Location         // Time zone to use
        APITraceWriter     io.WriteCloser         // API tracer
        APITraceWriterName string                 // API trace log name
        Immich             immich.ImmichInterface // Immich client
        ClientLog          *slog.Logger           // Logger
}

func (client *Client) Initialize(ctx context.Context, app *Application) error <span class="cov0" title="0">{
        var joinedErr error

        // If the client isn't yet initialized
        if client.Immich == nil </span><span class="cov0" title="0">{
                if client.Server == "" </span><span class="cov0" title="0">{
                        joinedErr = errors.Join(joinedErr, errors.New("missing the parameter --server, Immich server address (http://&lt;your-ip&gt;:2283 or https://&lt;your-domain&gt;)"))
                }</span>
                <span class="cov0" title="0">if client.APIKey == "" </span><span class="cov0" title="0">{
                        joinedErr = errors.Join(joinedErr, errors.New("missing the parameter --api-key, Immich API key"))
                }</span>

                <span class="cov0" title="0">if client.APITrace </span><span class="cov0" title="0">{
                        client.APITraceWriterName = strings.TrimSuffix(app.Log().File, filepath.Ext(app.Log().File)) + ".trace.log"
                }</span>
                <span class="cov0" title="0">if joinedErr != nil </span><span class="cov0" title="0">{
                        return joinedErr
                }</span>
        }
        <span class="cov0" title="0">client.ClientLog = app.log.Logger
        return nil</span>
}

func (client *Client) Open(ctx context.Context) error <span class="cov0" title="0">{
        var err error

        client.ClientLog.Info("Connection to the server " + client.Server)
        client.Immich, err = immich.NewImmichClient(
                client.Server,
                client.APIKey,
                immich.OptionVerifySSL(client.SkipSSL),
                immich.OptionConnectionTimeout(client.ClientTimeout),
                immich.OptionDryRun(client.DryRun),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if client.DeviceUUID != "" </span><span class="cov0" title="0">{
                client.Immich.SetDeviceUUID(client.DeviceUUID)
        }</span>

        <span class="cov0" title="0">if client.APITrace </span><span class="cov0" title="0">{
                if client.APITraceWriter == nil </span><span class="cov0" title="0">{
                        client.APITraceWriter, err = os.OpenFile(client.APITraceWriterName, os.O_CREATE|os.O_WRONLY, 0o664)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">client.Immich.EnableAppTrace(client.APITraceWriter)</span>
                }
        }

        <span class="cov0" title="0">err = client.Immich.PingServer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">client.ClientLog.Info("Server status: OK")

        user, err := client.Immich.ValidateConnection(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">client.ClientLog.Info(fmt.Sprintf("Connected, user: %s", user.Email))
        if client.DryRun </span><span class="cov0" title="0">{
                client.ClientLog.Info("Dry-run mode enabled. No changes will be made to the server.")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (client *Client) Close() error <span class="cov0" title="0">{
        if client.DryRun </span><span class="cov0" title="0">{
                client.ClientLog.Info("Dry-run mode enabled. No changes were made to the server.")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package archive

import (
        "context"
        "errors"
        "os"
        "strings"

        "github.com/simulot/immich-go/adapters/folder"
        "github.com/simulot/immich-go/adapters/fromimmich"
        gp "github.com/simulot/immich-go/adapters/googlePhotos"
        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/internal/fileevent"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/simulot/immich-go/internal/fshelper/osfs"
        "github.com/spf13/cobra"
)

type ArchiveOptions struct {
        ArchivePath string
}

func NewArchiveCommand(ctx context.Context, app *app.Application) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "archive",
                Short: "Archive various sources of photos to a file system",
        }
        options := &amp;ArchiveOptions{}

        cmd.PersistentFlags().StringVarP(&amp;options.ArchivePath, "write-to-folder", "w", "", "Path where to write the archive")
        _ = cmd.MarkPersistentFlagRequired("write-to-folder")

        cmd.AddCommand(NewImportFromFolderCommand(ctx, cmd, app, options))
        cmd.AddCommand(NewFromGooglePhotosCommand(ctx, cmd, app, options))
        cmd.AddCommand(NewFromImmichCommand(ctx, cmd, app, options))

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{ //nolint:contextcheck
                return errors.New("you must specify a subcommand to the archive command")
        }</span>
        <span class="cov0" title="0">return cmd</span>
}

func NewImportFromFolderCommand(ctx context.Context, parent *cobra.Command, app *app.Application, archOptions *ArchiveOptions) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "from-folder",
                Short: "Archive photos from a folder",
        }

        options := &amp;folder.ImportFolderOptions{}
        options.AddFromFolderFlags(cmd, parent)

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{ //nolint:contextcheck
                // ready to run
                ctx := cmd.Context()
                log := app.Log()
                if app.Jnl() == nil </span><span class="cov0" title="0">{
                        app.SetJnl(fileevent.NewRecorder(app.Log().Logger))
                        app.Jnl().SetLogger(app.Log().SetLogWriter(os.Stdout))
                }</span>

                <span class="cov0" title="0">options.TZ = app.GetTZ()

                p, err := cmd.Flags().GetString("write-to-folder")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = os.MkdirAll(p, 0o755)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">destFS := osfs.DirFS(p)

                // parse arguments
                fsyss, err := fshelper.ParsePath(args)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(fsyss) == 0 </span><span class="cov0" title="0">{
                        log.Message("No file found matching the pattern: %s", strings.Join(args, ","))
                        return errors.New("No file found matching the pattern: " + strings.Join(args, ","))
                }</span>
                <span class="cov0" title="0">options.InfoCollector = filenames.NewInfoCollector(options.TZ, options.SupportedMedia)
                source, err := folder.NewLocalFiles(ctx, app.Jnl(), options, fsyss...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dest, err := folder.NewLocalAssetWriter(destFS, ".")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return run(ctx, app.Jnl(), app, source, dest)</span>
        }
        <span class="cov0" title="0">return cmd</span>
}

func NewFromGooglePhotosCommand(ctx context.Context, parent *cobra.Command, app *app.Application, archOptions *ArchiveOptions) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "from-google-photos [flags] &lt;takeout-*.zip&gt; | &lt;takeout-folder&gt;",
                Short: "Archive photos either from a zipped Google Photos takeout or decompressed archive",
                Args:  cobra.MinimumNArgs(1),
        }
        cmd.SetContext(ctx)
        options := &amp;gp.ImportFlags{}
        options.AddFromGooglePhotosFlags(cmd, parent)

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{ //nolint:contextcheck
                ctx := cmd.Context()
                log := app.Log()
                if app.Jnl() == nil </span><span class="cov0" title="0">{
                        app.SetJnl(fileevent.NewRecorder(app.Log().Logger))
                        app.Jnl().SetLogger(app.Log().SetLogWriter(os.Stdout))
                }</span>
                <span class="cov0" title="0">options.TZ = app.GetTZ()
                p, err := cmd.Flags().GetString("write-to-folder")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = os.MkdirAll(p, 0o755)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">destFS := osfs.DirFS(p)

                fsyss, err := fshelper.ParsePath(args)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(fsyss) == 0 </span><span class="cov0" title="0">{
                        log.Message("No file found matching the pattern: %s", strings.Join(args, ","))
                        return errors.New("No file found matching the pattern: " + strings.Join(args, ","))
                }</span>
                <span class="cov0" title="0">source, err := gp.NewTakeout(ctx, app.Jnl(), options, fsyss...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">dest, err := folder.NewLocalAssetWriter(destFS, ".")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return run(ctx, app.Jnl(), app, source, dest)</span>
        }

        <span class="cov0" title="0">return cmd</span>
}

func NewFromImmichCommand(ctx context.Context, parent *cobra.Command, app *app.Application, archOptions *ArchiveOptions) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "from-immich [from-flags]",
                Short: "Archive photos from Immich",
        }
        cmd.SetContext(ctx)
        options := &amp;fromimmich.FromImmichFlags{}
        options.AddFromImmichFlags(cmd, parent)

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{ //nolint:contextcheck
                ctx := cmd.Context()
                if app.Jnl() == nil </span><span class="cov0" title="0">{
                        app.SetJnl(fileevent.NewRecorder(app.Log().Logger))
                        app.Jnl().SetLogger(app.Log().SetLogWriter(os.Stdout))
                }</span>

                <span class="cov0" title="0">p, err := cmd.Flags().GetString("write-to-folder")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = os.MkdirAll(p, 0o755)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">destFS := osfs.DirFS(p)

                dest, err := folder.NewLocalAssetWriter(destFS, ".")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">source, err := fromimmich.NewFromImmich(ctx, app, app.Jnl(), options)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return run(ctx, app.Jnl(), app, source, dest)</span>
        }

        <span class="cov0" title="0">return cmd</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package archive

import (
        "context"
        "errors"

        "github.com/simulot/immich-go/adapters"
        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/internal/fileevent"
)

func run(ctx context.Context, jnl *fileevent.Recorder, _ *app.Application, source adapters.Reader, dest adapters.AssetWriter) error <span class="cov0" title="0">{
        gChan := source.Browse(ctx)
        errCount := 0
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case g, ok := &lt;-gChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">for _, a := range g.Assets </span><span class="cov0" title="0">{
                                err := dest.WriteAsset(ctx, a)
                                if err == nil </span><span class="cov0" title="0">{
                                        err = a.Close()
                                }</span>
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        jnl.Log().Error(err.Error())
                                        errCount++
                                        if errCount &gt; 5 </span><span class="cov0" title="0">{
                                                err := errors.New("too many errors, aborting")
                                                jnl.Log().Error(err.Error())
                                                return err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        jnl.Record(ctx, fileevent.Written, a)
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cmd

import (
        "context"

        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/app/cmd/archive"
        "github.com/simulot/immich-go/app/cmd/stack"
        "github.com/simulot/immich-go/app/cmd/upload"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// Run immich-go
func RootImmichGoCommand(ctx context.Context) (*cobra.Command, *app.Application) <span class="cov0" title="0">{
        viper.SetEnvPrefix("IMMICHGO")

        // Create the application context

        // Add the root command
        c := &amp;cobra.Command{
                Use:     "immich-go",
                Short:   "Immich-go is a command line application to interact with the Immich application using its API",
                Long:    `An alternative to the immich-CLI command that doesn't depend on nodejs installation. It tries its best for importing google photos takeout archives.`,
                Version: app.Version,
        }
        cobra.EnableTraverseRunHooks = true // doc: cobra/site/content/user_guide.md
        a := app.New(ctx, c)

        // add immich-go commands
        c.AddCommand(
                app.NewVersionCommand(ctx, a),
                upload.NewUploadCommand(ctx, a),
                archive.NewArchiveCommand(ctx, a),
                stack.NewStackCommand(ctx, a),
        )

        return c, a
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package stack

import (
        "context"
        "sort"
        "time"

        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/immich"
        "github.com/simulot/immich-go/internal/assets"
        cliflags "github.com/simulot/immich-go/internal/cliFlags"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/filetypes"
        "github.com/simulot/immich-go/internal/filters"
        "github.com/simulot/immich-go/internal/groups"
        "github.com/simulot/immich-go/internal/groups/burst"
        "github.com/simulot/immich-go/internal/groups/epsonfastfoto"
        "github.com/simulot/immich-go/internal/groups/series"
        "github.com/spf13/cobra"
)

/*
TODO
- [X] dry-run mode
- [X] existing stack --&gt; apparently correctly handled by the server
- [X] Take sub second exif time into account
*/
type StackCmd struct {
        DateRange cliflags.DateRange // Set capture date range

        // Stack jpg/raw
        StackJpgWithRaw bool

        // Stack burst
        StackBurstPhotos bool

        // SupportedMedia is the server's actual list of supported media types.
        SupportedMedia filetypes.SupportedMedia

        // InfoCollector is used to extract information from the file name.
        InfoCollector *filenames.InfoCollector

        // ManageHEICJPG determines whether to manage HEIC to JPG conversion options.
        ManageHEICJPG filters.HeicJpgFlag

        // ManageRawJPG determines how to manage raw and JPEG files.
        ManageRawJPG filters.RawJPGFlag

        // BurstFlag determines how to manage burst photos.
        ManageBurst filters.BurstFlag

        // ManageEpsonFastFoto enables the management of Epson FastFoto files.
        ManageEpsonFastFoto bool

        TZ *time.Location

        assets []*assets.Asset

        groupers []groups.Grouper // groups are used to group assets
        filters  []filters.Filter // filters are used to filter assets in groups
}

const timeFormat = "2006-01-02T15:04:05.000Z"

func NewStackCommand(ctx context.Context, a *app.Application) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "stack [flags]",
                Short: "Update Immich for stacking related photos",
                Long:  `Stack photos related to each other according to the options`,
        }

        o := &amp;StackCmd{}
        app.AddClientFlags(ctx, cmd, a, false)
        cmd.TraverseChildren = true
        cmd.Flags().Var(&amp;o.ManageHEICJPG, "manage-heic-jpeg", "Manage coupled HEIC and JPEG files. Possible values: KeepHeic, KeepJPG, StackCoverHeic, StackCoverJPG")
        cmd.Flags().Var(&amp;o.ManageRawJPG, "manage-raw-jpeg", "Manage coupled RAW and JPEG files. Possible values: KeepRaw, KeepJPG, StackCoverRaw, StackCoverJPG")
        cmd.Flags().Var(&amp;o.ManageBurst, "manage-burst", "Manage burst photos. Possible values: Stack, StackKeepRaw, StackKeepJPEG")
        cmd.Flags().BoolVar(&amp;o.ManageEpsonFastFoto, "manage-epson-fastfoto", false, "Manage Epson FastFoto file (default: false)")
        cmd.Flags().Var(&amp;o.DateRange, "date-range", "photos must be taken in the date range")

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{ //nolint:contextcheck
                // ready to run
                ctx := cmd.Context()
                client := a.Client()
                o.TZ = a.GetTZ()

                o.InfoCollector = filenames.NewInfoCollector(o.TZ, client.Immich.SupportedMedia())
                o.filters = append(o.filters,
                        o.ManageBurst.GroupFilter(),
                        o.ManageRawJPG.GroupFilter(),
                        o.ManageHEICJPG.GroupFilter())

                if o.ManageEpsonFastFoto </span><span class="cov0" title="0">{
                        o.groupers = append(o.groupers, epsonfastfoto.Group{}.Group)
                }</span>
                <span class="cov0" title="0">if o.ManageBurst != filters.BurstNothing </span><span class="cov0" title="0">{
                        o.groupers = append(o.groupers, burst.Group)
                }</span>
                <span class="cov0" title="0">o.groupers = append(o.groupers, series.Group)

                query := &amp;immich.SearchMetadataQuery{
                        WithExif: true,
                }

                if o.DateRange.IsSet() </span><span class="cov0" title="0">{
                        query.TakenAfter = o.DateRange.After.Format(timeFormat)
                        query.TakenBefore = o.DateRange.Before.Format(timeFormat)
                }</span>
                <span class="cov0" title="0">err := client.Immich.GetAllAssetsWithFilter(ctx, query,
                        func(a *immich.Asset) error </span><span class="cov0" title="0">{
                                if a.IsTrashed </span><span class="cov0" title="0">{
                                        return nil
                                }</span>

                                <span class="cov0" title="0">asset := a.AsAsset()
                                asset.SetNameInfo(o.InfoCollector.GetInfo(asset.OriginalFileName))
                                asset.FromApplication = &amp;assets.Metadata{
                                        FileName:    a.OriginalFileName,
                                        Latitude:    a.ExifInfo.Latitude,
                                        Longitude:   a.ExifInfo.Longitude,
                                        Description: a.ExifInfo.Description,
                                        DateTaken:   a.ExifInfo.DateTimeOriginal.Time,
                                        Trashed:     a.IsTrashed,
                                        Archived:    a.IsArchived,
                                        Favorited:   a.IsFavorite,
                                        Rating:      byte(a.Rating),
                                        Tags:        asset.Tags,
                                }

                                o.assets = append(o.assets, asset)
                                return nil</span>
                        })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = o.ProcessAssets(ctx, a)
                return err</span>
        }
        <span class="cov0" title="0">return cmd</span>
}

func (s *StackCmd) ProcessAssets(ctx context.Context, app *app.Application) error <span class="cov0" title="0">{
        log := app.Log()

        in := make(chan *assets.Asset)

        go func() </span><span class="cov0" title="0">{
                defer close(in)
                // Sort assets by radical, then date
                sort.Slice(s.assets, func(i, j int) bool </span><span class="cov0" title="0">{
                        r1, r2 := s.assets[i].NameInfo.Radical, s.assets[j].NameInfo.Radical
                        if r1 != r2 </span><span class="cov0" title="0">{
                                return r1 &lt; r2
                        }</span>
                        <span class="cov0" title="0">return s.assets[i].CaptureDate.Before(s.assets[j].CaptureDate)</span>
                })
                <span class="cov0" title="0">for _, a := range s.assets </span><span class="cov0" title="0">{
                        select </span>{
                        case in &lt;- a:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        // Group assets
        <span class="cov0" title="0">gChan := groups.NewGrouperPipeline(ctx, s.groupers...).PipeGrouper(ctx, in)

        for g := range gChan </span><span class="cov0" title="0">{
                g = filters.ApplyFilters(g, s.filters...)
                // Delete filtered assets
                if len(g.Removed) &gt; 0 </span><span class="cov0" title="0">{
                        for _, r := range g.Removed </span><span class="cov0" title="0">{
                                if err := app.Client().Immich.DeleteAssets(ctx, []string{r.Asset.ID}, false); err != nil </span><span class="cov0" title="0">{
                                        log.Error("can't delete asset %s: %s", r.Asset.OriginalFileName, err)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Info("Asset %s deleted: %s", r.Asset.OriginalFileName, r.Reason)
                                }</span>
                        }
                }

                <span class="cov0" title="0">if len(g.Assets) &gt; 1 &amp;&amp; g.Grouping != assets.GroupByNone </span><span class="cov0" title="0">{
                        client := app.Client().Immich.(immich.ImmichStackInterface)
                        ids := []string{g.Assets[g.CoverIndex].ID}
                        for _, a := range g.Assets </span><span class="cov0" title="0">{
                                log.Info("Stacking", "file", a.OriginalFileName)
                                if a.ID != ids[0] </span><span class="cov0" title="0">{
                                        ids = append(ids, a.ID)
                                }</span>
                        }
                        <span class="cov0" title="0">if len(ids) &gt; 1 </span><span class="cov0" title="0">{
                                if _, err := client.CreateStack(ctx, ids); err != nil </span><span class="cov0" title="0">{
                                        log.Error("Can't create stack", "error", err)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

//         gChan := make(chan *assets.Group)
//         go func() {
//                 defer close(gChan)
//                 g := assets.NewGroup()
//                 for _, a := range s.assets {
//                         if !g.Add(a) {
//                                 gChan &lt;- g
//                                 g = assets.NewGroup()
//                                 g.Add(a)
//                         }
//                 }
//                 gChan &lt;- g
//         }
//         gs := groups.NewGrouperPipeline(ctx, la.groupers...).PipeGrouper(ctx, in)
//         g = filters.ApplyFilters(g, upCmd.UploadOptions.Filters...)

// filters :=         append( []filters.Filter,)
</pre>
		
		<pre class="file" id="file17" style="display: none">package upload

import (
        "fmt"
        "math"
        "path"
        "path/filepath"
        "time"

        "github.com/simulot/immich-go/immich"
        "github.com/simulot/immich-go/internal/assets"
)

// - - go:generate stringer -type=AdviceCode
type AdviceCode int

func (a AdviceCode) String() string <span class="cov0" title="0">{
        switch a </span>{
        case IDontKnow:<span class="cov0" title="0">
                return "IDontKnow"</span>
        // case SameNameOnServerButNotSure:
        //         return "SameNameOnServerButNotSure"
        case SmallerOnServer:<span class="cov0" title="0">
                return "SmallerOnServer"</span>
        case BetterOnServer:<span class="cov0" title="0">
                return "BetterOnServer"</span>
        case SameOnServer:<span class="cov0" title="0">
                return "SameOnServer"</span>
        case NotOnServer:<span class="cov0" title="0">
                return "NotOnServer"</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("advice(%d)", a)</span>
}

const (
        IDontKnow AdviceCode = iota
        SmallerOnServer
        BetterOnServer
        SameOnServer
        NotOnServer
)

type Advice struct {
        Advice      AdviceCode
        Message     string
        ServerAsset *immich.Asset
        LocalAsset  *assets.Asset
}

func formatBytes(s int64) string <span class="cov0" title="0">{
        suffixes := []string{"B", "KB", "MB", "GB"}
        bytes := float64(s)
        base := 1024.0
        if bytes &lt; base </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.0f %s", bytes, suffixes[0])
        }</span>
        <span class="cov0" title="0">exp := int64(0)
        for bytes &gt;= base &amp;&amp; exp &lt; int64(len(suffixes)-1) </span><span class="cov0" title="0">{
                bytes /= base
                exp++
        }</span>
        <span class="cov0" title="0">roundedSize := math.Round(bytes*10) / 10
        return fmt.Sprintf("%.1f %s", roundedSize, suffixes[exp])</span>
}

func (ai *AssetIndex) adviceSameOnServer(sa *immich.Asset) *Advice <span class="cov0" title="0">{
        return &amp;Advice{
                Advice:      SameOnServer,
                Message:     fmt.Sprintf("An asset with the same name:%q, date:%q and size:%s exists on the server. No need to upload.", sa.OriginalFileName, sa.ExifInfo.DateTimeOriginal.Format(time.DateTime), formatBytes(sa.ExifInfo.FileSizeInByte)),
                ServerAsset: sa,
        }
}</span>

func (ai *AssetIndex) adviceSmallerOnServer(sa *immich.Asset) *Advice <span class="cov0" title="0">{
        return &amp;Advice{
                Advice:      SmallerOnServer,
                Message:     fmt.Sprintf("An asset with the same name:%q and date:%q but with smaller size:%s exists on the server. Replace it.", sa.OriginalFileName, sa.ExifInfo.DateTimeOriginal.Format(time.DateTime), formatBytes(sa.ExifInfo.FileSizeInByte)),
                ServerAsset: sa,
        }
}</span>

func (ai *AssetIndex) adviceBetterOnServer(sa *immich.Asset) *Advice <span class="cov0" title="0">{
        return &amp;Advice{
                Advice:      BetterOnServer,
                Message:     fmt.Sprintf("An asset with the same name:%q and date:%q but with bigger size:%s exists on the server. No need to upload.", sa.OriginalFileName, sa.ExifInfo.DateTimeOriginal.Format(time.DateTime), formatBytes(sa.ExifInfo.FileSizeInByte)),
                ServerAsset: sa,
        }
}</span>

func (ai *AssetIndex) adviceNotOnServer() *Advice <span class="cov0" title="0">{
        return &amp;Advice{
                Advice:  NotOnServer,
                Message: "This a new asset, upload it.",
        }
}</span>

// ShouldUpload check if the server has this asset
//
// The server may have different assets with the same name. This happens with photos produced by digital cameras.
// The server may have the asset, but in lower resolution. Compare the taken date and resolution

func (ai *AssetIndex) ShouldUpload(la *assets.Asset) (*Advice, error) <span class="cov0" title="0">{
        filename := la.OriginalFileName
        if path.Ext(filename) == "" </span><span class="cov0" title="0">{
                filename += path.Ext(la.File.Name())
        }</span>

        <span class="cov0" title="0">ID := la.DeviceAssetID()

        sa := ai.byID[ID]
        if sa != nil </span><span class="cov0" title="0">{
                // the same ID exist on the server
                return ai.adviceSameOnServer(sa), nil
        }</span>

        <span class="cov0" title="0">var l []*immich.Asset

        // check all files with the same name

        n := filepath.Base(filename)
        l = ai.byName[n]
        if len(l) == 0 </span><span class="cov0" title="0">{
                // n = strings.TrimSuffix(n, filepath.Ext(n))
                l = ai.byName[n]
        }</span>

        <span class="cov0" title="0">if len(l) &gt; 0 </span><span class="cov0" title="0">{
                dateTaken := la.CaptureDate
                size := int64(la.FileSize)

                for _, sa = range l </span><span class="cov0" title="0">{
                        compareDate := compareDate(dateTaken, sa.ExifInfo.DateTimeOriginal.Time)
                        compareSize := size - sa.ExifInfo.FileSizeInByte

                        switch </span>{
                        case compareDate == 0 &amp;&amp; compareSize == 0:<span class="cov0" title="0">
                                return ai.adviceSameOnServer(sa), nil</span>
                        case compareDate == 0 &amp;&amp; compareSize &gt; 0:<span class="cov0" title="0">
                                return ai.adviceSmallerOnServer(sa), nil</span>
                        case compareDate == 0 &amp;&amp; compareSize &lt; 0:<span class="cov0" title="0">
                                return ai.adviceBetterOnServer(sa), nil</span>
                        }
                }
        }
        <span class="cov0" title="0">return ai.adviceNotOnServer(), nil</span>
}

func compareDate(d1 time.Time, d2 time.Time) int <span class="cov0" title="0">{
        diff := d1.Sub(d2)

        switch </span>{
        case diff &lt; -5*time.Minute:<span class="cov0" title="0">
                return -1</span>
        case diff &gt;= 5*time.Minute:<span class="cov0" title="0">
                return +1</span>
        }
        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package upload

import (
        "fmt"
        "path"
        "strings"

        "github.com/simulot/immich-go/immich"
        "github.com/simulot/immich-go/internal/assets"
)

type AssetIndex struct {
        assets []*immich.Asset
        byHash map[string][]*immich.Asset
        byName map[string][]*immich.Asset
        byID   map[string]*immich.Asset
        // albums []immich.AlbumSimplified
}

func (ai *AssetIndex) ReIndex() <span class="cov0" title="0">{
        ai.byHash = map[string][]*immich.Asset{}
        ai.byName = map[string][]*immich.Asset{}
        ai.byID = map[string]*immich.Asset{}

        for _, a := range ai.assets </span><span class="cov0" title="0">{
                ID := fmt.Sprintf("%s-%d", a.OriginalFileName, a.ExifInfo.FileSizeInByte)
                l := ai.byHash[a.Checksum]
                l = append(l, a)
                ai.byHash[a.Checksum] = l

                n := a.OriginalFileName
                l = ai.byName[n]
                l = append(l, a)
                ai.byName[n] = l
                ai.byID[ID] = a
        }</span>
}

func (ai *AssetIndex) Len() int <span class="cov0" title="0">{
        return len(ai.assets)
}</span>

func (ai *AssetIndex) AddLocalAsset(la *assets.Asset, immichID string) <span class="cov0" title="0">{
        sa := &amp;immich.Asset{
                ID:               immichID,
                DeviceAssetID:    la.DeviceAssetID(),
                OriginalFileName: strings.TrimSuffix(path.Base(la.OriginalFileName), path.Ext(la.OriginalFileName)),
                ExifInfo: immich.ExifInfo{
                        FileSizeInByte:   int64(la.FileSize),
                        DateTimeOriginal: immich.ImmichExifTime{Time: la.CaptureDate},
                        Latitude:         la.Latitude,
                        Longitude:        la.Longitude,
                },
        }
        ai.assets = append(ai.assets, sa)
        ai.byID[sa.DeviceAssetID] = sa
        l := ai.byName[sa.OriginalFileName]
        l = append(l, sa)
        ai.byName[sa.OriginalFileName] = l
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package upload

import (
        "context"
        "errors"
        "strings"

        "github.com/simulot/immich-go/adapters/folder"
        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/spf13/cobra"
)

func NewFromFolderCommand(ctx context.Context, parent *cobra.Command, app *app.Application, upOptions *UploadOptions) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "from-folder [flags] &lt;path&gt;...",
                Short: "Upload photos from a folder",
                Args:  cobra.MinimumNArgs(1),
        }
        cmd.SetContext(ctx)
        options := &amp;folder.ImportFolderOptions{}
        options.AddFromFolderFlags(cmd, parent)

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{ //nolint:contextcheck
                // ready to run
                ctx := cmd.Context()
                log := app.Log()
                client := app.Client()
                options.TZ = app.GetTZ()

                // parse arguments
                fsyss, err := fshelper.ParsePath(args)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(fsyss) == 0 </span><span class="cov0" title="0">{
                        log.Message("No file found matching the pattern: %s", strings.Join(args, ","))
                        return errors.New("No file found matching the pattern: " + strings.Join(args, ","))
                }</span>

                // create the adapter for folders
                <span class="cov0" title="0">options.SupportedMedia = client.Immich.SupportedMedia()
                upOptions.Filters = append(upOptions.Filters, options.ManageBurst.GroupFilter(), options.ManageRawJPG.GroupFilter(), options.ManageHEICJPG.GroupFilter())

                options.InfoCollector = filenames.NewInfoCollector(app.GetTZ(), options.SupportedMedia)
                adapter, err := folder.NewLocalFiles(ctx, app.Jnl(), options, fsyss...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return newUpload(UpModeFolder, app, upOptions).run(ctx, adapter, app, fsyss)</span>
        }

        <span class="cov0" title="0">return cmd</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package upload

import (
        "context"

        "github.com/simulot/immich-go/adapters/fromimmich"
        "github.com/simulot/immich-go/app"
        "github.com/spf13/cobra"
)

func NewFromImmichCommand(ctx context.Context, parent *cobra.Command, app *app.Application, upOptions *UploadOptions) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "from-immich [flags]",
                Short: "Upload photos from another Immich server",
                Args:  cobra.MaximumNArgs(0),
        }
        cmd.SetContext(ctx)
        options := &amp;fromimmich.FromImmichFlags{}
        options.AddFromImmichFlags(cmd, parent)

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{ //nolint:contextcheck
                // ready to run
                ctx := cmd.Context()

                source, err := fromimmich.NewFromImmich(ctx, app, app.Jnl(), options)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return newUpload(UpModeFolder, app, upOptions).run(ctx, source, app, nil)</span>
        }

        <span class="cov0" title="0">return cmd</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package upload

import (
        "context"
        "errors"
        "path/filepath"
        "regexp"
        "strings"

        gp "github.com/simulot/immich-go/adapters/googlePhotos"
        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/spf13/cobra"
)

var _re3digits = regexp.MustCompile(`-\d{3}$`)

func NewFromGooglePhotosCommand(ctx context.Context, parent *cobra.Command, app *app.Application, upOptions *UploadOptions) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "from-google-photos [flags] &lt;takeout-*.zip&gt; | &lt;takeout-folder&gt;",
                Short: "Upload photos either from a zipped Google Photos takeout or decompressed archive",
                Args:  cobra.MinimumNArgs(1),
        }
        cmd.SetContext(ctx)
        options := &amp;gp.ImportFlags{}
        options.AddFromGooglePhotosFlags(cmd, parent)

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{ //nolint:contextcheck
                ctx := cmd.Context()
                log := app.Log()
                client := app.Client()

                options.TZ = app.GetTZ()

                fsyss, err := fshelper.ParsePath(args)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(fsyss) == 0 </span><span class="cov0" title="0">{
                        log.Message("No file found matching the pattern: %s", strings.Join(args, ","))
                        return errors.New("No file found matching the pattern: " + strings.Join(args, ","))
                }</span>

                <span class="cov0" title="0">if options.TakeoutTag </span><span class="cov0" title="0">{
                        for _, fsys := range fsyss </span><span class="cov0" title="0">{
                                if fsys, ok := fsys.(fshelper.NameFS); ok </span><span class="cov0" title="0">{
                                        options.TakeoutName = fsys.Name()
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if filepath.Ext(options.TakeoutName) == ".zip" </span><span class="cov0" title="0">{
                                options.TakeoutName = strings.TrimSuffix(options.TakeoutName, filepath.Base(options.TakeoutName))
                        }</span>
                        <span class="cov0" title="0">if options.TakeoutName == "" </span><span class="cov0" title="0">{
                                options.TakeoutTag = false
                        }</span>
                        <span class="cov0" title="0">options.TakeoutName = _re3digits.ReplaceAllString(options.TakeoutName, "")</span>
                }

                <span class="cov0" title="0">upOptions.Filters = append(upOptions.Filters, options.ManageBurst.GroupFilter(), options.ManageRawJPG.GroupFilter(), options.ManageHEICJPG.GroupFilter())

                options.SupportedMedia = client.Immich.SupportedMedia()
                options.InfoCollector = filenames.NewInfoCollector(app.GetTZ(), options.SupportedMedia)
                adapter, err := gp.NewTakeout(ctx, app.Jnl(), options, fsyss...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = newUpload(UpModeGoogleTakeout, app, upOptions).setTakeoutOptions(options).run(ctx, adapter, app, fsyss)
                return err</span>
        }

        <span class="cov0" title="0">return cmd</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package upload

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/fileevent"
        "golang.org/x/sync/errgroup"
)

func (upCmd *UpCmd) runNoUI(ctx context.Context, app *app.Application) error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancelCause(ctx)
        lock := sync.RWMutex{}
        defer cancel(nil)

        var preparationDone atomic.Bool

        stopProgress := make(chan any)
        var maxImmich, currImmich int
        spinner := []rune{' ', ' ', '.', ' ', ' '}
        spinIdx := 0

        immichUpdate := func(value, total int) </span><span class="cov0" title="0">{
                lock.Lock()
                currImmich, maxImmich = value, total
                lock.Unlock()
        }</span>

        <span class="cov0" title="0">progressString := func() string </span><span class="cov0" title="0">{
                counts := app.Jnl().GetCounts()
                defer func() </span><span class="cov0" title="0">{
                        spinIdx++
                        if spinIdx == len(spinner) </span><span class="cov0" title="0">{
                                spinIdx = 0
                        }</span>
                }()
                <span class="cov0" title="0">lock.Lock()
                immichPct := 0
                if maxImmich &gt; 0 </span><span class="cov0" title="0">{
                        immichPct = 100 * currImmich / maxImmich
                }</span> else<span class="cov0" title="0"> {
                        immichPct = 100
                }</span>
                <span class="cov0" title="0">lock.Unlock()

                return fmt.Sprintf("\rImmich read %d%%, Assets found: %d, Upload errors: %d, Uploaded %d %s", immichPct, app.Jnl().TotalAssets(), counts[fileevent.UploadServerError], counts[fileevent.Uploaded], string(spinner[spinIdx]))</span>
        }
        <span class="cov0" title="0">uiGrp := errgroup.Group{}

        uiGrp.Go(func() error </span><span class="cov0" title="0">{
                ticker := time.NewTicker(500 * time.Millisecond)
                defer func() </span><span class="cov0" title="0">{
                        ticker.Stop()
                        fmt.Println(progressString())
                }</span>()
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-stopProgress:<span class="cov0" title="0">
                                fmt.Print(progressString())
                                return nil</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                fmt.Print(progressString())
                                return ctx.Err()</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                fmt.Print(progressString())</span>
                        }
                }
        })

        <span class="cov0" title="0">uiGrp.Go(func() error </span><span class="cov0" title="0">{
                processGrp := errgroup.Group{}
                var groupChan chan *assets.Group
                var err error

                processGrp.Go(func() error </span><span class="cov0" title="0">{
                        // Get immich asset
                        err := upCmd.getImmichAssets(ctx, immichUpdate)
                        if err != nil </span><span class="cov0" title="0">{
                                cancel(err)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                })
                <span class="cov0" title="0">processGrp.Go(func() error </span><span class="cov0" title="0">{
                        return upCmd.getImmichAlbums(ctx)
                }</span>)
                <span class="cov0" title="0">processGrp.Go(func() error </span><span class="cov0" title="0">{
                        // Run Prepare
                        groupChan = upCmd.adapter.Browse(ctx)
                        return err
                }</span>)
                <span class="cov0" title="0">err = processGrp.Wait()
                if err != nil </span><span class="cov0" title="0">{
                        err := context.Cause(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                cancel(err)
                                return err
                        }</span>
                }
                <span class="cov0" title="0">preparationDone.Store(true)
                err = upCmd.uploadLoop(ctx, groupChan)
                if err != nil </span><span class="cov0" title="0">{
                        cancel(err)
                }</span>

                <span class="cov0" title="0">counts := app.Jnl().GetCounts()
                messages := strings.Builder{}
                if counts[fileevent.Error]+counts[fileevent.UploadServerError] &gt; 0 </span><span class="cov0" title="0">{
                        messages.WriteString("Some errors have occurred. Look at the log file for details\n")
                }</span>

                <span class="cov0" title="0">if messages.Len() &gt; 0 </span><span class="cov0" title="0">{
                        cancel(errors.New(messages.String()))
                }</span>
                <span class="cov0" title="0">close(stopProgress)
                return err</span>
        })

        <span class="cov0" title="0">err := uiGrp.Wait()
        if err != nil </span><span class="cov0" title="0">{
                err = context.Cause(ctx)
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package upload

import (
        "context"
        "errors"
        "fmt"
        "io/fs"

        "github.com/gdamore/tcell/v2"
        "github.com/simulot/immich-go/adapters"
        gp "github.com/simulot/immich-go/adapters/googlePhotos"
        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/immich"
        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/bulktags"
        "github.com/simulot/immich-go/internal/fileevent"
        "github.com/simulot/immich-go/internal/filters"
        "github.com/simulot/immich-go/internal/fshelper"
)

type UpCmd struct {
        Mode UpLoadMode
        *UploadOptions
        app *app.Application

        AssetIndex       *AssetIndex     // List of assets present on the server
        deleteServerList []*immich.Asset // List of server assets to remove

        adapter       adapters.Reader
        DebugCounters bool // Enable CSV action counters per file

        Paths  []string                // Path to explore
        albums map[string]assets.Album // Albums by title

        tm *bulktags.BulkTagManager // Bulk tag manager

        takeoutOptions *gp.ImportFlags
}

func newUpload(mode UpLoadMode, app *app.Application, options *UploadOptions) *UpCmd <span class="cov0" title="0">{
        upCmd := &amp;UpCmd{
                UploadOptions: options,
                app:           app,
                Mode:          mode,
        }
        return upCmd
}</span>

func (upCmd *UpCmd) setTakeoutOptions(options *gp.ImportFlags) *UpCmd <span class="cov0" title="0">{
        upCmd.takeoutOptions = options
        return upCmd
}</span>

func (upCmd *UpCmd) run(ctx context.Context, adapter adapters.Reader, app *app.Application, fsys []fs.FS) error <span class="cov0" title="0">{
        upCmd.adapter = adapter
        upCmd.tm = bulktags.NewBulkTagManager(ctx, app.Client().Immich, app.Log().Logger)
        defer upCmd.tm.Close()

        runner := upCmd.runUI

        if upCmd.NoUI </span><span class="cov0" title="0">{
                runner = upCmd.runNoUI
        }</span>
        <span class="cov0" title="0">_, err := tcell.NewScreen()
        if err != nil </span><span class="cov0" title="0">{
                upCmd.app.Log().Error("can't initialize the screen for the UI mode. Falling back to no-gui mode")
                fmt.Println("can't initialize the screen for the UI mode. Falling back to no-gui mode")
                runner = upCmd.runNoUI
        }</span>
        <span class="cov0" title="0">err = runner(ctx, app)

        err = errors.Join(err, fshelper.CloseFSs(fsys))
        app.Jnl().Report()

        return err</span>
}

func (upCmd *UpCmd) getImmichAlbums(ctx context.Context) error <span class="cov0" title="0">{
        serverAlbums, err := upCmd.app.Client().Immich.GetAllAlbums(ctx)
        upCmd.albums = map[string]assets.Album{}
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't get the album list from the server: %w", err)
        }</span>
        <span class="cov0" title="0">for _, a := range serverAlbums </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        upCmd.albums[a.Title] = a</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (upCmd *UpCmd) getImmichAssets(ctx context.Context, updateFn progressUpdate) error <span class="cov0" title="0">{
        statistics, err := upCmd.app.Client().Immich.GetAssetStatistics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">totalOnImmich := statistics.Total
        received := 0

        var list []*immich.Asset

        err = upCmd.app.Client().Immich.GetAllAssetsWithFilter(ctx, nil, func(a *immich.Asset) error </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        received++
                        list = append(list, a)
                        if updateFn != nil </span><span class="cov0" title="0">{
                                updateFn(received, totalOnImmich)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if updateFn != nil </span><span class="cov0" title="0">{
                updateFn(totalOnImmich, totalOnImmich)
        }</span>
        <span class="cov0" title="0">upCmd.AssetIndex = &amp;AssetIndex{
                assets: list,
        }
        upCmd.app.Log().Info(fmt.Sprintf("Assets on the server: %d", len(list)))
        upCmd.AssetIndex.ReIndex()
        return nil</span>
}

func (upCmd *UpCmd) uploadLoop(ctx context.Context, groupChan chan *assets.Group) error <span class="cov0" title="0">{
        var err error
assetLoop:
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>

                case g, ok := &lt;-groupChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                break assetLoop</span>
                        }
                        <span class="cov0" title="0">err = upCmd.handleGroup(ctx, g)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(upCmd.deleteServerList) &gt; 0 </span><span class="cov0" title="0">{
                ids := []string{}
                for _, da := range upCmd.deleteServerList </span><span class="cov0" title="0">{
                        ids = append(ids, da.ID)
                }</span>
                <span class="cov0" title="0">err := upCmd.DeleteServerAssets(ctx, ids)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("can't delete server's assets: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}

func (upCmd *UpCmd) handleGroup(ctx context.Context, g *assets.Group) error <span class="cov0" title="0">{
        var errGroup error

        g = filters.ApplyFilters(g, upCmd.UploadOptions.Filters...)

        // discard rejected assets
        for _, a := range g.Removed </span><span class="cov0" title="0">{
                a.Asset.Close()
                upCmd.app.Jnl().Record(ctx, fileevent.DiscoveredDiscarded, a.Asset.File, "reason", a.Reason)
        }</span>

        // Upload assets from the group
        <span class="cov0" title="0">for _, a := range g.Assets </span><span class="cov0" title="0">{
                err := upCmd.handleAsset(ctx, a)
                errGroup = errors.Join(err)
        }</span>

        // Manage groups
        // after the filtering and the upload, we can stack the assets

        <span class="cov0" title="0">if len(g.Assets) &gt; 1 &amp;&amp; g.Grouping != assets.GroupByNone </span><span class="cov0" title="0">{
                client := upCmd.app.Client().Immich.(immich.ImmichStackInterface)
                ids := []string{g.Assets[g.CoverIndex].ID}
                for i, a := range g.Assets </span><span class="cov0" title="0">{
                        upCmd.app.Jnl().Record(ctx, fileevent.Stacked, g.Assets[i].File)
                        if i != g.CoverIndex &amp;&amp; a.ID != "" </span><span class="cov0" title="0">{
                                ids = append(ids, a.ID)
                        }</span>
                }
                <span class="cov0" title="0">if len(ids) &gt; 1 </span><span class="cov0" title="0">{
                        _, err := client.CreateStack(ctx, ids)
                        if err != nil </span><span class="cov0" title="0">{
                                upCmd.app.Jnl().Log().Error("Can't create stack", "error", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if errGroup != nil </span><span class="cov0" title="0">{
                return errGroup
        }</span>

        <span class="cov0" title="0">switch g.Grouping </span>{
        case assets.GroupByNone:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (upCmd *UpCmd) handleAsset(ctx context.Context, a *assets.Asset) error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                a.Close() // Close and clean resources linked to the local asset
        }</span>()

        <span class="cov0" title="0">advice, err := upCmd.AssetIndex.ShouldUpload(a)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the asset exists on the server, at full size, or smaller, we should get its tags and not tag it again.
        <span class="cov0" title="0">if advice.ServerAsset != nil </span><span class="cov0" title="0">{
                serverAsset, err := upCmd.app.Client().Immich.GetAssetInfo(ctx, advice.ServerAsset.ID)
                if err == nil </span><span class="cov0" title="0">{
                        newList := []assets.Tag{}
                        for _, t := range a.Tags </span><span class="cov0" title="0">{
                                keepMe := true
                                for _, st := range serverAsset.Tags </span><span class="cov0" title="0">{
                                        if t.Name == st.Name </span><span class="cov0" title="0">{
                                                keepMe = false
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if keepMe </span><span class="cov0" title="0">{
                                        newList = append(newList, t)
                                }</span>
                        }
                        <span class="cov0" title="0">a.Tags = newList</span>
                }
        }

        <span class="cov0" title="0">switch advice.Advice </span>{
        case NotOnServer:<span class="cov0" title="0"> // Upload and manage albums
                err = upCmd.uploadAsset(ctx, a)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Manage albums
                <span class="cov0" title="0">if len(a.Albums) &gt; 0 </span><span class="cov0" title="0">{
                        upCmd.manageAssetAlbums(ctx, a.File, a.ID, a.Albums)
                }</span>
                <span class="cov0" title="0">upCmd.manageAssetTags(ctx, a)
                return nil</span>
        case SmallerOnServer:<span class="cov0" title="0"> // Upload, manage albums and delete the server's asset

                // Remember existing asset's albums, if any
                for _, al := range advice.ServerAsset.Albums </span><span class="cov0" title="0">{
                        a.Albums = append(a.Albums, assets.Album{
                                Title:       al.AlbumName,
                                Description: al.Description,
                        })
                }</span>

                // Upload the superior asset
                <span class="cov0" title="0">err = upCmd.replaceAsset(ctx, advice.ServerAsset.ID, a)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">upCmd.app.Jnl().Record(ctx, fileevent.UploadUpgraded, a, "reason", advice.Message)

                // Manage albums
                if len(a.Albums) &gt; 0 </span><span class="cov0" title="0">{
                        upCmd.manageAssetAlbums(ctx, a.File, advice.ServerAsset.ID, a.Albums)
                }</span>

                <span class="cov0" title="0">upCmd.manageAssetTags(ctx, a)
                return err</span>

        case SameOnServer:<span class="cov0" title="0">
                a.ID = advice.ServerAsset.ID
                for _, al := range advice.ServerAsset.Albums </span><span class="cov0" title="0">{
                        a.Albums = append(a.Albums, assets.Album{
                                Title:       al.AlbumName,
                                Description: al.Description,
                        })
                }</span>
                <span class="cov0" title="0">upCmd.app.Jnl().Record(ctx, fileevent.UploadServerDuplicate, a.File, "reason", advice.Message)
                upCmd.manageAssetAlbums(ctx, a.File, a.ID, a.Albums)</span>

        case BetterOnServer:<span class="cov0" title="0"> // and manage albums
                a.ID = advice.ServerAsset.ID
                upCmd.app.Jnl().Record(ctx, fileevent.UploadServerBetter, a.File, "reason", advice.Message)
                upCmd.manageAssetAlbums(ctx, a.File, a.ID, a.Albums)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// uploadAsset uploads the asset to the server.
// set the server's asset ID to the asset.
func (upCmd *UpCmd) uploadAsset(ctx context.Context, a *assets.Asset) error <span class="cov0" title="0">{
        defer upCmd.app.Log().Debug("", "file", a)
        ar, err := upCmd.app.Client().Immich.AssetUpload(ctx, a)
        if err != nil </span><span class="cov0" title="0">{
                upCmd.app.Jnl().Record(ctx, fileevent.UploadServerError, a.File, "error", err.Error())
                return err // Must signal the error to the caller
        }</span>
        <span class="cov0" title="0">if ar.Status == immich.UploadDuplicate </span><span class="cov0" title="0">{
                upCmd.app.Jnl().Record(ctx, fileevent.UploadServerDuplicate, a.File, "reason", "the server has this file")
        }</span> else<span class="cov0" title="0"> {
                upCmd.app.Jnl().Record(ctx, fileevent.Uploaded, a.File)
        }</span>
        <span class="cov0" title="0">a.ID = ar.ID

        if a.FromApplication != nil </span><span class="cov0" title="0">{
                // metadata from application (immich or google photos) are forced.
                // if a.Description != "" || (a.Latitude != 0 &amp;&amp; a.Longitude != 0) || a.Rating != 0 || !a.CaptureDate.IsZero() {
                a.UseMetadata(a.FromApplication)
                _, err := upCmd.app.Client().Immich.UpdateAsset(ctx, a.ID, immich.UpdAssetField{
                        Description:      a.Description,
                        Latitude:         a.Latitude,
                        Longitude:        a.Longitude,
                        Rating:           a.Rating,
                        DateTimeOriginal: a.CaptureDate,
                })
                if err != nil </span><span class="cov0" title="0">{
                        upCmd.app.Jnl().Record(ctx, fileevent.UploadServerError, a.File, "error", err.Error())
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (upCmd *UpCmd) replaceAsset(ctx context.Context, ID string, a *assets.Asset) error <span class="cov0" title="0">{
        defer upCmd.app.Log().Debug("replaced by", "file", a)
        ar, err := upCmd.app.Client().Immich.ReplaceAsset(ctx, ID, a)
        if err != nil </span><span class="cov0" title="0">{
                upCmd.app.Jnl().Record(ctx, fileevent.UploadServerError, a.File, "error", err.Error())
                return err // Must signal the error to the caller
        }</span>
        <span class="cov0" title="0">if ar.Status == immich.UploadDuplicate </span><span class="cov0" title="0">{
                upCmd.app.Jnl().Record(ctx, fileevent.UploadServerDuplicate, a.File, "reason", "the server has this file")
        }</span> else<span class="cov0" title="0"> {
                upCmd.app.Jnl().Record(ctx, fileevent.UploadUpgraded, a.File)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// manageAssetAlbums add the assets to the albums listed.
// If an album does not exist, it is created.
// Errors are logged.
func (upCmd *UpCmd) manageAssetAlbums(ctx context.Context, f fshelper.FSAndName, ID string, albums []assets.Album) <span class="cov0" title="0">{
        for _, album := range albums </span><span class="cov0" title="0">{
                title := album.Title
                l, exist := upCmd.albums[title]
                if !exist </span><span class="cov0" title="0">{
                        newAl, err := upCmd.app.Client().Immich.CreateAlbum(ctx, title, album.Description, []string{ID})
                        if err != nil </span><span class="cov0" title="0">{
                                upCmd.app.Jnl().Record(ctx, fileevent.Error, nil, "error", err)
                        }</span>
                        <span class="cov0" title="0">upCmd.albums[title] = newAl
                        l = newAl</span>
                } else<span class="cov0" title="0"> {
                        _, err := upCmd.app.Client().Immich.AddAssetToAlbum(ctx, l.ID, []string{ID})
                        if err != nil </span><span class="cov0" title="0">{
                                upCmd.app.Jnl().Record(ctx, fileevent.Error, nil, "error", err)
                                return
                        }</span>
                }

                // Log the action
                <span class="cov0" title="0">upCmd.app.Jnl().Record(ctx, fileevent.UploadAddToAlbum, f, "Album", title)</span>
        }
}

func (upCmd *UpCmd) manageAssetTags(ctx context.Context, a *assets.Asset) <span class="cov0" title="0">{
        if len(a.Tags) &gt; 0 </span><span class="cov0" title="0">{
                // Get asset's tags
                for _, t := range a.Tags </span><span class="cov0" title="0">{
                        upCmd.tm.AddTag(t.Value, a.ID)
                        upCmd.app.Jnl().Record(ctx, fileevent.Tagged, a.File, "tags", t.Name)
                }</span>
        }
}

func (upCmd *UpCmd) DeleteServerAssets(ctx context.Context, ids []string) error <span class="cov0" title="0">{
        upCmd.app.Log().Message("%d server assets to delete.", len(ids))
        return upCmd.app.Client().Immich.DeleteAssets(ctx, ids, false)
}</span>

/*
func (app *UpCmd) DeleteLocalAssets() error {
        app.RootImmichFlags.Message(fmt.Sprintf("%d local assets to delete.", len(app.deleteLocalList)))

        for _, a := range app.deleteLocalList {
                if !app.DryRun {
                        app.Log.Info(fmt.Sprintf("delete file %q", a.Title))
                        err := a.Remove()
                        if err != nil {
                                return err
                        }
                } else {
                        app.Log.Info(fmt.Sprintf("file %q not deleted, dry run mode.", a.Title))
                }
        }
        return nil
}
*/
</pre>
		
		<pre class="file" id="file24" style="display: none">package upload

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "sync/atomic"
        "time"

        "github.com/gdamore/tcell/v2"
        "github.com/navidys/tvxwidgets"
        "github.com/rivo/tview"
        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/fileevent"
        "golang.org/x/sync/errgroup"
)

type uiPage struct {
        screen        *tview.Grid
        footer        *tview.Grid
        prepareCounts *tview.Grid
        uploadCounts  *tview.Grid
        serverJobs    *tvxwidgets.Sparkline
        logView       *tview.TextView
        counts        map[fileevent.Code]*tview.TextView

        // server's activity history
        serverActivity []float64

        // detect when the server is idling
        lastTimeServerActive atomic.Int64

        // gauges
        immichReading *tvxwidgets.PercentageModeGauge
        immichPrepare *tvxwidgets.PercentageModeGauge
        immichUpload  *tvxwidgets.PercentageModeGauge

        watchJobs bool
}

func (ui *uiPage) highJackLogger(app *app.Application) <span class="cov0" title="0">{
        ui.logView.SetDynamicColors(true)
        app.Jnl().SetLogger(app.Log().SetLogWriter(tview.ANSIWriter(ui.logView)))
}</span>

func (ui *uiPage) restoreLogger(app *app.Application) <span class="cov0" title="0">{
        app.Jnl().SetLogger(app.Log().SetLogWriter(nil))
}</span>

func (upCmd *UpCmd) runUI(ctx context.Context, app *app.Application) error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancelCause(ctx)

        uiApp := tview.NewApplication()
        ui := upCmd.newUI(ctx, app)

        defer cancel(nil)
        pages := tview.NewPages()

        var preparationDone atomic.Bool
        var uploadDone atomic.Bool
        var uiGroup errgroup.Group
        var messages strings.Builder

        uiApp.SetRoot(pages, true)

        stopUI := func(err error) </span><span class="cov0" title="0">{
                cancel(err)
                if uiApp != nil </span><span class="cov0" title="0">{
                        uiApp.Stop()
                }</span>
        }

        <span class="cov0" title="0">pages.AddPage("ui", ui.screen, true, true)

        // handle Ctrl+C and Ctrl+Q
        uiApp.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                switch event.Key() </span>{
                case tcell.KeyCtrlQ, tcell.KeyCtrlC:<span class="cov0" title="0">
                        ui.restoreLogger(app)
                        cancel(errors.New("interrupted: Ctrl+C or Ctrl+Q pressed"))</span>
                case tcell.KeyEnter:<span class="cov0" title="0">
                        if uploadDone.Load() </span><span class="cov0" title="0">{
                                stopUI(nil)
                        }</span>
                }
                <span class="cov0" title="0">return event</span>
        })

        // update server status
        <span class="cov0" title="0">if ui.watchJobs </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        tick := time.NewTicker(250 * time.Millisecond)
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        tick.Stop()
                                        return</span>
                                case &lt;-tick.C:<span class="cov0" title="0">
                                        jobs, err := upCmd.app.Client().Immich.GetJobs(ctx)
                                        if err == nil </span><span class="cov0" title="0">{
                                                jobCount := 0
                                                jobWaiting := 0
                                                for _, j := range jobs </span><span class="cov0" title="0">{
                                                        jobCount += j.JobCounts.Active
                                                        jobWaiting += j.JobCounts.Waiting
                                                }</span>
                                                <span class="cov0" title="0">_, _, w, _ := ui.serverJobs.GetInnerRect()
                                                ui.serverActivity = append(ui.serverActivity, float64(jobCount))
                                                if len(ui.serverActivity) &gt; w </span><span class="cov0" title="0">{
                                                        ui.serverActivity = ui.serverActivity[1:]
                                                }</span>
                                                <span class="cov0" title="0">ui.serverJobs.SetData(ui.serverActivity)
                                                ui.serverJobs.SetTitle(fmt.Sprintf("Server's jobs: active: %d, waiting: %d", jobCount, jobWaiting))
                                                if jobCount &gt; 0 </span><span class="cov0" title="0">{
                                                        ui.lastTimeServerActive.Store(time.Now().Unix())
                                                }</span>
                                        }
                                }
                        }
                }()
        }

        // force the ui to redraw counters
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                tick := time.NewTicker(100 * time.Millisecond)
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                tick.Stop()
                                return</span>
                        case &lt;-tick.C:<span class="cov0" title="0">
                                uiApp.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                                        counts := app.Jnl().GetCounts()
                                        for c := range ui.counts </span><span class="cov0" title="0">{
                                                ui.getCountView(c, counts[c])
                                        }</span>
                                        <span class="cov0" title="0">if upCmd.Mode == UpModeGoogleTakeout </span><span class="cov0" title="0">{
                                                ui.immichPrepare.SetMaxValue(int(app.Jnl().TotalAssets()))
                                                ui.immichPrepare.SetValue(int(app.Jnl().TotalProcessedGP()))

                                                if preparationDone.Load() </span><span class="cov0" title="0">{
                                                        ui.immichUpload.SetMaxValue(int(app.Jnl().TotalAssets()))
                                                }</span>
                                                <span class="cov0" title="0">ui.immichUpload.SetValue(int(app.Jnl().TotalProcessed(upCmd.takeoutOptions.KeepJSONLess)))</span>
                                        }
                                })
                        }
                }
        }()

        // start the UI
        <span class="cov0" title="0">uiGroup.Go(func() error </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        err := uiApp.Run()
                        cancel(err)
                        return err</span>
                }
        })

        // start the processes
        <span class="cov0" title="0">uiGroup.Go(func() error </span><span class="cov0" title="0">{
                var groupChan chan *assets.Group
                var err error
                processGrp := errgroup.Group{}
                processGrp.Go(func() error </span><span class="cov0" title="0">{
                        // Get immich asset
                        err = upCmd.getImmichAssets(ctx, ui.updateImmichReading)
                        if err != nil </span><span class="cov0" title="0">{
                                stopUI(err)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                })
                <span class="cov0" title="0">processGrp.Go(func() error </span><span class="cov0" title="0">{
                        err = upCmd.getImmichAlbums(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                stopUI(err)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                })
                <span class="cov0" title="0">processGrp.Go(func() error </span><span class="cov0" title="0">{
                        // Run Prepare
                        groupChan = upCmd.adapter.Browse(ctx)
                        return nil
                }</span>)

                // Wait the end of the preparation: immich assets, albums and first browsing
                <span class="cov0" title="0">err = processGrp.Wait()
                if err != nil </span><span class="cov0" title="0">{
                        return context.Cause(ctx)
                }</span>
                <span class="cov0" title="0">preparationDone.Store(true)

                // we can upload assets
                err = upCmd.uploadLoop(ctx, groupChan)
                if err != nil </span><span class="cov0" title="0">{
                        return context.Cause(ctx)
                }</span>
                <span class="cov0" title="0">uploadDone.Store(true)
                counts := app.Jnl().GetCounts()
                if counts[fileevent.Error]+counts[fileevent.UploadServerError] &gt; 0 </span><span class="cov0" title="0">{
                        messages.WriteString("Some errors have occurred. Look at the log file for details\n")
                }</span>

                <span class="cov0" title="0">modal := newModal(messages.String())
                pages.AddPage("modal", modal, true, false)
                // upload is done!
                pages.ShowPage("modal")

                return err</span>
        })

        // Wait for termination of UI processes
        <span class="cov0" title="0">err := uiGroup.Wait()
        if err != nil </span><span class="cov0" title="0">{
                err = context.Cause(ctx)
        }</span>

        // Time to leave
        <span class="cov0" title="0">if messages.Len() &gt; 0 </span><span class="cov0" title="0">{
                return (errors.New(messages.String()))
        }</span>
        <span class="cov0" title="0">return err</span>
}

func newModal(message string) tview.Primitive <span class="cov0" title="0">{
        message += "\nYou can quit the program safely.\n\nPress the [enter] key to exit."
        lines := strings.Count(message, "\n")
        // Returns a new primitive which puts the provided primitive in the center and
        // sets its size to the given width and height.
        modal := func(p tview.Primitive, width, height int) tview.Primitive </span><span class="cov0" title="0">{
                return tview.NewFlex().
                        AddItem(nil, 0, 1, false).
                        AddItem(tview.NewFlex().SetDirection(tview.FlexRow).
                                AddItem(nil, 0, 1, false).
                                AddItem(p, height, 1, true).
                                AddItem(nil, 0, 1, false), width, 1, true).
                        AddItem(nil, 0, 1, false)
        }</span>
        <span class="cov0" title="0">text := tview.NewTextView().SetText(message)
        box := tview.NewBox().
                SetBorder(true).
                SetTitle("Upload completed")
        text.Box = box
        return modal(text, 80, 2+lines)</span>
}

func (upCmd *UpCmd) newUI(ctx context.Context, a *app.Application) *uiPage <span class="cov0" title="0">{
        ui := &amp;uiPage{
                counts: map[fileevent.Code]*tview.TextView{},
        }

        ui.screen = tview.NewGrid()

        ui.screen.AddItem(tview.NewTextView().SetText(app.Banner()), 0, 0, 1, 1, 0, 0, false)

        ui.prepareCounts = tview.NewGrid()
        ui.prepareCounts.SetBorder(true).SetTitle("Input analysis")

        ui.addCounter(ui.prepareCounts, 0, "Images", fileevent.DiscoveredImage)
        ui.addCounter(ui.prepareCounts, 1, "Videos", fileevent.DiscoveredVideo)
        ui.addCounter(ui.prepareCounts, 2, "Metadata files", fileevent.DiscoveredSidecar)
        ui.addCounter(ui.prepareCounts, 3, "Discarded files", fileevent.DiscoveredDiscarded)
        ui.addCounter(ui.prepareCounts, 4, "Unsupported files", fileevent.DiscoveredUnsupported)
        ui.addCounter(ui.prepareCounts, 5, "Duplicates in the input", fileevent.AnalysisLocalDuplicate)
        ui.addCounter(ui.prepareCounts, 6, "Files with a sidecar", fileevent.AnalysisAssociatedMetadata)
        ui.addCounter(ui.prepareCounts, 7, "Files without sidecar", fileevent.AnalysisMissingAssociatedMetadata)

        ui.prepareCounts.SetSize(8, 2, 1, 1).SetColumns(30, 10)

        ui.uploadCounts = tview.NewGrid()
        ui.uploadCounts.SetBorder(true).SetTitle("Uploading")

        ui.addCounter(ui.uploadCounts, 0, "Files uploaded", fileevent.Uploaded)
        ui.addCounter(ui.uploadCounts, 1, "Errors during upload", fileevent.UploadServerError)
        ui.addCounter(ui.uploadCounts, 2, "Files not selected", fileevent.UploadNotSelected)
        ui.addCounter(ui.uploadCounts, 3, "Server's asset upgraded", fileevent.UploadUpgraded)
        ui.addCounter(ui.uploadCounts, 4, "Server has same quality", fileevent.UploadServerDuplicate)
        ui.addCounter(ui.uploadCounts, 5, "Server has better quality", fileevent.UploadServerBetter)
        ui.uploadCounts.SetSize(6, 2, 1, 1).SetColumns(30, 10)

        if _, err := a.Client().Immich.GetJobs(ctx); err == nil </span><span class="cov0" title="0">{
                ui.watchJobs = true

                ui.serverJobs = tvxwidgets.NewSparkline()
                ui.serverJobs.SetBorder(true).SetTitle("Server pending jobs")
                ui.serverJobs.SetData(ui.serverActivity)
                ui.serverJobs.SetDataTitleColor(tcell.ColorDarkOrange)
                ui.serverJobs.SetLineColor(tcell.ColorSteelBlue)
        }</span>

        <span class="cov0" title="0">counts := tview.NewGrid()
        counts.Box = tview.NewBox()
        counts.AddItem(ui.prepareCounts, 0, 0, 1, 1, 0, 0, false)
        counts.AddItem(ui.uploadCounts, 0, 1, 1, 1, 0, 0, false)
        if ui.watchJobs </span><span class="cov0" title="0">{
                counts.AddItem(ui.serverJobs, 0, 2, 1, 1, 0, 0, false)
        }</span>
        <span class="cov0" title="0">counts.SetSize(1, 3, 15, 40)
        counts.SetColumns(40, 40, 0)

        ui.screen.AddItem(counts, 1, 0, 1, 1, 0, 0, false)

        // Hijack the log
        ui.logView = tview.NewTextView().SetMaxLines(100).ScrollToEnd()
        ui.highJackLogger(a)

        ui.logView.SetBorder(true).SetTitle("Log")
        ui.screen.AddItem(ui.logView, 2, 0, 1, 1, 0, 0, false)

        ui.immichReading = tvxwidgets.NewPercentageModeGauge()
        ui.immichReading.SetRect(0, 0, 50, 1)
        ui.immichReading.SetMaxValue(0)
        ui.immichReading.SetValue(0)

        ui.immichPrepare = tvxwidgets.NewPercentageModeGauge()
        ui.immichPrepare.SetRect(0, 0, 50, 1)
        ui.immichPrepare.SetMaxValue(0)
        ui.immichPrepare.SetValue(0)

        ui.immichUpload = tvxwidgets.NewPercentageModeGauge()
        ui.immichUpload.SetRect(0, 0, 50, 1)
        ui.immichUpload.SetMaxValue(0)
        ui.immichUpload.SetValue(0)

        ui.footer = tview.NewGrid()
        ui.footer.AddItem(tview.NewTextView().SetText("Immich content:").SetTextAlign(tview.AlignCenter), 0, 0, 1, 1, 0, 0, false).AddItem(ui.immichReading, 0, 1, 1, 1, 0, 0, false)

        if upCmd.Mode == UpModeGoogleTakeout </span><span class="cov0" title="0">{
                ui.footer.AddItem(tview.NewTextView().SetText("Google Photo puzzle:").SetTextAlign(tview.AlignCenter), 0, 2, 1, 1, 0, 0, false).AddItem(ui.immichPrepare, 0, 3, 1, 1, 0, 0, false)
                ui.footer.AddItem(tview.NewTextView().SetText("Uploading:").SetTextAlign(tview.AlignCenter), 0, 4, 1, 1, 0, 0, false).AddItem(ui.immichUpload, 0, 5, 1, 1, 0, 0, false)
                ui.footer.SetColumns(25, 0, 25, 0, 25, 0)
        }</span> else<span class="cov0" title="0"> {
                ui.footer.SetColumns(25, 0)
        }</span>
        <span class="cov0" title="0">ui.screen.AddItem(ui.footer, 3, 0, 1, 1, 0, 0, false)

        // Adjust section's height
        ui.screen.SetRows(4, 10, 0, 1)
        return ui</span>
}

type progressUpdate func(value, maxValue int)

// call back to get the progression
func (ui *uiPage) updateImmichReading(value, total int) <span class="cov0" title="0">{
        if value == 0 &amp;&amp; total == 0 </span><span class="cov0" title="0">{
                total, value = 100, 100
        }</span>
        <span class="cov0" title="0">ui.immichReading.SetMaxValue(total)
        ui.immichReading.SetValue(value)</span>
}

func (ui *uiPage) getCountView(c fileevent.Code, count int64) *tview.TextView <span class="cov0" title="0">{
        v, ok := ui.counts[c]
        if !ok </span><span class="cov0" title="0">{
                v = tview.NewTextView()
                ui.counts[c] = v
        }</span>
        <span class="cov0" title="0">v.SetText(fmt.Sprintf("%6d", count))
        return v</span>
}

func (ui *uiPage) addCounter(g *tview.Grid, row int, label string, counter fileevent.Code) <span class="cov0" title="0">{
        g.AddItem(tview.NewTextView().SetText(label), row, 0, 1, 1, 0, 0, false)
        g.AddItem(ui.getCountView(counter, 0), row, 1, 1, 1, 0, 0, false)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package upload

import (
        "context"
        "time"

        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/internal/fileevent"
        "github.com/simulot/immich-go/internal/filters"
        "github.com/spf13/cobra"
)

type UpLoadMode int

const (
        UpModeGoogleTakeout UpLoadMode = iota
        UpModeFolder
)

func (m UpLoadMode) String() string <span class="cov0" title="0">{
        switch m </span>{
        case UpModeGoogleTakeout:<span class="cov0" title="0">
                return "Google Takeout"</span>
        case UpModeFolder:<span class="cov0" title="0">
                return "Folder"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// UploadOptions represents a set of common flags used for filtering assets.
type UploadOptions struct {
        // TODO place this option at the top
        NoUI bool // Disable UI

        Filters []filters.Filter
}

// NewUploadCommand adds the Upload command
func NewUploadCommand(ctx context.Context, a *app.Application) *cobra.Command <span class="cov0" title="0">{
        options := &amp;UploadOptions{}
        cmd := &amp;cobra.Command{
                Use:   "upload",
                Short: "Upload photos to an Immich server from various sources",
        }
        app.AddClientFlags(ctx, cmd, a, false)
        cmd.TraverseChildren = true
        cmd.PersistentFlags().BoolVar(&amp;options.NoUI, "no-ui", false, "Disable the user interface")
        cmd.PersistentPreRunE = app.ChainRunEFunctions(cmd.PersistentPreRunE, options.Open, ctx, cmd, a)

        cmd.AddCommand(NewFromFolderCommand(ctx, cmd, a, options))
        cmd.AddCommand(NewFromGooglePhotosCommand(ctx, cmd, a, options))
        cmd.AddCommand(NewFromImmichCommand(ctx, cmd, a, options))
        return cmd
}</span>

func (options *UploadOptions) Open(ctx context.Context, cmd *cobra.Command, app *app.Application) error <span class="cov0" title="0">{
        // Initialize the Journal
        if app.Jnl() == nil </span><span class="cov0" title="0">{
                app.SetJnl(fileevent.NewRecorder(app.Log().Logger))
        }</span>
        <span class="cov0" title="0">app.SetTZ(time.Local)
        if tz, err := cmd.Flags().GetString("time-zone"); err == nil &amp;&amp; tz != "" </span><span class="cov0" title="0">{
                if loc, err := time.LoadLocation(tz); err == nil </span><span class="cov0" title="0">{
                        app.SetTZ(loc)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package app

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "runtime"
        "strings"
        "time"

        "github.com/phsym/console-slog"
        slogmulti "github.com/samber/slog-multi"
        "github.com/simulot/immich-go/internal/configuration"
        "github.com/simulot/immich-go/internal/fshelper/debugfiles"
        "github.com/simulot/immich-go/internal/loghelper"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "github.com/spf13/viper"
)

type Log struct {
        *slog.Logger // Logger

        Type  string // Log format : text|json
        File  string // Log file name
        Level string // Indicate the log level (string)

        sLevel slog.Level // the log level value

        mainWriter    io.Writer // the log writer to file
        consoleWriter io.Writer
}

func AddLogFlags(ctx context.Context, cmd *cobra.Command, app *Application) <span class="cov0" title="0">{
        log := app.Log()
        cmd.PersistentFlags().StringVar(&amp;log.Level, "log-level", "INFO", "Log level (DEBUG|INFO|WARN|ERROR), default INFO")
        cmd.PersistentFlags().StringVarP(&amp;log.File, "log-file", "l", "", "Write log messages into the file")
        cmd.PersistentFlags().StringVar(&amp;log.Type, "log-type", "text", "Log formatted  as text of JSON file")

        cmd.PersistentPreRunE = ChainRunEFunctions(cmd.PersistentPreRunE, log.Open, ctx, cmd, app)
        cmd.PersistentPostRunE = ChainRunEFunctions(cmd.PersistentPostRunE, log.Close, ctx, cmd, app)
}</span>

func (log *Log) OpenLogFile() error <span class="cov0" title="0">{
        var w io.WriteCloser

        if log.File == "" </span><span class="cov0" title="0">{
                log.File = configuration.DefaultLogFile()
        }</span>
        <span class="cov0" title="0">if log.File != "" </span><span class="cov0" title="0">{
                if log.mainWriter == nil </span><span class="cov0" title="0">{
                        err := configuration.MakeDirForFile(log.File)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">w, err = os.OpenFile(log.File, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o664)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">err = log.sLevel.UnmarshalText([]byte(strings.ToUpper(log.Level)))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">log.Message("Log file: %s", log.File)</span>
                }
        } else<span class="cov0" title="0"> {
                w = os.Stdout
        }</span>
        <span class="cov0" title="0">log.setHandlers(w, nil)
        loghelper.SetGlobalLogger(log.Logger)
        return nil</span>
}

func (log *Log) Open(ctx context.Context, cmd *cobra.Command, app *Application) error <span class="cov0" title="0">{
        if cmd.Name() == "version" </span><span class="cov0" title="0">{
                // No log for version command
                return nil
        }</span>
        <span class="cov0" title="0">fmt.Println(Banner())
        err := log.OpenLogFile()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // List flags
        <span class="cov0" title="0">log.Info(GetVersion())
        log.Info("Running environment:", "architecture", runtime.GOARCH, "os", runtime.GOOS)

        cmdStack := []string{cmd.Name()}
        for c := cmd.Parent(); c != nil; c = c.Parent() </span><span class="cov0" title="0">{
                cmdStack = append([]string{c.Name()}, cmdStack...)
        }</span>

        <span class="cov0" title="0">log.Info(fmt.Sprintf("Command: %s", strings.Join(cmdStack, " ")))
        log.Info("Flags:")
        cmd.Flags().VisitAll(func(flag *pflag.Flag) </span><span class="cov0" title="0">{
                val := flag.Value.String()
                if val == "" </span><span class="cov0" title="0">{
                        if v := viper.GetString(flag.Name); v != "" </span><span class="cov0" title="0">{
                                val = v
                        }</span>
                }
                <span class="cov0" title="0">if strings.Contains(flag.Name, "api-key") &amp;&amp; len(val) &gt; 4 </span><span class="cov0" title="0">{
                        val = strings.Repeat("*", len(val)-4) + val[len(val)-4:]
                }</span>
                <span class="cov0" title="0">log.Info("", "--"+flag.Name, val)</span>
        })

        // List arguments
        <span class="cov0" title="0">log.Info("Arguments:")
        for _, arg := range cmd.Flags().Args() </span><span class="cov0" title="0">{
                log.Info(fmt.Sprintf("  %q", arg))
        }</span>
        <span class="cov0" title="0">if log.sLevel == slog.LevelDebug </span><span class="cov0" title="0">{
                debugfiles.EnableTrackFiles(log.Logger)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

/*
func replaceAttr(groups []string, a slog.Attr) slog.Attr {
        if a.Key == slog.LevelKey {
                level := a.Value.Any().(slog.Level)
                a.Value = slog.StringValue(fmt.Sprintf("%-7s", level.String()))
        }
        return a
}
*/

func (log *Log) setHandlers(file, con io.Writer) <span class="cov0" title="0">{
        handlers := []slog.Handler{}

        log.mainWriter = file
        if log.Type == "JSON" </span><span class="cov0" title="0">{
                handlers = append(handlers, slog.NewJSONHandler(log.mainWriter, &amp;slog.HandlerOptions{
                        Level: log.sLevel,
                }))
        }</span> else<span class="cov0" title="0"> {
                handlers = append(handlers, console.NewHandler(log.mainWriter, &amp;console.HandlerOptions{
                        // ReplaceAttr: replaceAttr,
                        Level:      log.sLevel,
                        TimeFormat: time.DateTime,
                        NoColor:    true,
                        Theme:      console.NewDefaultTheme(),
                }))
        }</span>

        <span class="cov0" title="0">log.consoleWriter = con
        if log.consoleWriter != nil </span><span class="cov0" title="0">{
                handlers = append(handlers, console.NewHandler(log.consoleWriter, &amp;console.HandlerOptions{
                        // ReplaceAttr: replaceAttr,
                        Level:      log.sLevel,
                        TimeFormat: time.DateTime,
                        NoColor:    false,
                        Theme:      console.NewDefaultTheme(),
                }))
        }</span>

        <span class="cov0" title="0">log.Logger = slog.New(slogmulti.Fanout(handlers...))</span>
}

func (log *Log) SetLogWriter(w io.Writer) *slog.Logger <span class="cov0" title="0">{
        log.setHandlers(log.mainWriter, w)
        return log.Logger
}</span>

func (log *Log) Message(msg string, values ...any) <span class="cov0" title="0">{
        s := fmt.Sprintf(msg, values...)
        fmt.Println(s)
        if log.Logger != nil </span><span class="cov0" title="0">{
                log.Info(s)
        }</span>
}

func (log *Log) Close(ctx context.Context, cmd *cobra.Command, app *Application) error <span class="cov0" title="0">{
        if cmd.Name() == "version" </span><span class="cov0" title="0">{
                // No log for version command
                return nil
        }</span>
        <span class="cov0" title="0">debugfiles.ReportTrackedFiles()
        if log.File != "" </span><span class="cov0" title="0">{
                log.Message("Check the log file: %s", log.File)
        }</span>
        <span class="cov0" title="0">if closer, ok := log.mainWriter.(io.Closer); ok </span><span class="cov0" title="0">{
                return closer.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (log *Log) GetSLog() *slog.Logger <span class="cov0" title="0">{
        return log.Logger
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package app

import (
        "context"
        "fmt"
        "runtime/debug"
        "strings"

        "github.com/spf13/cobra"
)

var (
        Version = "dev"
        Commit  = "none"
        Date    = "unknown"
)

// initialize version and commit at the runtime
func init() <span class="cov0" title="0">{
        dirty := false
        buildvcs := false

        buildinfo, _ := debug.ReadBuildInfo()
        for _, s := range buildinfo.Settings </span><span class="cov0" title="0">{
                switch s.Key </span>{
                case "vcs.revision":<span class="cov0" title="0">
                        buildvcs = true
                        Commit = s.Value</span>
                case "vcs.modified":<span class="cov0" title="0">
                        if s.Value == "true" </span><span class="cov0" title="0">{
                                dirty = true
                        }</span>
                case "vcs.time":<span class="cov0" title="0">
                        Date = s.Value</span>
                }
        }
        <span class="cov0" title="0">if buildvcs &amp;&amp; dirty </span><span class="cov0" title="0">{
                Commit += "-dirty"
        }</span>
}

// Banner Ascii art
// Generator : http://patorjk.com/software/taag-v1/
// Font: Three point

var _banner = []string{
        ". _ _  _ _ . _|_     _  _ ",
        "|| | || | ||(_| |  (_|(_)",
        "                     _)   ",
}

// String generate a string with new lines and place the given text on the latest line
func Banner() string <span class="cov0" title="0">{
        const lenVersion = 20
        var text string
        if Version != "" </span><span class="cov0" title="0">{
                text = fmt.Sprintf("v %s", Version)
        }</span>
        <span class="cov0" title="0">sb := strings.Builder{}
        for i := range _banner </span><span class="cov0" title="0">{
                if i == len(_banner)-1 &amp;&amp; text != "" </span><span class="cov0" title="0">{
                        if len(text) &gt;= lenVersion </span><span class="cov0" title="0">{
                                text = text[:lenVersion]
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(_banner[i][:lenVersion-len(text)] + text + _banner[i][lenVersion:])</span>
                } else<span class="cov0" title="0"> {
                        sb.WriteString(_banner[i])
                }</span>
                <span class="cov0" title="0">sb.WriteRune('\n')</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}

func GetVersion() string <span class="cov0" title="0">{
        return fmt.Sprintf("immich-go version:%s,  commit:%s, date:%s", Version, Commit, Date)
}</span>

// NewUploadCommand adds the Upload command
func NewVersionCommand(ctx context.Context, app *Application) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Give immich-go version",
        }

        cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                fmt.Println(GetVersion())
                return nil
        }</span>
        <span class="cov0" title="0">return cmd</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package coverageTester

import (
        "bufio"
        "os"
)

func WriteUniqueLine(input string) error <span class="cov0" title="0">{
        filename := "/Users/manszellman/Desktop/kth/soffan/immich-go/coverageBranch.txt"
        file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                if scanner.Text() == input </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file, err = os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        _, err = file.WriteString(input + "\n")
        return err</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package immich

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/simulot/immich-go/internal/assets"
)

type AlbumSimplified struct {
        ID          string `json:"id,omitempty"`
        AlbumName   string `json:"albumName"`
        Description string `json:"description,omitempty"`
        // OwnerID                    string    `json:"ownerId"`
        // CreatedAt                  time.Time `json:"createdAt"`
        // UpdatedAt                  time.Time `json:"updatedAt"`
        // AlbumThumbnailAssetID      string    `json:"albumThumbnailAssetId"`
        // SharedUsers                []string  `json:"sharedUsers"`
        // Owner                      User      `json:"owner"`
        // Shared                     bool      `json:"shared"`
        // AssetCount                 int       `json:"assetCount"`
        // LastModifiedAssetTimestamp time.Time `json:"lastModifiedAssetTimestamp"
        AssetIds []string `json:"assetIds,omitempty"`
}

func AlbumsFromAlbumSimplified(albums []AlbumSimplified) []assets.Album <span class="cov0" title="0">{
        result := make([]assets.Album, 0, len(albums))
        for _, a := range albums </span><span class="cov0" title="0">{
                result = append(result, assets.Album{
                        ID:          a.ID,
                        Title:       a.AlbumName,
                        Description: a.Description,
                })
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (ic *ImmichClient) GetAllAlbums(ctx context.Context) ([]assets.Album, error) <span class="cov0" title="0">{
        var albums []AlbumSimplified
        err := ic.newServerCall(ctx, EndPointGetAllAlbums).
                do(
                        getRequest("/albums", setAcceptJSON()),
                        responseJSON(&amp;albums),
                )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return AlbumsFromAlbumSimplified(albums), nil</span>
}

type AlbumContent struct {
        ID string `json:"id,omitempty"`
        // OwnerID                    string    `json:"ownerId"`
        AlbumName   string   `json:"albumName"`
        Description string   `json:"description"`
        Shared      bool     `json:"shared"`
        Assets      []*Asset `json:"assets,omitempty"`
        AssetIDs    []string `json:"assetIds,omitempty"`
        // CreatedAt                  time.Time `json:"createdAt"`
        // UpdatedAt                  time.Time `json:"updatedAt"`
        // AlbumThumbnailAssetID      string    `json:"albumThumbnailAssetId"`
        // SharedUsers                []string  `json:"sharedUsers"`
        // Owner                      User      `json:"owner"`
        // AssetCount                 int       `json:"assetCount"`
        // LastModifiedAssetTimestamp time.Time `json:"lastModifiedAssetTimestamp"
}

// immich Asset simplified
type AssetSimplified struct {
        ID            string `json:"id"`
        DeviceAssetID string `json:"deviceAssetId"`
        // // OwnerID          string `json:"ownerId"`
        // DeviceID         string `json:"deviceId"`
        // Type             string `json:"type"`
        // OriginalPath     string `json:"originalPath"`
        // OriginalFileName string `json:"originalFileName"`
        // // Resized          bool      `json:"resized"`
        // // Thumbhash        string    `json:"thumbhash"`
        // FileCreatedAt time.Time `json:"fileCreatedAt"`
        // // FileModifiedAt time.Time `json:"fileModifiedAt"`
        // UpdatedAt time.Time `json:"updatedAt"`
        // // IsFavorite     bool      `json:"isFavorite"`
        // // IsArchived     bool      `json:"isArchived"`
        // // Duration       string    `json:"duration"`
        // // ExifInfo ExifInfo `json:"exifInfo"`
        // // LivePhotoVideoID any    `json:"livePhotoVideoId"`
        // // Tags             []any  `json:"tags"`
        // Checksum     string `json:"checksum"`
        // JustUploaded bool   `json:"-"`
}

func (ic *ImmichClient) GetAlbumInfo(ctx context.Context, id string, withoutAssets bool) (AlbumContent, error) <span class="cov0" title="0">{
        var album AlbumContent
        query := id
        if withoutAssets </span><span class="cov0" title="0">{
                query += "?withoutAssets=true"
        }</span> else<span class="cov0" title="0"> {
                query += "?withoutAssets=false"
        }</span>
        <span class="cov0" title="0">err := ic.newServerCall(ctx, EndPointGetAlbumInfo).do(getRequest("/albums/"+query, setAcceptJSON()), responseJSON(&amp;album))
        return album, err</span>
}

func (ic *ImmichClient) GetAssetsAlbums(ctx context.Context, id string) ([]assets.Album, error) <span class="cov0" title="0">{
        var albums []AlbumSimplified
        err := ic.newServerCall(ctx, EndPointGetAlbumInfo).do(getRequest("/albums", setAcceptJSON()), responseJSON(&amp;albums))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return AlbumsFromAlbumSimplified(albums), nil</span>
}

type UpdateAlbum struct {
        IDS []string `json:"ids"`
}

type UpdateAlbumResult struct {
        ID      string `json:"id"`
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
}

func (ic *ImmichClient) AddAssetToAlbum(ctx context.Context, albumID string, assets []string) ([]UpdateAlbumResult, error) <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return []UpdateAlbumResult{}, nil
        }</span>
        <span class="cov0" title="0">var r []UpdateAlbumResult
        body := UpdateAlbum{
                IDS: assets,
        }
        err := ic.newServerCall(ctx, EndPointAddAsstToAlbum).do(
                putRequest(fmt.Sprintf("/albums/%s/assets", albumID), setAcceptJSON(),
                        setJSONBody(body)),
                responseJSON(&amp;r))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func (ic *ImmichClient) CreateAlbum(ctx context.Context, name string, description string, assetsIDs []string) (assets.Album, error) <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return assets.Album{
                        ID:    uuid.NewString(),
                        Title: name,
                }, nil
        }</span>
        <span class="cov0" title="0">body := AlbumContent{
                AlbumName:   name,
                Description: description,
                AssetIDs:    assetsIDs,
        }
        var r AlbumSimplified
        err := ic.newServerCall(ctx, EndPointCreateAlbum).do(
                postRequest("/albums", "application/json", setAcceptJSON(), setJSONBody(body)),
                responseJSON(&amp;r))
        if err != nil </span><span class="cov0" title="0">{
                return assets.Album{}, err
        }</span>
        <span class="cov0" title="0">return assets.Album{
                ID:          r.ID,
                Title:       r.AlbumName,
                Description: r.Description,
        }, nil</span>
}

func (ic *ImmichClient) GetAssetAlbums(ctx context.Context, assetID string) ([]assets.Album, error) <span class="cov0" title="0">{
        var r []AlbumSimplified
        err := ic.newServerCall(ctx, EndPointGetAssetAlbums).do(
                getRequest("/albums?assetId="+assetID, setAcceptJSON()),
                responseJSON(&amp;r))
        return AlbumsFromAlbumSimplified(r), err
}</span>

func (ic *ImmichClient) DeleteAlbum(ctx context.Context, id string) error <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return ic.newServerCall(ctx, EndPointDeleteAlbum).do(deleteRequest("/albums/" + id))</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package immich

import (
        "context"
        "fmt"
        "io"
        "net/url"
        "time"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/fshelper"
)

// immich Asset simplified
type Asset struct {
        ID               string            `json:"id"`
        DeviceAssetID    string            `json:"deviceAssetId"`
        OwnerID          string            `json:"ownerId"`
        DeviceID         string            `json:"deviceId"`
        Type             string            `json:"type"`
        OriginalPath     string            `json:"originalPath"`
        OriginalFileName string            `json:"originalFileName"`
        Resized          bool              `json:"resized"`
        Thumbhash        string            `json:"thumbhash"`
        FileCreatedAt    ImmichTime        `json:"fileCreatedAt"`
        FileModifiedAt   ImmichTime        `json:"fileModifiedAt"`
        UpdatedAt        ImmichTime        `json:"updatedAt"`
        IsFavorite       bool              `json:"isFavorite"`
        IsArchived       bool              `json:"isArchived"`
        IsTrashed        bool              `json:"isTrashed"`
        Duration         string            `json:"duration"`
        Rating           int               `json:"rating"`
        ExifInfo         ExifInfo          `json:"exifInfo"`
        LivePhotoVideoID string            `json:"livePhotoVideoId"`
        Checksum         string            `json:"checksum"`
        StackParentID    string            `json:"stackParentId"`
        Albums           []AlbumSimplified `json:"-"` // Albums that asset belong to
        Tags             []TagSimplified   `json:"tags"`
        // JustUploaded     bool              `json:"-"` // TO REMOVE
}

// NewAssetFromImmich creates an assets.Asset from an immich.Asset.
func (ia Asset) AsAsset() *assets.Asset <span class="cov0" title="0">{
        a := &amp;assets.Asset{
                FileDate:         ia.FileModifiedAt.Time,
                Description:      ia.ExifInfo.Description,
                OriginalFileName: ia.OriginalFileName,
                ID:               ia.ID,
                CaptureDate:      ia.ExifInfo.DateTimeOriginal.Time,
                Trashed:          ia.IsTrashed,
                Archived:         ia.IsArchived,
                Favorite:         ia.IsFavorite,
                Rating:           ia.Rating,
                Latitude:         ia.ExifInfo.Latitude,
                Longitude:        ia.ExifInfo.Longitude,
                File:             fshelper.FSName(nil, ia.OriginalFileName),
        }
        a.FileSize = int(ia.ExifInfo.FileSizeInByte)
        for _, album := range ia.Albums </span><span class="cov0" title="0">{
                a.Albums = append(a.Albums, assets.Album{
                        Title:       album.AlbumName,
                        Description: album.Description,
                })
        }</span>

        <span class="cov0" title="0">for _, tag := range ia.Tags </span><span class="cov0" title="0">{
                a.Tags = append(a.Tags, tag.AsTag())
        }</span>
        <span class="cov0" title="0">return a</span>
}

type ExifInfo struct {
        Make             string         `json:"make"`
        Model            string         `json:"model"`
        ExifImageWidth   int            `json:"exifImageWidth"`
        ExifImageHeight  int            `json:"exifImageHeight"`
        FileSizeInByte   int64          `json:"fileSizeInByte"`
        Orientation      string         `json:"orientation"`
        DateTimeOriginal ImmichExifTime `json:"dateTimeOriginal,omitempty"`
        //         ModifyDate       time.Time `json:"modifyDate"`
        TimeZone string `json:"timeZone"`
        // LensModel        string    `json:"lensModel"`
        //         FNumber          float64   `json:"fNumber"`
        //         FocalLength      float64   `json:"focalLength"`
        //         Iso              int       `json:"iso"`
        //         ExposureTime     string    `json:"exposureTime"`
        Latitude  float64 `json:"latitude,omitempty"`
        Longitude float64 `json:"longitude,omitempty"`
        //         City             string    `json:"city"`
        //         State            string    `json:"state"`
        //         Country          string    `json:"country"`
        Description string `json:"description"`
}

type AssetResponse struct {
        ID     string `json:"id"`
        Status string `json:"status"`
}

const (
        UploadCreated   = "created"
        UploadReplaced  = "replaced"
        UploadDuplicate = "duplicate"
)

func formatDuration(duration time.Duration) string <span class="cov0" title="0">{
        hours := duration / time.Hour
        duration -= hours * time.Hour

        minutes := duration / time.Minute
        duration -= minutes * time.Minute

        seconds := duration / time.Second
        duration -= seconds * time.Second

        milliseconds := duration / time.Millisecond

        return fmt.Sprintf("%02d:%02d:%02d.%06d", hours, minutes, seconds, milliseconds)
}</span>

func (ic *ImmichClient) AssetUpload(ctx context.Context, la *assets.Asset) (AssetResponse, error) <span class="cov0" title="0">{
        return ic.uploadAsset(ctx, la, EndPointAssetUpload, "")
}</span>

func (ic *ImmichClient) ReplaceAsset(ctx context.Context, ID string, la *assets.Asset) (AssetResponse, error) <span class="cov0" title="0">{
        return ic.uploadAsset(ctx, la, EndPointAssetReplace, ID)
}</span>

type GetAssetOptions struct {
        UserID        string
        IsFavorite    bool
        IsArchived    bool
        WithoutThumbs bool
        Skip          string
}

func (o *GetAssetOptions) Values() url.Values <span class="cov0" title="0">{
        if o == nil </span><span class="cov0" title="0">{
                return url.Values{}
        }</span>
        <span class="cov0" title="0">v := url.Values{}
        v.Add("userId", o.UserID)
        v.Add("isFavorite", myBool(o.IsFavorite).String())
        v.Add("isArchived", myBool(o.IsArchived).String())
        v.Add("withoutThumbs", myBool(o.WithoutThumbs).String())
        v.Add("skip", o.Skip)
        return v</span>
}

func (ic *ImmichClient) DeleteAssets(ctx context.Context, id []string, forceDelete bool) error <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">req := struct {
                Force bool     `json:"force"`
                IDs   []string `json:"ids"`
        }{
                IDs:   id,
                Force: forceDelete,
        }

        return ic.newServerCall(ctx, "DeleteAsset").do(deleteRequest("/assets", setJSONBody(&amp;req)))</span>
}

func (ic *ImmichClient) GetAssetInfo(ctx context.Context, id string) (*Asset, error) <span class="cov0" title="0">{
        r := Asset{}
        err := ic.newServerCall(ctx, "GetAssetInfo").do(getRequest("/assets/"+id, setAcceptJSON()), responseJSON(&amp;r))
        return &amp;r, err
}</span>

func (ic *ImmichClient) UpdateAssets(ctx context.Context, ids []string,
        isArchived bool, isFavorite bool,
        latitude float64, longitude float64,
        removeParent bool, stackParentID string,
) error <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">type updAssets struct {
                IDs           []string `json:"ids"`
                IsArchived    bool     `json:"isArchived"`
                IsFavorite    bool     `json:"isFavorite"`
                Latitude      float64  `json:"latitude"`
                Longitude     float64  `json:"longitude"`
                RemoveParent  bool     `json:"removeParent"`
                StackParentID string   `json:"stackParentId,omitempty"`
        }

        param := updAssets{
                IDs:           ids,
                IsArchived:    isArchived,
                IsFavorite:    isFavorite,
                Latitude:      latitude,
                Longitude:     longitude,
                RemoveParent:  removeParent,
                StackParentID: stackParentID,
        }
        return ic.newServerCall(ctx, "updateAssets").do(putRequest("/assets", setJSONBody(param)))</span>
}

// UpdAssetField is used to update asset with fields given in the struct fields
type UpdAssetField struct {
        IsArchived       bool      `json:"isArchived"`
        IsFavorite       bool      `json:"isFavorite"`
        Latitude         float64   `json:"latitude,omitempty"`
        Longitude        float64   `json:"longitude,omitempty"`
        Description      string    `json:"description,omitempty"`
        Rating           int       `json:"rating,omitempty"`
        LivePhotoVideoID string    `json:"livePhotoVideoId,omitempty"`
        DateTimeOriginal time.Time `json:"dateTimeOriginal,omitempty"`
}

func (ic *ImmichClient) UpdateAsset(ctx context.Context, id string, param UpdAssetField) (*Asset, error) <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">r := Asset{}
        err := ic.newServerCall(ctx, "updateAsset").do(putRequest("/assets/"+id, setJSONBody(param)), responseJSON(&amp;r))
        return &amp;r, err</span>
}

func (ic *ImmichClient) DownloadAsset(ctx context.Context, id string) (io.ReadCloser, error) <span class="cov8" title="1">{
        var rc io.ReadCloser

        err := ic.newServerCall(ctx, "DownloadAsset").do(getRequest(fmt.Sprintf("/assets/%s/original", id), setOctetStream()), responseOctetStream(&amp;rc))
        return rc, err
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package immich

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync/atomic"
        "time"

        "github.com/simulot/immich-go/internal/fshelper"
)

const (
        EndPointGetJobs                = "GetJobs"
        EndPointSendJobCommand         = "SendJobCommand"
        EndPointCreateJob              = "CreateJob"
        EndPointGetAllAlbums           = "GetAllAlbums"
        EndPointGetAlbumInfo           = "GetAlbumInfo"
        EndPointAddAsstToAlbum         = "AddAssetToAlbum"
        EndPointCreateAlbum            = "CreateAlbum"
        EndPointGetAssetAlbums         = "GetAssetAlbums"
        EndPointDeleteAlbum            = "DeleteAlbum"
        EndPointPingServer             = "PingServer"
        EndPointValidateConnection     = "ValidateConnection"
        EndPointGetServerStatistics    = "GetServerStatistics"
        EndPointGetAssetStatistics     = "GetAssetStatistics"
        EndPointGetSupportedMediaTypes = "GetSupportedMediaTypes"
        EndPointGetAllAssets           = "GetAllAssets"
        EndPointUpsertTags             = "UpsertTags"
        EndPointTagAssets              = "TagAssets"
        EndPointBulkTagAssets          = "BulkTagAssets"
        EndPointGetAllTags             = "GetAllTags"
        EndPointAssetUpload            = "AssetUpload"
        EndPointAssetReplace           = "AssetReplace"
)

type TooManyInternalError struct {
        error
}

func (e TooManyInternalError) Is(target error) bool <span class="cov0" title="0">{
        _, ok := target.(*TooManyInternalError)
        return ok
}</span>

// serverCall permit to decorate request and responses in one line
type serverCall struct {
        endPoint string
        ic       *ImmichClient
        err      error
        ctx      context.Context
}

// callError represents errors returned by the server
type callError struct {
        endPoint string
        method   string
        url      string
        status   int
        err      error
        message  *ServerErrorMessage
}

type ServerErrorMessage struct {
        Error         string `json:"error"`
        StatusCode    int    `json:"statusCode"`
        Message       string `json:"message"`
        CorrelationID string `json:"correlationId"`
}

func (ce callError) Is(target error) bool <span class="cov0" title="0">{
        _, ok := target.(*callError)
        return ok
}</span>

func (ce callError) Error() string <span class="cov8" title="1">{
        b := strings.Builder{}
        b.WriteString(ce.endPoint)
        b.WriteString(", ")
        b.WriteString(ce.method)
        b.WriteString(", ")
        b.WriteString(ce.url)
        if ce.status &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString(", ")
                b.WriteString(fmt.Sprintf("%d %s", ce.status, http.StatusText(ce.status)))
        }</span>
        <span class="cov8" title="1">b.WriteRune('\n')
        if ce.err != nil &amp;&amp; !errors.Is(ce.err, &amp;callError{}) </span><span class="cov8" title="1">{
                b.WriteString(ce.err.Error())
                b.WriteRune('\n')
        }</span>

        <span class="cov8" title="1">if ce.message != nil </span><span class="cov8" title="1">{
                b.WriteString(ce.message.Message)
                b.WriteRune('\n')
        }</span>

        <span class="cov8" title="1">return b.String()</span>
}

func (ic *ImmichClient) newServerCall(ctx context.Context, api string) *serverCall <span class="cov8" title="1">{
        sc := &amp;serverCall{
                endPoint: api,
                ic:       ic,
                ctx:      ctx,
        }
        return sc
}</span>

func (sc *serverCall) Err(req *http.Request, resp *http.Response, msg *ServerErrorMessage) error <span class="cov8" title="1">{
        ce := callError{
                endPoint: sc.endPoint,
                err:      sc.err,
        }
        if req != nil </span><span class="cov8" title="1">{
                ce.method = req.Method
                ce.url = req.URL.String()
        }</span>
        <span class="cov8" title="1">if resp != nil </span><span class="cov8" title="1">{
                ce.status = resp.StatusCode
        }</span>
        <span class="cov8" title="1">ce.message = msg
        return ce</span>
}

func (sc *serverCall) joinError(err error) error <span class="cov8" title="1">{
        sc.err = errors.Join(sc.err, err)
        return err
}</span>

type requestFunction func(sc *serverCall) *http.Request

var callSequence atomic.Int64

const ctxCallSequenceID = "api-call-sequence"

func (sc *serverCall) request(
        method string,
        url string,
        opts ...serverRequestOption,
) *http.Request <span class="cov8" title="1">{
        if sc.ic.apiTraceWriter != nil &amp;&amp; sc.endPoint != EndPointGetJobs </span><span class="cov0" title="0">{
                seq := callSequence.Add(1)
                sc.ctx = context.WithValue(sc.ctx, ctxCallSequenceID, seq)
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(sc.ctx, method, url, http.NoBody)
        if sc.joinError(err) != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">opts = append(opts, setAPIKey())
        for _, opt := range opts </span><span class="cov8" title="1">{
                if sc.joinError(opt(sc, req)) != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return req</span>
}

func getRequest(url string, opts ...serverRequestOption) requestFunction <span class="cov8" title="1">{
        return func(sc *serverCall) *http.Request </span><span class="cov8" title="1">{
                if sc.err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return sc.request(http.MethodGet, sc.ic.endPoint+url, opts...)</span>
        }
}

func postRequest(url string, cType string, opts ...serverRequestOption) requestFunction <span class="cov8" title="1">{
        return func(sc *serverCall) *http.Request </span><span class="cov8" title="1">{
                if sc.err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return sc.request(
                        http.MethodPost,
                        sc.ic.endPoint+url,
                        append(opts, setContentType(cType))...)</span>
        }
}

func deleteRequest(url string, opts ...serverRequestOption) requestFunction <span class="cov0" title="0">{
        return func(sc *serverCall) *http.Request </span><span class="cov0" title="0">{
                if sc.err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return sc.request(http.MethodDelete, sc.ic.endPoint+url, opts...)</span>
        }
}

func putRequest(url string, opts ...serverRequestOption) requestFunction <span class="cov0" title="0">{
        return func(sc *serverCall) *http.Request </span><span class="cov0" title="0">{
                if sc.err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return sc.request(http.MethodPut, sc.ic.endPoint+url, opts...)</span>
        }
}

func (sc *serverCall) do(fnRequest requestFunction, opts ...serverResponseOption) error <span class="cov8" title="1">{
        var (
                resp *http.Response
                err  error
        )

        req := fnRequest(sc)
        if sc.err != nil || req == nil </span><span class="cov8" title="1">{
                return sc.Err(req, nil, nil)
        }</span>

        <span class="cov8" title="1">if sc.ic.apiTraceWriter != nil &amp;&amp; sc.endPoint != EndPointGetJobs </span><span class="cov0" title="0">{
                _ = sc.joinError(setTraceRequest()(sc, req))
        }</span>

        <span class="cov8" title="1">resp, err = sc.ic.client.Do(req)
        // any non nil error must be returned
        if err != nil </span><span class="cov0" title="0">{
                _ = sc.joinError(err)
                return sc.Err(req, nil, nil)
        }</span>

        // Any StatusCode above 300 denotes a problem
        <span class="cov8" title="1">if resp.StatusCode &gt;= 300 </span><span class="cov8" title="1">{
                msg := ServerErrorMessage{}
                if resp.Body != nil </span><span class="cov8" title="1">{
                        defer resp.Body.Close()
                        b := bytes.NewBuffer(nil)
                        _, _ = io.Copy(b, resp.Body)
                        if json.NewDecoder(b).Decode(&amp;msg) == nil </span><span class="cov0" title="0">{
                                if sc.ic.apiTraceWriter != nil &amp;&amp; sc.endPoint != EndPointGetJobs </span><span class="cov0" title="0">{
                                        seq := sc.ctx.Value(ctxCallSequenceID)
                                        fmt.Fprintln(
                                                sc.ic.apiTraceWriter,
                                                time.Now().Format(time.RFC3339),
                                                "RESPONSE",
                                                seq,
                                                sc.endPoint,
                                                resp.Request.Method,
                                                resp.Request.URL.String(),
                                        )
                                        fmt.Fprintln(sc.ic.apiTraceWriter, "  Status:", resp.Status)
                                        fmt.Fprintln(sc.ic.apiTraceWriter, "-- response body --")
                                        dec := json.NewEncoder(newLimitWriter(sc.ic.apiTraceWriter, 100))
                                        dec.SetIndent("", " ")
                                        if err := dec.Encode(msg); err != nil </span>{<span class="cov0" title="0">
                                                // return sc.Err(req, resp, &amp;msg)
                                        }</span>
                                        <span class="cov0" title="0">fmt.Fprint(sc.ic.apiTraceWriter, "-- response body end --\n\n")</span>
                                }
                                <span class="cov0" title="0">return sc.Err(req, resp, &amp;msg)</span>
                        } else<span class="cov8" title="1"> {
                                if sc.ic.apiTraceWriter != nil &amp;&amp; sc.endPoint != EndPointGetJobs </span><span class="cov0" title="0">{
                                        seq := sc.ctx.Value(ctxCallSequenceID)
                                        fmt.Fprintln(
                                                sc.ic.apiTraceWriter,
                                                time.Now().Format(time.RFC3339),
                                                "RESPONSE",
                                                seq,
                                                sc.endPoint,
                                                resp.Request.Method,
                                                resp.Request.URL.String(),
                                        )
                                        fmt.Fprintln(sc.ic.apiTraceWriter, "  Status:", resp.Status)
                                        fmt.Fprintln(sc.ic.apiTraceWriter, "-- response body --")
                                        fmt.Fprintln(sc.ic.apiTraceWriter, b.String())
                                        fmt.Fprint(sc.ic.apiTraceWriter, "-- response body end --\n\n")
                                }</span>
                        }
                }
                <span class="cov8" title="1">return sc.Err(req, resp, &amp;msg)</span>
        }

        // We have a success
        <span class="cov8" title="1">for _, opt := range opts </span><span class="cov8" title="1">{
                _ = sc.joinError(opt(sc, resp))
        }</span>
        <span class="cov8" title="1">if sc.err != nil </span><span class="cov0" title="0">{
                return sc.Err(req, resp, nil)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type serverRequestOption func(sc *serverCall, req *http.Request) error

func setBody(body io.ReadCloser) serverRequestOption <span class="cov0" title="0">{
        return func(sc *serverCall, req *http.Request) error </span><span class="cov0" title="0">{
                req.Body = body
                return nil
        }</span>
}

func setAcceptJSON() serverRequestOption <span class="cov8" title="1">{
        return func(sc *serverCall, req *http.Request) error </span><span class="cov8" title="1">{
                req.Header.Add("Accept", "application/json")
                return nil
        }</span>
}

func setOctetStream() serverRequestOption <span class="cov8" title="1">{
        return func(sc *serverCall, req *http.Request) error </span><span class="cov8" title="1">{
                req.Header.Add("Accept", "application/octet-stream")
                return nil
        }</span>
}

func setAPIKey() serverRequestOption <span class="cov8" title="1">{
        return func(sc *serverCall, req *http.Request) error </span><span class="cov8" title="1">{
                req.Header.Set("x-api-key", sc.ic.key)
                return nil
        }</span>
}

func setJSONBody(object any) serverRequestOption <span class="cov8" title="1">{
        return func(sc *serverCall, req *http.Request) error </span><span class="cov8" title="1">{
                b := bytes.NewBuffer(nil)
                enc := json.NewEncoder(b)
                if sc.ic.apiTraceWriter != nil &amp;&amp; sc.endPoint != EndPointGetJobs </span><span class="cov0" title="0">{
                        enc.SetIndent("", " ")
                }</span>
                <span class="cov8" title="1">err := enc.Encode(object)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">req.Body = io.NopCloser(b)
                req.Header.Set("Content-Type", "application/json")
                return err</span>
        }
}

func setContentType(cType string) serverRequestOption <span class="cov8" title="1">{
        return func(sc *serverCall, req *http.Request) error </span><span class="cov8" title="1">{
                req.Header.Set("Content-Type", cType)
                return nil
        }</span>
}

type serverResponseOption func(sc *serverCall, resp *http.Response) error

func responseJSON[T any](object *T) serverResponseOption <span class="cov8" title="1">{
        return func(sc *serverCall, resp *http.Response) error </span><span class="cov8" title="1">{
                if resp != nil </span><span class="cov8" title="1">{
                        if resp.Body != nil </span><span class="cov8" title="1">{
                                defer resp.Body.Close()
                                if resp.StatusCode == http.StatusNoContent </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov8" title="1">err := json.NewDecoder(resp.Body).Decode(object)
                                if sc.ic.apiTraceWriter != nil &amp;&amp; sc.endPoint != EndPointGetJobs </span><span class="cov0" title="0">{
                                        seq := sc.ctx.Value(ctxCallSequenceID)
                                        fmt.Fprintln(
                                                sc.ic.apiTraceWriter,
                                                time.Now().Format(time.RFC3339),
                                                "RESPONSE",
                                                seq,
                                                sc.endPoint,
                                                resp.Request.Method,
                                                resp.Request.URL.String(),
                                        )
                                        fmt.Fprintln(sc.ic.apiTraceWriter, "  Status:", resp.Status)
                                        fmt.Fprintln(sc.ic.apiTraceWriter, "-- response body --")
                                        dec := json.NewEncoder(newLimitWriter(sc.ic.apiTraceWriter, 100))
                                        dec.SetIndent("", " ")
                                        _ = dec.Encode(object)
                                        fmt.Fprint(sc.ic.apiTraceWriter, "-- response body end --\n\n")
                                }</span>
                                <span class="cov8" title="1">return err</span>
                        }
                }
                <span class="cov0" title="0">return errors.New("can't decode nil response")</span>
        }
}

func responseCopy(buffer *bytes.Buffer) serverResponseOption <span class="cov8" title="1">{
        return func(sc *serverCall, resp *http.Response) error </span><span class="cov8" title="1">{
                if resp != nil </span><span class="cov8" title="1">{
                        if resp.Body != nil </span><span class="cov8" title="1">{
                                newBody := fshelper.TeeReadCloser(resp.Body, buffer)
                                resp.Body = newBody
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}

func responseOctetStream(rc *io.ReadCloser) serverResponseOption <span class="cov8" title="1">{
        return func(sc *serverCall, resp *http.Response) error </span><span class="cov8" title="1">{
                if resp != nil </span><span class="cov8" title="1">{
                        if resp.Body != nil </span><span class="cov8" title="1">{
                                *rc = resp.Body
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package immich

import (
        "crypto/tls"
        "io"
        "net/http"
        "os"
        "time"

        "github.com/simulot/immich-go/internal/filetypes"
)

/*
ImmichClient is a proxy for immich services

Immich API documentation https://documentation.immich.app/docs/api/introduction
*/

type ImmichClient struct {
        client              *http.Client
        roundTripper        *http.Transport
        endPoint            string                   // Server API url
        key                 string                   // User KEY
        DeviceUUID          string                   // Device
        Retries             int                      // Number of attempts on 500 errors
        RetriesDelay        time.Duration            // Duration between retries
        apiTraceWriter      io.Writer                // If not nil, logs API calls to this writer
        supportedMediaTypes filetypes.SupportedMedia // Server's list of supported medias
        dryRun              bool                     //  If true, do not send any data to the server
}

func (ic *ImmichClient) SetEndPoint(endPoint string) <span class="cov0" title="0">{
        ic.endPoint = endPoint
}</span>

func (ic *ImmichClient) GetEndPoint() string <span class="cov0" title="0">{
        return ic.endPoint
}</span>

func (ic *ImmichClient) SetDeviceUUID(deviceUUID string) <span class="cov0" title="0">{
        ic.DeviceUUID = deviceUUID
}</span>

func (ic *ImmichClient) EnableAppTrace(w io.Writer) <span class="cov0" title="0">{
        ic.apiTraceWriter = w
}</span>

func (ic *ImmichClient) SupportedMedia() filetypes.SupportedMedia <span class="cov0" title="0">{
        return ic.supportedMediaTypes
}</span>

type clientOption func(ic *ImmichClient) error

func OptionVerifySSL(verify bool) clientOption <span class="cov0" title="0">{
        return func(ic *ImmichClient) error </span><span class="cov0" title="0">{
                ic.roundTripper.TLSClientConfig.InsecureSkipVerify = verify
                return nil
        }</span>
}

func OptionConnectionTimeout(d time.Duration) clientOption <span class="cov0" title="0">{
        return func(ic *ImmichClient) error </span><span class="cov0" title="0">{
                ic.client.Timeout = d
                return nil
        }</span>
}

func OptionDryRun(dryRun bool) clientOption <span class="cov0" title="0">{
        return func(ic *ImmichClient) error </span><span class="cov0" title="0">{
                ic.dryRun = dryRun
                return nil
        }</span>
}

// Create a new ImmichClient
func NewImmichClient(endPoint string, key string, options ...clientOption) (*ImmichClient, error) <span class="cov8" title="1">{
        var err error
        deviceUUID, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create a custom HTTP client with SSL verification disabled
        // Add timeouts for #219
        // Info at https://www.loginradius.com/blog/engineering/tune-the-go-http-client-for-high-performance/
        // https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/
        // ![image](https://blog.cloudflare.com/content/images/2016/06/Timeouts-002.png)

        <span class="cov8" title="1">ic := ImmichClient{
                endPoint: endPoint + "/api",
                roundTripper: &amp;http.Transport{
                        MaxIdleConns:        100,
                        IdleConnTimeout:     90 * time.Second,
                        TLSClientConfig:     &amp;tls.Config{InsecureSkipVerify: true},
                        MaxIdleConnsPerHost: 100,
                        MaxConnsPerHost:     100,
                },
                key:          key,
                DeviceUUID:   deviceUUID,
                Retries:      1,
                RetriesDelay: time.Second * 1,
        }

        ic.client = &amp;http.Client{
                Timeout:   time.Second * 60,
                Transport: ic.roundTripper,
        }

        for _, fn := range options </span><span class="cov0" title="0">{
                err := fn(&amp;ic)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return &amp;ic, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package immich

import (
        "context"
        "encoding/json"
        "io"
        "time"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/filetypes"
)

var _ ImmichInterface = (*ImmichClient)(nil)

// ImmichInterface is an interface that implements the minimal immich client set of features for uploading
// interface used to mock up the client
type ImmichInterface interface {
        ImmichAssetInterface
        ImmichClientInterface
        ImmichAlbumInterface
        ImmichTagInterface
        ImmichStackInterface
        ImmichJobInterface
}

type ImmichAssetInterface interface {
        GetAssetInfo(ctx context.Context, id string) (*Asset, error)
        DownloadAsset(ctx context.Context, id string) (io.ReadCloser, error)
        UpdateAsset(ctx context.Context, id string, param UpdAssetField) (*Asset, error)
        ReplaceAsset(ctx context.Context, ID string, la *assets.Asset) (AssetResponse, error)
        GetAllAssets(ctx context.Context) ([]*Asset, error)
        AddAssetToAlbum(context.Context, string, []string) ([]UpdateAlbumResult, error)
        UpdateAssets(
                ctx context.Context,
                IDs []string,
                isArchived bool,
                isFavorite bool,
                latitude float64,
                longitude float64,
                removeParent bool,
                stackParentID string,
        ) error
        GetAllAssetsWithFilter(context.Context, *SearchMetadataQuery, func(*Asset) error) error
        GetAssetsByHash(ctx context.Context, hash string) ([]*Asset, error)
        GetAssetsByImageName(ctx context.Context, name string) ([]*Asset, error)

        AssetUpload(context.Context, *assets.Asset) (AssetResponse, error)
        DeleteAssets(context.Context, []string, bool) error
}

type ImmichClientInterface interface {
        SetEndPoint(string)
        EnableAppTrace(w io.Writer)
        SetDeviceUUID(string)
        PingServer(ctx context.Context) error
        ValidateConnection(ctx context.Context) (User, error)
        GetServerStatistics(ctx context.Context) (ServerStatistics, error)
        GetAssetStatistics(ctx context.Context) (UserStatistics, error)
        SupportedMedia() filetypes.SupportedMedia
}

type ImmichAlbumInterface interface {
        GetAllAlbums(ctx context.Context) ([]assets.Album, error)
        GetAlbumInfo(ctx context.Context, id string, withoutAssets bool) (AlbumContent, error)
        CreateAlbum(
                ctx context.Context,
                tilte string,
                description string,
                ids []string,
        ) (assets.Album, error)

        // GetAssetAlbums get all albums that an asset belongs to
        GetAssetAlbums(ctx context.Context, assetID string) ([]assets.Album, error)
        DeleteAlbum(ctx context.Context, id string) error
}
type ImmichTagInterface interface {
        GetAllTags(ctx context.Context) ([]TagSimplified, error)
        UpsertTags(ctx context.Context, tags []string) ([]TagSimplified, error)
        TagAssets(
                ctx context.Context,
                tagID string,
                assetIDs []string,
        ) ([]TagAssetsResponse, error)
        BulkTagAssets(
                ctx context.Context,
                tagIDs []string,
                assetIDs []string,
        ) (struct {
                Count int `json:"count"`
        }, error)
}

type ImmichStackInterface interface {
        // CreateStack create a stack with the given assets, the 1st asset is the cover, return the stack ID
        CreateStack(ctx context.Context, ids []string) (string, error)
}

type ImmichJobInterface interface {
        GetJobs(ctx context.Context) (map[string]Job, error)
        SendJobCommand(
                ctx context.Context,
                jobID JobID,
                command JobCommand,
                force bool,
        ) (SendJobCommandResponse, error)
        CreateJob(ctx context.Context, name JobName) error
}

type myBool bool

func (b myBool) String() string <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                return "true"
        }</span>
        <span class="cov0" title="0">return "false"</span>
}

type ImmichTime struct {
        time.Time
}

// ImmichTime.UnmarshalJSON read time from the JSON string.
// The json provides a time UTC, but the server and the images dates are given in local time.
// The get the correct time into the struct, we capture the UTC time and return it in the local zone.
//
// workaround for: error at connection to immich server: cannot parse "+174510-04-28T00:49:44.000Z" as "2006" #28
// capture the error

func (t *ImmichTime) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        var ts time.Time
        if len(b) &lt; 3 </span><span class="cov0" title="0">{
                t.Time = time.Time{}
                return nil
        }</span>
        <span class="cov8" title="1">b = b[1 : len(b)-1]
        ts, err := time.ParseInLocation("2006-01-02T15:04:05.000Z", string(b), time.UTC)
        if err != nil </span><span class="cov8" title="1">{
                t.Time = time.Time{}
                return nil
        }</span>
        <span class="cov8" title="1">t.Time = ts.In(time.Local)
        return nil</span>
}

func (t ImmichTime) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return json.Marshal("")
        }</span>

        <span class="cov0" title="0">return json.Marshal(t.Time.Format("\"" + time.RFC3339 + "\""))</span>
}

type ImmichExifTime struct {
        time.Time
}

// ImmichTime.UnmarshalJSON read time from the JSON string.
// The json provides a time UTC, but the server and the images dates are given in local time.
// The get the correct time into the struct, we capture the UTC time and return it in the local zone.
//
// workaround for: error at connection to immich server: cannot parse "+174510-04-28T00:49:44.000Z" as "2006" #28
// capture the error

func (t *ImmichExifTime) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        var ts time.Time
        if len(b) &lt; 3 </span><span class="cov0" title="0">{
                t.Time = time.Time{}
                return nil
        }</span>
        <span class="cov8" title="1">b = b[1 : len(b)-1]
        var err error
        var pattern string
        str := string(b)

        switch len(b) </span>{
        case 29:<span class="cov8" title="1">
                pattern = "2006-01-02T15:04:05.000+00:00"</span>
        case 25:<span class="cov0" title="0">
                pattern = "2006-01-02T15:04:05+00:00"</span>
        }

        <span class="cov8" title="1">if pattern != "" </span><span class="cov8" title="1">{
                ts, err = time.ParseInLocation(pattern, str, time.UTC)
                if err != nil </span><span class="cov8" title="1">{
                        t.Time = time.Time{}
                        return nil
                }</span>
        }

        <span class="cov8" title="1">t.Time = ts.In(time.Local)
        return nil</span>
}

func (t ImmichExifTime) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return json.Marshal("")
        }</span>

        <span class="cov0" title="0">return json.Marshal(t.Time.Format("\"" + time.RFC3339 + "\""))</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package immich

import "context"

type Job struct {
        JobCounts struct {
                Active    int `json:"active"`
                Completed int `json:"completed"`
                Failed    int `json:"failed"`
                Delayed   int `json:"delayed"`
                Waiting   int `json:"waiting"`
                Paused    int `json:"paused"`
        } `json:"jobCounts"`
        QueueStatus struct {
                IsActive bool `json:"isActive"`
                IsPaused bool `json:"isPaused"`
        } `json:"queueStatus"`
}

type SendJobCommandResponse struct {
        JobCounts struct {
                Active    int `json:"active"`
                Completed int `json:"completed"`
                Delayed   int `json:"delayed"`
                Failed    int `json:"failed"`
                Paused    int `json:"paused"`
                Waiting   int `json:"waiting"`
        } `json:"jobCounts"`
        QueueStatus struct {
                IsActive bool `json:"isActive"`
                IsPause  bool `json:"isPause"`
        }
}

type JobID string

const (
        StorageTemplateMigration JobID = "storageTemplateMigration"
)

type JobCommand string

const (
        Start       JobCommand = "start"
        Pause       JobCommand = "pause"
        Resume      JobCommand = "resume"
        Empty       JobCommand = "empty"
        ClearFailed JobCommand = "clear-failed"
)

type JobName string

const (
        PersonCleanup JobName = "person-cleanup"
        TagCleanup    JobName = "tag-cleanup"
        UserCleanup   JobName = "user-cleanup"
)

func (ic *ImmichClient) GetJobs(ctx context.Context) (map[string]Job, error) <span class="cov0" title="0">{
        var resp map[string]Job
        err := ic.newServerCall(ctx, EndPointGetJobs).
                do(getRequest("/jobs", setAcceptJSON()), responseJSON(&amp;resp))
        return resp, err
}</span>

func (ic *ImmichClient) SendJobCommand(
        ctx context.Context,
        jobID JobID,
        command JobCommand,
        force bool,
) (resp SendJobCommandResponse, err error) <span class="cov0" title="0">{
        err = ic.newServerCall(ctx, EndPointSendJobCommand).do(putRequest("/jobs/"+string(jobID),
                setJSONBody(struct {
                        Command JobCommand `json:"command"`
                        Force   bool       `json:"force"`
                }{Command: command, Force: force})), responseJSON(&amp;resp))
        return
}</span>

func (ic *ImmichClient) CreateJob(ctx context.Context, name JobName) error <span class="cov0" title="0">{
        return ic.newServerCall(ctx, EndPointCreateJob).do(postRequest("/jobs",
                "application/json",
                setJSONBody(struct {
                        Name JobName `json:"name"`
                }{Name: name})))
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package immich

type UnsupportedMedia struct {
        msg string
}

func (u UnsupportedMedia) Error() string <span class="cov0" title="0">{
        return u.msg
}</span>

func (u UnsupportedMedia) Is(target error) bool <span class="cov0" title="0">{
        _, ok := target.(*UnsupportedMedia)
        return ok
}</span>

func (ic *ImmichClient) TypeFromExt(ext string) string <span class="cov0" title="0">{
        return ic.supportedMediaTypes.TypeFromExt(ext)
}</span>

func (ic *ImmichClient) IsExtensionPrefix(ext string) bool <span class="cov0" title="0">{
        return ic.supportedMediaTypes.IsExtensionPrefix(ext)
}</span>

func (ic *ImmichClient) IsIgnoredExt(ext string) bool <span class="cov0" title="0">{
        return ic.supportedMediaTypes.IsIgnoredExt(ext)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package immich

import (
        "context"
)

type searchMetadataResponse struct {
        Assets struct {
                Total    int      `json:"total"`
                Count    int      `json:"count"`
                Items    []*Asset `json:"items"`
                NextPage int      `json:"nextPage,string"`
        }
}

type SearchMetadataQuery struct {
        // pagination
        Page int `json:"page"`
        Size int `json:"size,omitempty"`

        // filters
        WithExif         bool   `json:"withExif,omitempty"`
        IsVisible        bool   `json:"isVisible,omitempty"` // For motion stuff you need to pass isVisible=true to hide the motion ones (dijrasm91  https://discord.com/channels/979116623879368755/1178366369423700080/1201206313699508295)
        WithDeleted      bool   `json:"withDeleted,omitempty"`
        WithArchived     bool   `json:"withArchived,omitempty"`
        TakenBefore      string `json:"takenBefore,omitempty"`
        TakenAfter       string `json:"takenAfter,omitempty"`
        Model            string `json:"model,omitempty"`
        Make             string `json:"make,omitempty"`
        Checksum         string `json:"checksum,omitempty"`
        OriginalFileName string `json:"originalFileName,omitempty"`
}

func (ic *ImmichClient) callSearchMetadata(ctx context.Context, query *SearchMetadataQuery, filter func(*Asset) error) error <span class="cov0" title="0">{
        query.Page = 1
        query.Size = 1000
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        resp := searchMetadataResponse{}
                        err := ic.newServerCall(ctx, EndPointGetAllAssets).do(postRequest("/search/metadata", "application/json", setJSONBody(&amp;query), setAcceptJSON()), responseJSON(&amp;resp))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">for _, a := range resp.Assets.Items </span><span class="cov0" title="0">{
                                err = filter(a)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov0" title="0">if resp.Assets.NextPage == 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">query.Page = resp.Assets.NextPage</span>
                }
        }
}

func (ic *ImmichClient) GetAllAssets(ctx context.Context) ([]*Asset, error) <span class="cov0" title="0">{
        var assets []*Asset

        req := SearchMetadataQuery{Page: 1, WithExif: true, IsVisible: true, WithDeleted: true}
        err := ic.callSearchMetadata(ctx, &amp;req, func(asset *Asset) error </span><span class="cov0" title="0">{
                assets = append(assets, asset)
                return nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return assets, nil</span>
}

func (ic *ImmichClient) GetAllAssetsWithFilter(ctx context.Context, query *SearchMetadataQuery, filter func(*Asset) error) error <span class="cov0" title="0">{
        if query == nil </span><span class="cov0" title="0">{
                query = &amp;SearchMetadataQuery{Page: 1, WithExif: true, IsVisible: true, WithDeleted: true}
        }</span>
        <span class="cov0" title="0">query.Page = 1
        return ic.callSearchMetadata(ctx, query, filter)</span>
}

// GetAssetByHash returns the asset with the given hash
// The hash is the base64 encoded sha1 of the file
func (ic *ImmichClient) GetAssetsByHash(ctx context.Context, hash string) ([]*Asset, error) <span class="cov0" title="0">{
        query := SearchMetadataQuery{Page: 1, WithExif: true, IsVisible: true, WithDeleted: true, Checksum: hash}
        query.Page = 1
        list := []*Asset{}
        filter := func(asset *Asset) error </span><span class="cov0" title="0">{
                if asset.Checksum == hash </span><span class="cov0" title="0">{
                        list = append(list, asset)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">err := ic.callSearchMetadata(ctx, &amp;query, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return list, nil</span>
}

// GetAssetByHash returns the asset with the given hash
// The hash is the base64 encoded sha1 of the file
func (ic *ImmichClient) GetAssetsByImageName(ctx context.Context, name string) ([]*Asset, error) <span class="cov0" title="0">{
        query := SearchMetadataQuery{Page: 1, WithExif: true, IsVisible: true, WithDeleted: true, OriginalFileName: name}
        query.Page = 1
        list := []*Asset{}
        filter := func(asset *Asset) error </span><span class="cov0" title="0">{
                if asset.OriginalFileName == name </span><span class="cov0" title="0">{
                        list = append(list, asset)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">err := ic.callSearchMetadata(ctx, &amp;query, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return list, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package immich

import (
        "bytes"
        "context"
        "fmt"

        "github.com/simulot/immich-go/internal/filetypes"
)

type PingResponse struct {
        Res string `json:"res"`
}

// Ping server
func (ic *ImmichClient) PingServer(ctx context.Context) error <span class="cov8" title="1">{
        r := PingResponse{}
        b := bytes.NewBuffer(nil)
        err := ic.newServerCall(ctx, EndPointPingServer).do(getRequest("/server/ping", setAcceptJSON()), responseCopy(b), responseJSON(&amp;r))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected response to the immich's ping API at this address: %s:\n%s", ic.endPoint+"/server/ping", b.String())
        }</span>
        <span class="cov8" title="1">if r.Res != "pong" </span><span class="cov0" title="0">{
                return fmt.Errorf("incorrect ping response: %s", r.Res)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateConnection
// Validate the connection by querying the identity of the user having the given key

func (ic *ImmichClient) ValidateConnection(ctx context.Context) (User, error) <span class="cov8" title="1">{
        var user User

        err := ic.newServerCall(ctx, EndPointValidateConnection).
                do(getRequest("/users/me", setAcceptJSON()), responseJSON(&amp;user))
        if err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>

        <span class="cov8" title="1">sm, err := ic.GetSupportedMediaTypes(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>
        <span class="cov8" title="1">ic.supportedMediaTypes = sm
        return user, nil</span>
}

type ServerStatistics struct {
        Photos      int   `json:"photos"`
        Videos      int   `json:"videos"`
        Usage       int64 `json:"usage"`
        UsageByUser []struct {
                UserID           string `json:"userId"`
                UserName         string `json:"userName"`
                Photos           int    `json:"photos"`
                Videos           int    `json:"videos"`
                Usage            int64  `json:"usage"`
                QuotaSizeInBytes any    `json:"quotaSizeInBytes"`
        } `json:"usageByUser"`
}

// getServerStatistics
// Get server stats

func (ic *ImmichClient) GetServerStatistics(ctx context.Context) (ServerStatistics, error) <span class="cov8" title="1">{
        var s ServerStatistics

        err := ic.newServerCall(ctx, EndPointGetServerStatistics).do(getRequest("/server/statistics", setAcceptJSON()), responseJSON(&amp;s))
        return s, err
}</span>

// getAssetStatistics
// Get user's stats

type UserStatistics struct {
        Images int `json:"images"`
        Videos int `json:"videos"`
        Total  int `json:"total"`
}

func (ic *ImmichClient) GetAssetStatistics(ctx context.Context) (UserStatistics, error) <span class="cov8" title="1">{
        var s UserStatistics
        err := ic.newServerCall(ctx, EndPointGetAssetStatistics).do(getRequest("/assets/statistics", setAcceptJSON()), responseJSON(&amp;s))
        return s, err
}</span>

func (ic *ImmichClient) GetSupportedMediaTypes(ctx context.Context) (filetypes.SupportedMedia, error) <span class="cov8" title="1">{
        var s map[string][]string

        err := ic.newServerCall(ctx, EndPointGetSupportedMediaTypes).do(getRequest("/server/media-types", setAcceptJSON()), responseJSON(&amp;s))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sm := make(filetypes.SupportedMedia)
        for t, l := range s </span><span class="cov8" title="1">{
                for _, e := range l </span><span class="cov8" title="1">{
                        sm[e] = t
                }</span>
        }
        <span class="cov8" title="1">sm[".mp"] = filetypes.TypeUseless
        sm[".json"] = filetypes.TypeSidecar
        return sm, err</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package immich

import (
        "context"

        "github.com/google/uuid"
)

// CreateStack create a stack with the given assets, the 1st asset is the cover, return the stack ID
func (ic *ImmichClient) CreateStack(ctx context.Context, ids []string) (string, error) <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return uuid.NewString(), nil
        }</span>

        <span class="cov0" title="0">param := struct {
                AssetIds []string `json:"assetIds"`
        }{
                AssetIds: ids,
        }

        var result struct {
                ID             string `json:"id"`
                PrimaryAssetID string `json:"primaryAssetId"`
        }

        err := ic.newServerCall(ctx, "createStack").do(postRequest("/stacks", "application/json", setAcceptJSON(), setJSONBody(param)), responseJSON(&amp;result))
        return result.ID, err</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package immich

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/simulot/immich-go/internal/assets"
)

type TagSimplified struct {
        ID    string `json:"id"`
        Name  string `json:"name"`
        Value string `json:"value"`
}

func (ts TagSimplified) AsTag() assets.Tag <span class="cov0" title="0">{
        return assets.Tag{
                ID:    ts.ID,
                Name:  ts.Name,
                Value: ts.Value,
        }
}</span>

type TagAssetsResponse struct {
        Error   string `json:"error,omitempty"` // [duplicate, no_permission, not_found, unknown]
        ID      string `json:"id"`
        Success bool   `json:"success"`
}

func (ic *ImmichClient) UpsertTags(ctx context.Context, tags []string) ([]TagSimplified, error) <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                resp := make([]TagSimplified, len(tags))
                for i, t := range tags </span><span class="cov0" title="0">{
                        resp[i] = TagSimplified{
                                ID:    uuid.NewString(),
                                Name:  t,
                                Value: t,
                        }
                }</span>
                <span class="cov0" title="0">return resp, nil</span>
        }
        <span class="cov0" title="0">var resp []TagSimplified
        body := struct {
                Tags []string `json:"tags"`
        }{Tags: tags}
        err := ic.newServerCall(ctx, EndPointUpsertTags).
                do(putRequest("/tags", setJSONBody(body), setAcceptJSON()), responseJSON(&amp;resp))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func (ic *ImmichClient) TagAssets(
        ctx context.Context,
        tagID string,
        assetIDs []string,
) ([]TagAssetsResponse, error) <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                resp := make([]TagAssetsResponse, len(assetIDs))
                for i, a := range assetIDs </span><span class="cov0" title="0">{
                        resp[i] = TagAssetsResponse{
                                ID:      a,
                                Success: true,
                        }
                }</span>
                <span class="cov0" title="0">return resp, nil</span>
        }

        <span class="cov0" title="0">var resp []TagAssetsResponse

        body := struct {
                IDs []string `json:"ids"`
        }{IDs: assetIDs}
        err := ic.newServerCall(ctx, EndPointTagAssets).
                do(putRequest(fmt.Sprintf("/tags/%s/assets", tagID), setJSONBody(body), setAcceptJSON()), responseJSON(&amp;resp))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

func (ic *ImmichClient) BulkTagAssets(
        ctx context.Context,
        tagIDs []string,
        assetIDs []string,
) (struct {
        Count int `json:"count"`
}, error,
) <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return struct {
                        Count int `json:"count"`
                }{Count: len(assetIDs)}, nil
        }</span>

        <span class="cov0" title="0">var resp struct {
                Count int `json:"count"`
        }

        body := struct {
                TagIDs   []string `json:"tagIds"`
                AssetIDs []string `json:"assetIds"`
        }{
                TagIDs:   tagIDs,
                AssetIDs: assetIDs,
        }
        err := ic.newServerCall(ctx, EndPointBulkTagAssets).
                do(putRequest("/tags/assets", setJSONBody(body)), responseJSON(&amp;resp))

        return resp, err</span>
}

func (ic *ImmichClient) GetAllTags(ctx context.Context) ([]TagSimplified, error) <span class="cov0" title="0">{
        var resp []TagSimplified
        err := ic.newServerCall(ctx, EndPointGetAllTags).
                do(getRequest("/tags"), responseJSON(&amp;resp))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package immich

import (
        "bytes"
        "fmt"
        "io"
        "net/http"
        "sort"
        "time"

        "github.com/simulot/immich-go/internal/gen"
)

/*
  To inspect requests or response request, add setTraceJSONRequest or setTraceJSONResponse to the request options

*/

type limitWriter struct {
        W     io.Writer
        Err   error
        Lines int
}

func newLimitWriter(w io.Writer, lines int) *limitWriter <span class="cov0" title="0">{
        return &amp;limitWriter{W: w, Lines: lines, Err: nil}
}</span>

func (lw *limitWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if lw.Lines &lt; 0 </span><span class="cov0" title="0">{
                return 0, lw.Err
        }</span>
        <span class="cov0" title="0">total := 0
        for len(b) &gt; 0 &amp;&amp; lw.Lines &gt;= 0 &amp;&amp; lw.Err == nil </span><span class="cov0" title="0">{
                p := bytes.Index(b, []byte{'\n'})
                var n int
                if p &gt; 0 </span><span class="cov0" title="0">{
                        n, lw.Err = lw.W.Write(b[:p+1])
                        b = b[p+1:]
                        lw.Lines--
                }</span> else<span class="cov0" title="0"> {
                        n, lw.Err = lw.W.Write(b)
                }</span>
                <span class="cov0" title="0">total += n</span>
        }
        <span class="cov0" title="0">if lw.Lines &lt; 0 </span><span class="cov0" title="0">{
                _, _ = lw.W.Write([]byte(".... truncated ....\n"))
        }</span>
        <span class="cov0" title="0">return total, lw.Err</span>
}

func (lw *limitWriter) Close() error <span class="cov0" title="0">{
        if closer, ok := lw.W.(io.Closer); ok </span><span class="cov0" title="0">{
                return closer.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type smartBodyCloser struct {
        r    io.Reader
        body io.ReadCloser
        w    io.Writer
}

func (sb *smartBodyCloser) Close() error <span class="cov0" title="0">{
        fmt.Fprint(sb.w, "-- request body end --\n\n")
        return sb.body.Close()
}</span>

func (sb *smartBodyCloser) Read(b []byte) (int, error) <span class="cov0" title="0">{
        return sb.r.Read(b)
}</span>

func setTraceRequest() serverRequestOption <span class="cov0" title="0">{
        return func(sc *serverCall, req *http.Request) error </span><span class="cov0" title="0">{
                seq := sc.ctx.Value(ctxCallSequenceID)
                fmt.Fprintln(sc.ic.apiTraceWriter, time.Now().Format(time.RFC3339), "QUERY", seq, sc.endPoint, req.Method, req.URL.String())
                for h, v := range req.Header </span><span class="cov0" title="0">{
                        if h == "X-Api-Key" </span><span class="cov0" title="0">{
                                fmt.Fprintln(sc.ic.apiTraceWriter, "  ", h, "redacted")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintln(sc.ic.apiTraceWriter, "  ", h, v)
                        }</span>
                }
                <span class="cov0" title="0">if v := sc.ctx.Value(ctxCallValues); v != nil </span><span class="cov0" title="0">{
                        if values, ok := v.(map[string]string); ok </span><span class="cov0" title="0">{
                                fmt.Fprintln(sc.ic.apiTraceWriter, "  Post values")
                                keys := gen.MapKeys(values)
                                sort.Strings(keys)
                                for _, k := range keys </span><span class="cov0" title="0">{
                                        fmt.Fprintln(sc.ic.apiTraceWriter, "    ", k+": ", values[k])
                                }</span>
                        }
                }
                <span class="cov0" title="0">if req.Header.Get("Content-Type") == "application/json" </span><span class="cov0" title="0">{
                        fmt.Fprintln(sc.ic.apiTraceWriter, "-- request JSON Body --")
                        if req.Body != nil </span><span class="cov0" title="0">{
                                // tr := io.TeeReader(req.Body, newLimitWriter(sc.ic.apiTraceWriter, 100))
                                tr := io.TeeReader(req.Body, sc.ic.apiTraceWriter)
                                req.Body = &amp;smartBodyCloser{body: req.Body, r: tr, w: sc.ic.apiTraceWriter}
                        }</span>
                } else<span class="cov0" title="0"> {
                        if req.Body != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(sc.ic.apiTraceWriter, "-- Empty body or binary body not dumped --")
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package immich

import (
        "context"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "mime/multipart"
        "net/http"
        "path"
        "strings"

        "github.com/google/uuid"
        "github.com/simulot/immich-go/internal/assets"
)

const (
        TimeFormat    = "2006-01-02T15:04:05Z"
        ctxCallValues = "call-values"
)

func setContextValue(kv map[string]string) serverRequestOption <span class="cov0" title="0">{
        return func(sc *serverCall, req *http.Request) error </span><span class="cov0" title="0">{
                if sc.err != nil || kv == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">sc.ctx = context.WithValue(sc.ctx, ctxCallValues, kv)
                return nil</span>
        }
}

func (ic *ImmichClient) uploadAsset(ctx context.Context, la *assets.Asset, endPoint string, replaceID string) (AssetResponse, error) <span class="cov0" title="0">{
        if ic.dryRun </span><span class="cov0" title="0">{
                return AssetResponse{
                        ID:     uuid.NewString(),
                        Status: UploadCreated,
                }, nil
        }</span>

        <span class="cov0" title="0">var ar AssetResponse
        ext := path.Ext(la.OriginalFileName)
        if strings.TrimSuffix(la.OriginalFileName, ext) == "" </span><span class="cov0" title="0">{
                la.OriginalFileName = "No Name" + ext // fix #88, #128
        }</span>
        <span class="cov0" title="0">if strings.ToUpper(ext) == ".MP" </span><span class="cov0" title="0">{
                ext = ".MP4" // #405
                la.OriginalFileName = la.OriginalFileName + ".MP4"
        }</span>

        <span class="cov0" title="0">mtype := ic.TypeFromExt(ext)
        switch mtype </span>{
        case "video", "image":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return ar, fmt.Errorf("type file not supported: %s", path.Ext(la.OriginalFileName))</span>
        }

        <span class="cov0" title="0">f, err := la.OpenFile()
        if err != nil </span><span class="cov0" title="0">{
                return ar, err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        s, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return ar, err
        }</span>

        <span class="cov0" title="0">callValues := ic.prepareCallValues(la, s, ext, mtype)
        body, pw := io.Pipe()
        m := multipart.NewWriter(pw)

        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        m.Close()
                        pw.Close()
                }</span>()

                <span class="cov0" title="0">err = ic.writeMultipartFields(m, callValues)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">err = ic.writeFilePart(m, f, la.OriginalFileName, mtype)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if la.FromSideCar != nil &amp;&amp; strings.HasSuffix(strings.ToLower(la.FromSideCar.File.Name()), ".xmp") </span><span class="cov0" title="0">{
                        err = ic.writeSideCarPart(m, la)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }()

        <span class="cov0" title="0">var errCall error
        switch endPoint </span>{
        case EndPointAssetUpload:<span class="cov0" title="0">
                errCall = ic.newServerCall(ctx, EndPointAssetUpload).
                        do(postRequest("/assets", m.FormDataContentType(), setContextValue(callValues), setAcceptJSON(), setBody(body)), responseJSON(&amp;ar))</span>
        case EndPointAssetReplace:<span class="cov0" title="0">
                errCall = ic.newServerCall(ctx, EndPointAssetReplace).
                        do(putRequest("/assets/"+replaceID+"/original", setContextValue(callValues), setAcceptJSON(), setContentType(m.FormDataContentType()), setBody(body)), responseJSON(&amp;ar))</span>
        }
        <span class="cov0" title="0">err = errors.Join(err, errCall)
        return ar, err</span>
}

func (ic *ImmichClient) prepareCallValues(la *assets.Asset, s fs.FileInfo, ext, mtype string) map[string]string <span class="cov0" title="0">{
        callValues := map[string]string{}
        callValues["deviceAssetId"] = fmt.Sprintf("%s-%d", path.Base(la.OriginalFileName), s.Size())
        callValues["deviceId"] = ic.DeviceUUID
        callValues["assetType"] = mtype
        if !la.CaptureDate.IsZero() </span><span class="cov0" title="0">{
                callValues["fileCreatedAt"] = la.CaptureDate.Format(TimeFormat)
        }</span> else<span class="cov0" title="0"> {
                callValues["fileCreatedAt"] = s.ModTime().Format(TimeFormat)
        }</span>
        <span class="cov0" title="0">callValues["fileModifiedAt"] = s.ModTime().Format(TimeFormat)
        callValues["isFavorite"] = myBool(la.Favorite).String()
        callValues["fileExtension"] = ext
        callValues["duration"] = formatDuration(0)
        callValues["isReadOnly"] = "false"
        callValues["isArchived"] = myBool(la.Archived).String()
        return callValues</span>
}

func (ic *ImmichClient) writeMultipartFields(m *multipart.Writer, callValues map[string]string) error <span class="cov0" title="0">{
        for key, value := range callValues </span><span class="cov0" title="0">{
                err := m.WriteField(key, value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ic *ImmichClient) writeFilePart(m *multipart.Writer, f io.Reader, originalFileName, _ string) error <span class="cov0" title="0">{
        w, err := m.CreateFormFile("assetData", originalFileName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = io.Copy(w, f)
        return err</span>
}

func (ic *ImmichClient) writeSideCarPart(m *multipart.Writer, la *assets.Asset) error <span class="cov0" title="0">{
        scName := path.Base(la.OriginalFileName) + ".xmp"

        w, err := m.CreateFormFile("sidecarData", scName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">scf, err := la.FromSideCar.File.Open()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer scf.Close()
        _, err = io.Copy(w, scf)
        return err</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package assets

import (
        "log/slog"
)

type Album struct {
        ID          string  `json:"-"`                     // The album ID
        Title       string  `json:"title,omitempty"`       // either the directory base name, or metadata
        Description string  `json:"description,omitempty"` // As found in the metadata
        Latitude    float64 `json:"latitude,omitempty"`    // As found in the metadata
        Longitude   float64 `json:"longitude,omitempty"`   // As found in the metadata
}

func (a Album) LogValue() slog.Value <span class="cov0" title="0">{
        return slog.GroupValue(
                slog.String("title", a.Title),
                slog.String("description", a.Description),
                slog.Float64("latitude", a.Latitude),
                slog.Float64("longitude", a.Longitude),
        )
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package assets

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/simulot/immich-go/internal/fshelper/cachereader"
)

/*
        Asset structure hold information on assets used for building immich assets.

        The asset is taken into a fs.FS system which doesn't implement anything else than a strait
        reader.
        fsys can be a zip file, a DirFS, or anything else.

        It implements a way to read a minimal quantity of data to be able to take a decision
        about chose a file or discard it.

        implements fs.File and fs.FileInfo, Stat

*/

type Asset struct {
        // File system and file name
        File     fshelper.FSAndName
        FileDate time.Time // File creation date
        ID       string    // Immich ID after upload

        // Common fields
        OriginalFileName string // File name as delivered to Immich/Google
        Description      string // Google Photos may a have description
        FileSize         int    // File size in bytes

        // Metadata for the process and the upload to Immich
        CaptureDate time.Time // Date of the capture
        Trashed     bool      // The asset is trashed
        Archived    bool      // The asset is archived
        FromPartner bool      // the asset comes from a partner
        Favorite    bool      // the asset is marked as favorite
        Rating      int       // the asset is marked with stars
        Albums      []Album   // List of albums the asset is in
        Tags        []Tag     // List of tags the asset is tagged with

        // Information inferred from the original file name
        NameInfo

        FromSideCar     *Metadata // Metadata extracted from a sidecar file (XMP or JSON)
        FromSourceFile  *Metadata // Metadata extracted from the file content (embedded metadata)
        FromApplication *Metadata // Metadata extracted from the application that created the file

        // GPS location
        Latitude  float64 // GPS latitude
        Longitude float64 // GPS longitude

        // buffer management
        cacheReader *cachereader.CacheReader
}

// Kind is the probable type of the image
type Kind int

const (
        KindNone Kind = iota
        KindBurst
        KindEdited
        KindPortrait
        KindNight
        KindMotion
        KindLongExposure
)

type NameInfo struct {
        Base       string    // base name (with extension)
        Ext        string    // extension
        Radical    string    // base name usable for grouping photos
        Type       string    // type of the asset  video, image
        Kind       Kind      // type of the series
        Index      int       // index of the asset in the series
        Taken      time.Time // date taken
        IsCover    bool      // is this is the cover if the series
        IsModified bool      // is this is a modified version of the original
}

func (a *Asset) SetNameInfo(ni NameInfo) <span class="cov0" title="0">{
        a.NameInfo = ni
}</span>

func (a *Asset) UseMetadata(md *Metadata) *Metadata <span class="cov0" title="0">{
        if md == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">a.Description = md.Description
        a.Latitude = md.Latitude
        a.Longitude = md.Longitude
        a.CaptureDate = md.DateTaken
        a.FromPartner = md.FromPartner
        a.Trashed = md.Trashed
        a.Archived = md.Archived
        a.Favorite = md.Favorited
        a.Rating = int(md.Rating)
        a.MergeAlbums(md.Albums)
        a.MergeTags(md.Tags)
        return md</span>
}

// LogValue returns a slog.Value representing the LocalAssetFile's properties.
func (a Asset) LogValue() slog.Value <span class="cov0" title="0">{
        return slog.GroupValue(
                slog.Any("FileName", a.File),
                slog.Time("FileDate", a.FileDate),
                slog.String("Description", a.Description),
                slog.String("Title", a.OriginalFileName),
                slog.Int("FileSize", a.FileSize),
                slog.String("ID", a.ID),
                slog.Time("CaptureDate", a.CaptureDate),
                slog.Bool("Trashed", a.Trashed),
                slog.Bool("Archived", a.Archived),
                slog.Bool("FromPartner", a.FromPartner),
                slog.Bool("Favorite", a.Favorite),
                slog.Int("Stars", a.Rating),
                slog.String("Latitude", fmt.Sprintf("%.0f.xxxxx", a.Latitude)),
                slog.String("Longitude", fmt.Sprintf("%.0f.xxxxx", a.Longitude)),
        )
}</span>

func (a *Asset) MergeAlbums(a2 []Album) <span class="cov0" title="0">{
        for _, album := range a2 </span><span class="cov0" title="0">{
                found := false
                for _, existingAlbum := range a.Albums </span><span class="cov0" title="0">{
                        if existingAlbum.Title == album.Title </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        a.Albums = append(a.Albums, album)
                }</span>
        }
}

func (a *Asset) MergeTags(t2 []Tag) <span class="cov0" title="0">{
        for _, tag := range t2 </span><span class="cov0" title="0">{
                found := false
                for _, existingTag := range a.Tags </span><span class="cov0" title="0">{
                        if existingTag.Name == tag.Name </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        a.Tags = append(a.Tags, tag)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package assets

import (
        "fmt"

        "github.com/simulot/immich-go/internal/fshelper/cachereader"
        "github.com/simulot/immich-go/internal/fshelper/debugfiles"
        "github.com/simulot/immich-go/internal/fshelper/osfs"
)

func (a *Asset) DeviceAssetID() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%d", a.OriginalFileName, a.FileSize)
}</span>

// OpenFile return an os.File whatever the type of source reader is.
// It can be called several times for the same asset.

func (a *Asset) OpenFile() (osfs.OSFS, error) <span class="cov0" title="0">{
        if a.cacheReader == nil </span><span class="cov0" title="0">{
                // get a FS.File from of the asset
                f, err := a.File.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">debugfiles.TrackOpenFile(f, a.File.FullName())
                // Create a cache reader from the FS.File
                cr, err := cachereader.NewCacheReader(a.File.FullName(), f)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">a.cacheReader = cr</span>
        }
        <span class="cov0" title="0">return a.cacheReader.OpenFile()</span>
}

// Close close the temporary file  and close the source
func (a *Asset) Close() error <span class="cov0" title="0">{
        if a.cacheReader == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return a.cacheReader.Close()</span>
}

/*

// Open return fs.File that reads previously read bytes followed by the actual file content.
func (a *Asset) Open() (fs.File, error) {
        var err error
        if a.sourceFile == nil {
                a.sourceFile, err = a.File.Open()
                if err != nil {
                        return nil, err
                }
        }
        if a.tempFile != nil {
                _, err = a.tempFile.Seek(0, 0)
                if err != nil {
                        return nil, err
                }
                a.reader = io.MultiReader(a.tempFile, a.sourceFile)
        } else {
                a.reader = a.sourceFile
        }
        return a, nil
}

// Read
func (a *Asset) Read(b []byte) (int, error) {
        return a.reader.Read(b)
}

// Close close the temporary file  and close the source
func (a *Asset) Close() error {
        var err error
        if a.sourceFile != nil {
                err = errors.Join(err, a.sourceFile.Close())
                a.sourceFile = nil
        }
        if a.tempFile != nil {
                f := a.tempFile.Name()
                err = errors.Join(err, a.tempFile.Close())
                err = errors.Join(err, os.Remove(f))
                a.tempFile = nil
        }
        return err
}

// Stat implements the fs.FILE interface
func (a *Asset) Stat() (fs.FileInfo, error) {
        return a, nil
}
func (a *Asset) IsDir() bool { return false }

func (a *Asset) Name() string {
        return a.File.Name()
}

func (a *Asset) Size() int64 {
        return int64(a.FileSize)
}

// Mode Implements the fs.FILE interface
func (a *Asset) Mode() fs.FileMode { return 0 }

// ModTime implements the fs.FILE interface
func (a *Asset) ModTime() time.Time {
        s, err := a.File.Stat()
        if err != nil {
                return time.Time{}
        }
        return s.ModTime()
}

// Sys implements the fs.FILE interface
func (a *Asset) Sys() any { return nil }
*/
</pre>
		
		<pre class="file" id="file45" style="display: none">package assets

import (
        "errors"
)

type GroupBy int

const (
        GroupByNone    GroupBy = iota
        GroupByBurst           // Group by burst
        GroupByRawJpg          // Group by raw/jpg
        GroupByHeicJpg         // Group by heic/jpg
        GroupByOther           // Group by other (same radical, not previous cases)
)

type removed struct {
        Asset  *Asset
        Reason string
}

type Group struct {
        Assets     []*Asset
        Removed    []removed
        Grouping   GroupBy
        CoverIndex int // index of the cover assert in the Assets slice
}

// NewGroup create a new asset group
func NewGroup(grouping GroupBy, a ...*Asset) *Group <span class="cov0" title="0">{
        return &amp;Group{
                Grouping: grouping,
                Assets:   a,
        }
}</span>

// AddAsset add an asset to the group
func (g *Group) AddAsset(a *Asset) <span class="cov0" title="0">{
        g.Assets = append(g.Assets, a)
}</span>

// RemoveAsset remove an asset from the group
func (g *Group) RemoveAsset(a *Asset, reason string) <span class="cov0" title="0">{
        for i, asset := range g.Assets </span><span class="cov0" title="0">{
                if asset == a </span><span class="cov0" title="0">{
                        g.Removed = append(g.Removed, removed{Asset: asset, Reason: reason})
                        g.Assets = append(g.Assets[:i], g.Assets[i+1:]...)
                        return
                }</span>
        }
}

// SetCover set the cover asset of the group
func (g *Group) SetCover(i int) *Group <span class="cov0" title="0">{
        g.CoverIndex = i
        return g
}</span>

func (g *Group) Validate() error <span class="cov0" title="0">{
        if g == nil </span><span class="cov0" title="0">{
                return errors.New("nil group")
        }</span>
        <span class="cov0" title="0">if len(g.Assets) == 0 </span><span class="cov0" title="0">{
                return errors.New("empty group")
        }</span>
        // test all asset not nil
        <span class="cov0" title="0">for _, a := range g.Assets </span><span class="cov0" title="0">{
                if a == nil </span><span class="cov0" title="0">{
                        return errors.New("nil asset in group")
                }</span>
        }
        <span class="cov0" title="0">if 0 &gt; g.CoverIndex || g.CoverIndex &gt; len(g.Assets) </span><span class="cov0" title="0">{
                return errors.New("cover index out of range")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package assets

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "path"
        "time"

        "github.com/simulot/immich-go/internal/fshelper"
)

type Metadata struct {
        File        fshelper.FSAndName `json:"-"`                     // File name and file system that holds the metadata. Could be empty
        FileName    string             `json:"fileName,omitempty"`    // File name as presented to users
        Latitude    float64            `json:"latitude,omitempty"`    // GPS
        Longitude   float64            `json:"longitude,omitempty"`   // GPS
        DateTaken   time.Time          `json:"dateTaken,omitempty"`   // Date of exposure
        Description string             `json:"description,omitempty"` // Long description
        Albums      []Album            `json:"albums,omitempty"`      // Used to list albums that contain the file
        Tags        []Tag              `json:"tags,omitempty"`        // Used to list tags
        Rating      byte               `json:"rating,omitempty"`      // 0 to 5
        Trashed     bool               `json:"trashed,omitempty"`     // Flag to indicate if the image has been trashed
        Archived    bool               `json:"archived,omitempty"`    // Flag to indicate if the image has been archived
        Favorited   bool               `json:"favorited,omitempty"`   // Flag to indicate if the image has been favorited
        FromPartner bool               `json:"fromPartner,omitempty"` // Flag to indicate if the image is from a partner
}

func (m Metadata) LogValue() slog.Value <span class="cov0" title="0">{
        var gpsGroup slog.Value
        if m.Latitude != 0 || m.Longitude != 0 </span><span class="cov0" title="0">{
                gpsGroup = slog.GroupValue(
                        slog.String("latitude", fmt.Sprintf("%0.f.xxxx", m.Latitude)),
                        slog.String("longitude", fmt.Sprintf("%0.f.xxxx", m.Longitude)),
                )
        }</span>

        <span class="cov0" title="0">return slog.GroupValue(
                slog.Any("GPS coordinates", gpsGroup),
                slog.Any("fileName", m.File),
                slog.Time("dateTaken", m.DateTaken),
                slog.String("description", m.Description),
                slog.Int("rating", int(m.Rating)),
                slog.Bool("trashed", m.Trashed),
                slog.Bool("archived", m.Archived),
                slog.Bool("favorited", m.Favorited),
                slog.Bool("fromPartner", m.FromPartner),
                slog.Any("albums", m.Albums),
                slog.Any("tags", m.Tags),
        )</span>
}

func (m Metadata) IsSet() bool <span class="cov0" title="0">{
        return m.Description != "" || !m.DateTaken.IsZero() || m.Latitude != 0 || m.Longitude != 0
}</span>

func UnMarshalMetadata(data []byte) (*Metadata, error) <span class="cov0" title="0">{
        var m Metadata
        err := json.Unmarshal(data, &amp;m)
        return &amp;m, err
}</span>

func (m *Metadata) AddTag(tag string) <span class="cov0" title="0">{
        for _, t := range m.Tags </span><span class="cov0" title="0">{
                if t.Value == tag </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">m.Tags = append(m.Tags, Tag{Name: path.Base(tag), Value: tag})</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package assets

import "path"

type Tag struct {
        ID    string `json:"-"`               // Tag ID in immich
        Name  string `json:"-"`               // the leaf name of the tag: subtag
        Value string `json:"value,omitempty"` // the full tag name rootTag/subtag
}

func (t Tag) LogValuer() string <span class="cov0" title="0">{
        return t.Value
}</span>

func (a *Asset) AddTag(tag string) <span class="cov0" title="0">{
        for _, t := range a.Tags </span><span class="cov0" title="0">{
                if t.Value == tag </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">a.Tags = append(a.Tags, Tag{Name: path.Base(tag), Value: tag})</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package bulktags

import (
        "context"
        "log/slog"
        "sync"

        "github.com/simulot/immich-go/immich"
        "github.com/simulot/immich-go/internal/gen/syncmap"
)

const bulkBatchSize = 100

type BulkTagManager struct {
        ctx     context.Context
        client  immich.ImmichTagInterface
        logger  *slog.Logger
        tags    *syncmap.SyncMap[string, []string] // map of tag value to assets
        tagsID  *syncmap.SyncMap[string, string]   // map of tag value to ID
        tagChan chan struct {
                tag     string
                assetID string
        }
        done chan struct{}
        wg   sync.WaitGroup
}

func NewBulkTagManager(ctx context.Context, client immich.ImmichTagInterface, logger *slog.Logger) *BulkTagManager <span class="cov8" title="1">{
        bm := &amp;BulkTagManager{
                ctx:    ctx,
                client: client,
                logger: logger,
                tags:   syncmap.New[string, []string](),
                tagsID: syncmap.New[string, string](),
                tagChan: make(chan struct {
                        tag     string
                        assetID string
                }),
                done: make(chan struct{}),
        }

        go bm.tagWorker()
        return bm
}</span>

func (m *BulkTagManager) AddTag(tag string, assetID string) <span class="cov8" title="1">{
        if len(assetID) == 0 || len(tag) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">m.tagChan &lt;- struct{ tag, assetID string }{tag, assetID}</span>
}

func (m *BulkTagManager) Close() <span class="cov8" title="1">{
        close(m.tagChan)
        &lt;-m.done
}</span>

// tagWorker is a goroutine that listens for tags+ids to be added to the BulkTagManager.
// it protects the tags map from concurrent access.
func (m *BulkTagManager) tagWorker() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case t, ok := &lt;-m.tagChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                m.flush()
                                return
                        }</span>
                        <span class="cov8" title="1">ids, _ := m.tags.Load(t.tag)
                        ids = append(ids, t.assetID)
                        m.tags.Store(t.tag, ids)
                        if len(ids) &gt;= bulkBatchSize </span><span class="cov8" title="1">{
                                m.flushTag(t.tag)
                        }</span>
                }
        }
}

func (m *BulkTagManager) flushTag(tag string) <span class="cov8" title="1">{
        ids, ok := m.tags.Swap(tag, []string{})
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">ID, ok := m.tagsID.Load(tag)
        if !ok </span><span class="cov8" title="1">{
                tags, err := m.client.UpsertTags(m.ctx, []string{tag})
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Error("Error upserting tag", "Tag", tag, "error", err)
                        return
                }</span>
                <span class="cov8" title="1">if len(tags) == 0 || tags[0].ID == "" </span><span class="cov0" title="0">{
                        m.logger.Error("Error upserting tag", "Tag", tag, "error", "no tag ID returned")
                        return
                }</span>
                <span class="cov8" title="1">ID = tags[0].ID
                m.tagsID.Store(tag, ID)</span>
        }
        <span class="cov8" title="1">m.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer m.wg.Done()
                _, err := m.client.BulkTagAssets(m.ctx, []string{ID}, ids)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Error("Error tagging assets with tag", "Tag", tag, "error", err)
                }</span>
        }()
}

func (m *BulkTagManager) flush() <span class="cov8" title="1">{
        for _, tag := range m.tags.Keys() </span><span class="cov8" title="1">{
                m.flushTag(tag)
        }</span>
        <span class="cov8" title="1">m.wg.Wait()
        close(m.done)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package cliflags

import (
        "fmt"
        "strings"
)

type DateMethod string

const (
        DateMethodNone         DateMethod = "NONE"
        DateMethodName         DateMethod = "FILENAME"
        DateMethodEXIF         DateMethod = "EXIF"
        DateMethodNameThenExif DateMethod = "FILENAME-EXIF"
        DateMethodExifThenName DateMethod = "EXIF-FILENAME"
)

func (dm *DateMethod) Set(s string) error <span class="cov0" title="0">{
        s = strings.TrimSpace(strings.ToUpper(s))
        if s == "" </span><span class="cov0" title="0">{
                s = string(DateMethodNone)
        }</span>
        <span class="cov0" title="0">switch DateMethod(s) </span>{
        case DateMethodNone,
                DateMethodEXIF,
                DateMethodNameThenExif,
                DateMethodExifThenName,
                DateMethodName:<span class="cov0" title="0">
                *dm = DateMethod(s)
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid DateMethod: %s, expecting NONE|FILENAME|EXIF|FILENAME-EXIF|EXIF-FILENAME", s)</span>
        }
}

func (dm *DateMethod) Type() string <span class="cov0" title="0">{
        return "DateMethod"
}</span>

func (dm *DateMethod) String() string <span class="cov0" title="0">{
        return string(*dm)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package cliflags

import (
        "fmt"
        "time"
)

// DateRange represent the date range for capture date

type DateRange struct {
        After, Before         time.Time // todo: make After and Before private
        day, month, year, set bool
        tz                    *time.Location
        s                     string
}

// InitDateRange initialize a DateRange with a string (for tests)
func InitDateRange(tz *time.Location, s string) DateRange <span class="cov0" title="0">{
        dr := DateRange{
                tz: tz,
        }
        _ = dr.Set(s)
        return dr
}</span>

// IsSet returns whether the date range is set
func (dr DateRange) IsSet() bool <span class="cov0" title="0">{ return dr.set }</span>

func (dr DateRange) String() string <span class="cov8" title="1">{
        if dr.set </span><span class="cov8" title="1">{
                switch </span>{
                case dr.day:<span class="cov8" title="1">
                        return dr.After.Format("2006-01-02")</span>
                case dr.month:<span class="cov8" title="1">
                        return dr.After.Format("2006-01")</span>
                case dr.year:<span class="cov8" title="1">
                        return dr.After.Format("2006")</span>
                default:<span class="cov8" title="1">
                        return dr.After.Format("2006-01-02") + "," + dr.Before.AddDate(0, 0, -1).Format("2006-01-02")</span>
                }
        } else<span class="cov0" title="0"> {
                return "unset"
        }</span>
}

func (dr *DateRange) SetTZ(tz *time.Location) <span class="cov8" title="1">{
        dr.tz = tz
        if dr.set </span><span class="cov0" title="0">{
                _ = dr.Set(dr.s)
        }</span>
}

// Implements the flags interface
// A day:    2022-01-01
// A month:  2022-01
// A year:   2022
// A range:  2022-01-01,2022-12-31
func (dr *DateRange) Set(s string) (err error) <span class="cov8" title="1">{
        if dr.tz == nil </span><span class="cov0" title="0">{
                dr.tz = time.Local
        }</span>
        <span class="cov8" title="1">switch len(s) </span>{
        case 4:<span class="cov8" title="1">
                dr.year = true
                dr.After, err = time.ParseInLocation("2006", s, dr.tz)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid date range:%w", err)
                }</span>
                <span class="cov8" title="1">dr.Before = dr.After.AddDate(1, 0, 0)</span>
        case 7:<span class="cov8" title="1">
                dr.month = true
                dr.After, err = time.ParseInLocation("2006-01", s, dr.tz)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid date range:%w", err)
                }</span>
                <span class="cov8" title="1">dr.Before = dr.After.AddDate(0, 1, 0)</span>
        case 10:<span class="cov8" title="1">
                dr.day = true
                dr.After, err = time.ParseInLocation("2006-01-02", s, dr.tz)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid date range:%w", err)
                }</span>
                <span class="cov8" title="1">dr.Before = dr.After.AddDate(0, 0, 1)</span>
        case 21:<span class="cov8" title="1">
                dr.After, err = time.ParseInLocation("2006-01-02", s[:10], dr.tz)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid date range:%w", err)
                }</span>
                <span class="cov8" title="1">dr.Before, err = time.ParseInLocation("2006-01-02", s[11:], dr.tz)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid date range:%w", err)
                }</span>
                <span class="cov8" title="1">dr.Before = dr.Before.AddDate(0, 0, 1)</span>
        default:<span class="cov0" title="0">
                dr.set = false
                return fmt.Errorf("invalid date range:%s", s)</span>
        }
        <span class="cov8" title="1">dr.set = true
        dr.s = s
        return nil</span>
}

// InRange checks if a given date is within the range
func (dr DateRange) InRange(d time.Time) bool <span class="cov8" title="1">{
        if !dr.set </span><span class="cov0" title="0">{
                return true
        }</span>
        //        --------------After----------d------------Before
        <span class="cov8" title="1">return (d.Compare(dr.After) &gt;= 0 &amp;&amp; dr.Before.Compare(d) &gt; 0)</span>
}

func (dr DateRange) Type() string <span class="cov0" title="0">{
        return "date-range"
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package cliflags

import (
        "slices"
        "strings"

        "github.com/spf13/cobra"
)

type InclusionFlags struct {
        ExcludedExtensions ExtensionList
        IncludedExtensions ExtensionList
        DateRange          DateRange
}

func AddInclusionFlags(cmd *cobra.Command, flags *InclusionFlags) <span class="cov0" title="0">{
        cmd.Flags().Var(&amp;flags.DateRange, "date-range", "Only import photos taken within the specified date range")
        cmd.Flags().Var(&amp;flags.ExcludedExtensions, "exclude-extensions", "Comma-separated list of extension to exclude. (e.g. .gif,.PM) (default: none)")
        cmd.Flags().Var(&amp;flags.IncludedExtensions, "include-extensions", "Comma-separated list of extension to include. (e.g. .jpg,.heic) (default: all)")
}</span>

// Validate validates the common flags.
func (flags *InclusionFlags) Validate() <span class="cov0" title="0">{
        flags.ExcludedExtensions = flags.ExcludedExtensions.Validate()
        flags.IncludedExtensions = flags.IncludedExtensions.Validate()
}</span>

// An ExtensionList is a list of file extensions, where each extension is a string that starts with a dot (.) and is in lowercase.
type ExtensionList []string

// Validate validates the extension list by converting to lowercase.
func (sl ExtensionList) Validate() ExtensionList <span class="cov0" title="0">{
        vl := ExtensionList{}
        for _, e := range sl </span><span class="cov0" title="0">{
                e = strings.ToLower(strings.TrimSpace(e))
                if !strings.HasPrefix(e, ".") </span><span class="cov0" title="0">{
                        e = "." + e
                }</span>
                <span class="cov0" title="0">vl = append(vl, e)</span>
        }
        <span class="cov0" title="0">return vl</span>
}

// Include checks if the extension list includes a given extension.
func (sl ExtensionList) Include(s string) bool <span class="cov8" title="1">{
        if len(sl) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">s = strings.ToLower(s)
        return slices.Contains(sl, strings.ToLower(s))</span>
}

// Exclude checks if the extension list excludes a given extension.
func (sl ExtensionList) Exclude(s string) bool <span class="cov8" title="1">{
        if len(sl) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">s = strings.ToLower(s)
        return slices.Contains(sl, strings.ToLower(s))</span>
}

// Implements the flag interface
func (sl *ExtensionList) Set(s string) error <span class="cov0" title="0">{
        exts := strings.Split(s, ",")
        for _, ext := range exts </span><span class="cov0" title="0">{
                ext = strings.TrimSpace(ext)
                if ext != "" </span><span class="cov0" title="0">{
                        *sl = append(*sl, ext)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (sl ExtensionList) String() string <span class="cov0" title="0">{
        return strings.Join(sl, ", ")
}</span>

func (sl ExtensionList) Type() string <span class="cov0" title="0">{
        return "ExtensionList"
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package configuration

import (
        "encoding/json"
        "os"
        "path/filepath"
        "time"
)

type Configuration struct {
        APIURL    string `json:",omitempty"`
        ServerURL string `json:",omitempty"`
        APIKey    string
}

// DefaultConfigFile return the default configuration file name
// Return a local file when the default UserHomeDir can't be determined,
func DefaultConfigFile() string <span class="cov0" title="0">{
        config, err := os.UserConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                // $XDG_CONFIG_HOME nor $HOME is set
                // return current
                return "./immich-go.json"
        }</span>
        <span class="cov0" title="0">return filepath.Join(config, "immich-go", "immich-go.json")</span>
}

// ConfigRead the configuration in file name
func ConfigRead(name string) (Configuration, error) <span class="cov0" title="0">{
        f, err := os.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return Configuration{}, err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        var c Configuration
        err = json.NewDecoder(f).Decode(&amp;c)
        if err != nil </span><span class="cov0" title="0">{
                return Configuration{}, err
        }</span>
        <span class="cov0" title="0">return c, nil</span>
}

// Write the configuration in the file name
// Create the needed sub directories as needed
func (c Configuration) Write(name string) error <span class="cov0" title="0">{
        d, _ := filepath.Split(name)
        if d != "" </span><span class="cov0" title="0">{
                err := os.MkdirAll(d, 0o700)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">f, err := os.OpenFile(name, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0o700)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")
        return enc.Encode(c)</span>
}

// DefaultLogDir give the default log file
// Return the current dir when $HOME not $XDG_CACHE_HOME are not set
func DefaultLogFile() string <span class="cov0" title="0">{
        f := time.Now().Format("immich-go_2006-01-02_15-04-05.log")
        d, err := os.UserCacheDir()
        if err != nil </span><span class="cov0" title="0">{
                return f
        }</span>
        <span class="cov0" title="0">return filepath.Join(d, "immich-go", f)</span>
}

// MakeDirForFile create all dirs to write the given file
func MakeDirForFile(f string) error <span class="cov0" title="0">{
        dir := filepath.Dir(f)
        return os.MkdirAll(dir, 0o700)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package docker

/*
        This package implements a connection to a local docker demon running Immich or a distant one through a SSH connection
        It can:
        - run any docker command
        - download a file from a container
        - upload a fil in a container
*/

import (
        "archive/tar"
        "bytes"
        "context"
        "fmt"
        "io"
        "os"
        "path"
        "sync"
        "time"
)

// DockerConnect represent a connection to a docker service
type DockerConnect struct {
        Host      string
        Container string
        proxy     dockerProxy
}

// dockerProxy in the an interface for a docker command runner
type dockerProxy interface {
        connect(context.Context) error
        docker(context.Context, ...string) (cmdAdaptor, error)
}

// cmdAdaptor provide a common interface between exec.Cmd and goph.Cmd
type cmdAdaptor interface {
        // CommandContext( context.Context,string,...string)
        Run() error
        Start() error
        StdoutPipe() (io.ReadCloser, error)
        StdinPipe() (io.WriteCloser, error)
        CombinedOutput() ([]byte, error)
        Wait() error
}

// NewDockerConnection create a connection with a docker service based on host and container parameters
// host:
//         - Leave host empty for a local docker
//  - ssh url  for a remote docker on a machine reachable via ssh
//    - ssh://host to access with your username, and you private key
//    - ssh://root@host to access with root user, and you private key
//    - ssh://user:password@host to access with the user and the password

func NewDockerConnection(ctx context.Context, host string, container string) (*DockerConnect, error) <span class="cov0" title="0">{
        d := DockerConnect{
                Host:      host,
                Container: container,
        }

        err := d.connect(ctx, host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't open docker: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;d, nil</span>
}

// Connect test the connection with docker, and get instance parameters
func (d *DockerConnect) connect(ctx context.Context, host string) error <span class="cov0" title="0">{
        var err error
        if host == "" || host == "local" </span><span class="cov0" title="0">{
                d.proxy = newLocalProxy(d)
        }</span> else<span class="cov0" title="0"> {
                d.proxy, err = newSSHProxy(host)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = d.proxy.connect(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmd, err := d.proxy.docker(ctx, "ps", "--format", "{{.Names}}")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't connect to the local docker: %s", err)
        }</span>

        <span class="cov0" title="0">b, err := cmd.CombinedOutput()
        buf := bytes.NewBuffer(b)
        for </span><span class="cov0" title="0">{
                l, err := buf.ReadString('\n')
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if l[:len(l)-1] == d.Container </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("container 'immich_server' not found: %w", err)</span>
}

// Download a file from the docker container
func (d *DockerConnect) Download(ctx context.Context, hostFile string) (io.Reader, error) <span class="cov0" title="0">{
        cmd, err := d.proxy.docker(ctx, "cp", d.Container+":"+hostFile, "-")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">out, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">pr, pw := io.Pipe()
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        _ = cmd.Wait()
                        pw.Close()
                }</span>()
                <span class="cov0" title="0">tr := tar.NewReader(out)
                for </span><span class="cov0" title="0">{
                        hd, err := tr.Next()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span> // End of archive
                        }
                        <span class="cov0" title="0">_ = hd
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">if _, err := io.Copy(pw, tr); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }()

        <span class="cov0" title="0">err = cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return pr, nil</span>
}

// Upload a file to the docker container
func (d *DockerConnect) Upload(ctx context.Context, file string, size int64, r io.Reader) error <span class="cov0" title="0">{
        cmd, err := d.proxy.docker(ctx, "cp", "-", d.Container+":"+path.Dir(file))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">in, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wg := sync.WaitGroup{}
        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                var err error
                tw := tar.NewWriter(in)
                defer func() </span><span class="cov0" title="0">{
                        tw.Close()
                        in.Close()
                        wg.Done()
                }</span>()
                <span class="cov0" title="0">hdr := tar.Header{
                        Name:    path.Base(file),
                        Mode:    0o644,
                        Size:    size,
                        ModTime: time.Now(),
                }
                err = tw.WriteHeader(&amp;hdr)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">_, err = io.Copy(tw, r)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }()

        <span class="cov0" title="0">err = cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">wg.Wait()
        err = cmd.Wait()

        return err</span>
}

func (d *DockerConnect) BatchUpload(ctx context.Context, dir string) (*batchUploader, error) <span class="cov0" title="0">{
        f := bytes.NewBuffer(nil)

        cmd, err := d.proxy.docker(ctx, "cp", "-", d.Container+":"+dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">out, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                _, _ = io.Copy(os.Stdout, out)
        }</span>()
        <span class="cov0" title="0">in, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">mw := io.MultiWriter(f, in)

        loader := batchUploader{
                fileChannel: make(chan file),
                fileErr:     make(chan error),
        }

        go func() </span><span class="cov0" title="0">{
                var err error
                tw := tar.NewWriter(mw)
                defer func() </span><span class="cov0" title="0">{
                        // f.Close()
                        tw.Close()
                        in.Close()
                        _ = cmd.Wait()
                }</span>()
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case f, isOpen := &lt;-loader.fileChannel:<span class="cov0" title="0">
                                if !isOpen </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">hdr := tar.Header{
                                        Name:    f.name,
                                        Mode:    0o644,
                                        Size:    int64(len(f.content)),
                                        ModTime: time.Now(),
                                }
                                err = tw.WriteHeader(&amp;hdr)
                                if err != nil </span><span class="cov0" title="0">{
                                        loader.fileErr &lt;- err
                                        return
                                }</span>

                                <span class="cov0" title="0">_, err = tw.Write(f.content)
                                if err != nil </span><span class="cov0" title="0">{
                                        loader.fileErr &lt;- err
                                        return
                                }</span>
                                <span class="cov0" title="0">loader.fileErr &lt;- nil</span>
                        }
                }
        }()

        <span class="cov0" title="0">err = cmd.Start()

        return &amp;loader, err</span>
}

type batchUploader struct {
        fileChannel chan file
        fileErr     chan error
}

func (b *batchUploader) Upload(name string, content []byte) error <span class="cov0" title="0">{
        b.fileChannel &lt;- file{
                name:    name,
                content: content,
        }
        err := &lt;-b.fileErr
        return err
}</span>

func (b *batchUploader) Close() error <span class="cov0" title="0">{
        close(b.fileChannel)
        return nil
}</span>

type file struct {
        name    string
        content []byte
}

func (d *DockerConnect) Command(ctx context.Context, args ...string) (string, error) <span class="cov0" title="0">{
        cmd, err := d.proxy.docker(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">buffOut := bytes.NewBuffer(nil)

        out, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                _, _ = io.Copy(buffOut, out)
        }</span>()
        <span class="cov0" title="0">err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return buffOut.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package docker

import (
        "context"
        "os/exec"
)

type localProxy struct {
        c *DockerConnect
}

func newLocalProxy(c *DockerConnect) *localProxy <span class="cov0" title="0">{
        return &amp;localProxy{c: c}
}</span>

func (localProxy) connect(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

func (localProxy) docker(ctx context.Context, args ...string) (cmdAdaptor, error) <span class="cov0" title="0">{
        return exec.CommandContext(ctx, "docker", args...), nil
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package docker

import (
        "context"
        "fmt"
        "io"
        "net/url"
        "os/user"
        "path/filepath"

        "github.com/melbahja/goph"
)

type sshProxy struct {
        sshAuth   goph.Auth
        sshUser   string
        sshHost   string
        sshClient *goph.Client
}

func newSSHProxy(host string) (*sshProxy, error) <span class="cov0" title="0">{
        u, err := url.Parse(host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if u.Scheme != "ssh" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported protocol %s: %s", u.Scheme, host)
        }</span>
        <span class="cov0" title="0">p := sshProxy{}
        p.sshUser = u.User.Username()
        p.sshHost = u.Host
        pass, set := u.User.Password()
        if set </span><span class="cov0" title="0">{
                p.sshAuth = goph.Password(pass)
        }</span> else<span class="cov0" title="0"> {
                var u *user.User
                u, err = user.Current()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if p.sshUser == "" </span><span class="cov0" title="0">{
                        p.sshUser = u.Username
                }</span>
                <span class="cov0" title="0">keyFile := filepath.Join(u.HomeDir, ".ssh", "id_rsa")
                p.sshAuth, err = goph.Key(keyFile, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return &amp;p, nil</span>
}

func (p *sshProxy) connect(ctx context.Context) error <span class="cov0" title="0">{
        var err error
        p.sshClient, err = goph.New(p.sshUser, p.sshHost, p.sshAuth)
        return err
}</span>

func (p *sshProxy) docker(ctx context.Context, args ...string) (cmdAdaptor, error) <span class="cov0" title="0">{
        cmd, err := p.sshClient.CommandContext(ctx, "docker", args...)
        return &amp;sshCmd{Cmd: cmd}, err
}</span>

// sshCmd shim
type sshCmd struct {
        *goph.Cmd
}

func (c *sshCmd) StdoutPipe() (io.ReadCloser, error) <span class="cov0" title="0">{
        r, err := c.Cmd.StdoutPipe()
        return io.NopCloser(r), err
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package e2e

import (
        "context"
        "fmt"
        "os/exec"
        "testing"
        "time"

        "github.com/joho/godotenv"
        "github.com/simulot/immich-go/immich"
)

var myEnv map[string]string

const e2eEnv = "../../../e2e.env"

func InitMyEnv() <span class="cov0" title="0">{
        if len(myEnv) &gt; 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var err error
        e, err := godotenv.Read(e2eEnv)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("cant initialize environment variables: %s", err))</span>
        }
        <span class="cov0" title="0">myEnv = e
        if myEnv["IMMICHGO_TESTFILES"] == "" </span><span class="cov0" title="0">{
                panic("missing IMMICHGO_TESTFILES in .env file")</span>
        }
}

func MyEnv(key string) string <span class="cov0" title="0">{
        if len(myEnv) == 0 </span><span class="cov0" title="0">{
                InitMyEnv()
        }</span>
        <span class="cov0" title="0">return myEnv[key]</span>
}

func ResetImmich(t *testing.T) <span class="cov0" title="0">{
        // Reset immich's database
        // https://github.com/immich-app/immich/blob/main/e2e/src/utils.ts
        //
        c := exec.Command("docker", "exec", "-i", "immich_postgres", "psql", "--dbname=immich", "--username=postgres", "-c",
                `
                DELETE FROM asset_stack CASCADE;
                DELETE FROM libraries CASCADE;
                DELETE FROM shared_links CASCADE;
                DELETE FROM person CASCADE;
                DELETE FROM albums CASCADE;
                DELETE FROM assets CASCADE;
                DELETE FROM asset_faces CASCADE;
                DELETE FROM activity CASCADE;
                --DELETE FROM api_keys CASCADE;
                --DELETE FROM sessions CASCADE;
                --DELETE FROM users CASCADE;
                DELETE FROM "system_metadata" where "key" NOT IN ('reverse-geocoding-state', 'system-flags');
                DELETE FROM tags CASCADE;
                `,
        )
        b, err := c.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                t.Log(string(b))
                t.Fatal(err)
        }</span>
}

func WaitingForJobsEnding(ctx context.Context, client *immich.ImmichClient, t *testing.T) <span class="cov0" title="0">{
        // Waiting for jobs to complete
        ctx, cancel := context.WithDeadline(ctx, time.Now().Add(30*time.Second))
check:
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        t.Fatal("Timeout waiting for metadata job to terminate")</span>
                default:<span class="cov0" title="0">
                        jobs, err := client.GetJobs(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                t.Fatal(err)
                        }</span>
                        <span class="cov0" title="0">if jobs["metadataExtraction"].JobCounts.Active == 0 </span><span class="cov0" title="0">{
                                cancel()
                                break check</span>
                        }
                        <span class="cov0" title="0">fmt.Println("Waiting for metadata extraction to finish")
                        time.Sleep(1 * time.Second)</span>
                }
        }
}

func GetImmichClient() (*immich.ImmichClient, error) <span class="cov0" title="0">{
        return immich.NewImmichClient(
                MyEnv("IMMICHGO_SERVER"),
                MyEnv("IMMICHGO_APIKEY"),
        )
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package main

import (
        "fmt"
        "log/slog"
        "os"
        "time"

        "github.com/simulot/immich-go/internal/exif"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) != 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage: reader &lt;file&gt;")
                return
        }</span>
        <span class="cov0" title="0">err := run(os.Args[1])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
}

func run(file string) error <span class="cov0" title="0">{
        f, err := os.Open(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        m, err := exif.MetadataFromDirectRead(f, file, time.Local)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">slog.Info("Metadata", "m", m)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package exif

/*
        Read metadata from a file not using exiftool.

        TODO: Use sync.Pool for buffers
*/
import (
        "bytes"
        "fmt"
        "io"
        "path"
        "strings"
        "time"

        "github.com/rwcarlsen/goexif/exif"
        "github.com/simulot/immich-go/internal/assets"
)

// MetadataFromDirectRead read the file using GO package
func MetadataFromDirectRead(f io.Reader, name string, localTZ *time.Location) (*assets.Metadata, error) <span class="cov8" title="1">{
        var md *assets.Metadata
        var err error
        ext := strings.ToLower(path.Ext(name))

        switch strings.ToLower(ext) </span>{
        case ".heic", ".heif":<span class="cov0" title="0">
                md, err = readHEIFMetadata(f, localTZ)</span>
        case ".jpg", ".jpeg", ".dng", ".cr2", ".arw", ".raf", ".nef":<span class="cov8" title="1">
                md, err = readExifMetadata(f, localTZ)</span>
        case ".mp4", ".mov":<span class="cov8" title="1">
                md, err = readMP4Metadata(f)</span>
        case ".cr3":<span class="cov0" title="0">
                md, err = readCR3Metadata(f, localTZ)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("can't read metadata for this format '%s'", ext)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't read metadata: %w", err)
        }</span>

        <span class="cov8" title="1">return md, nil</span>
}

// readExifMetadata locate the Exif part and return the date of capture
func readExifMetadata(r io.Reader, localTZ *time.Location) (*assets.Metadata, error) <span class="cov8" title="1">{
        // try to read the Exif data directly
        readBuffer := bytes.NewBuffer(make([]byte, searchBufferSize))
        r2 := io.TeeReader(r, readBuffer)
        x, err := exif.Decode(r2)
        if err == nil || !exif.IsCriticalError(err) </span><span class="cov8" title="1">{
                return getExifMetadata(x, localTZ)
        }</span>
        <span class="cov8" title="1">b := make([]byte, searchBufferSize)

        // search for the Exif header
        r, err = searchPattern(io.MultiReader(readBuffer, r), []byte("Exif\x00\x00"), b)
        if err == nil </span><span class="cov8" title="1">{
                x, err = exif.Decode(r)
                if err == nil || !exif.IsCriticalError(err) </span><span class="cov8" title="1">{
                        return getExifMetadata(x, localTZ)
                }</span>
        }
        <span class="cov0" title="0">return nil, err</span>
}

const searchBufferSize = 32 * 1024

// readHEIFMetadata locate the Exif part and return the date of capture
func readHEIFMetadata(r io.Reader, localTZ *time.Location) (*assets.Metadata, error) <span class="cov0" title="0">{
        b := make([]byte, searchBufferSize)
        r, err := searchPattern(r, []byte{0x45, 0x78, 0x69, 0x66, 0, 0, 0x4d, 0x4d}, b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filler := make([]byte, 6)
        _, err = r.Read(filler)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x, err := exif.Decode(r)
        if err == nil || !exif.IsCriticalError(err) </span><span class="cov0" title="0">{
                return getExifMetadata(x, localTZ)
        }</span>
        <span class="cov0" title="0">return nil, err</span>
}

// readMP4Metadata locate the mvhd atom and decode the date of capture
func readMP4Metadata(r io.Reader) (*assets.Metadata, error) <span class="cov8" title="1">{
        b := make([]byte, searchBufferSize)

        r, err := searchPattern(r, []byte{'m', 'v', 'h', 'd'}, b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">atom, err := decodeMvhdAtom(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">t := atom.CreationTime
        if t.Year() &lt; 2000 </span><span class="cov8" title="1">{
                t = atom.ModificationTime
        }</span>
        <span class="cov8" title="1">return &amp;assets.Metadata{DateTaken: t}, nil</span>
}

// readCR3Metadata locate the CMT1 atom and decode the date of capture
func readCR3Metadata(r io.Reader, localTZ *time.Location) (*assets.Metadata, error) <span class="cov0" title="0">{
        b := make([]byte, searchBufferSize)

        r, err := searchPattern(r, []byte("CMT1"), b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filler := make([]byte, 4)
        _, err = r.Read(filler)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x, err := exif.Decode(r)
        if err == nil || !exif.IsCriticalError(err) </span><span class="cov0" title="0">{
                return getExifMetadata(x, localTZ)
        }</span>
        <span class="cov0" title="0">return nil, err</span>
}

// type exifDumper struct{}

// func (exifDumper) Walk(name exif.FieldName, tag *tiff.Tag) error {
//         fmt.Printf("%s: %s\n", name, tag)
//         return nil
// }

// getExifMetadata extract the date and location from the Exif data

func getExifMetadata(x *exif.Exif, local *time.Location) (*assets.Metadata, error) <span class="cov8" title="1">{
        var err error

        // _ = x.Walk(exifDumper{})

        md := &amp;assets.Metadata{}
        // md.DateTaken, err = readGPSTimeStamp(x, local)
        // if err != nil || md.DateTaken.IsZero() {
        // GPS Time Stamp is not reliable

        md.DateTaken, err = readDateTime(x, exif.DateTimeOriginal, exif.SubSecTimeOriginal, local)
        if err != nil </span><span class="cov0" title="0">{
                md.DateTaken, err = readDateTime(x, exif.DateTime, exif.SubSecTime, local)
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                lat, lon, err := x.LatLong()
                if err == nil </span><span class="cov8" title="1">{
                        md.Latitude = lat
                        md.Longitude = lon
                }</span>
        }
        <span class="cov8" title="1">return md, err</span>
}

// readDateTime with subsecond when possible
func readDateTime(x *exif.Exif, dateTag exif.FieldName, subSecTag exif.FieldName, local *time.Location) (time.Time, error) <span class="cov8" title="1">{
        date, err := getTagSting(x, dateTag)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">subSec, err := getTagSting(x, subSecTag)
        if err == nil </span><span class="cov8" title="1">{
                subSec += "000"
                date = date + "." + subSec[:3]
                return time.ParseInLocation("2006:01:02 15:04:05.000", date, local)
        }</span>
        <span class="cov8" title="1">return time.ParseInLocation("2006:01:02 15:04:05", date, local)</span>
}

/*
// readGPSTimeStamp extract the date from the GPS data

        func readGPSTimeStamp(x *exif.Exif, _ *time.Location) (time.Time, error) {
                tag, err := getTagSting(x, exif.GPSDateStamp)
                if err == nil {
                        var tags *tiff.Tag
                        tags, err = x.Get(exif.GPSTimeStamp)
                        if err == nil {
                                tag = tag + " " + fmt.Sprintf("%02d:%02d:%02dZ", ratToInt(tags, 0), ratToInt(tags, 1), ratToInt(tags, 2))
                                t, err := time.ParseInLocation("2006:01:02 15:04:05Z", tag, time.UTC)
                                if err == nil {
                                        return t, nil
                                }
                        }
                }
                return time.Time{}, err
        }

        func ratToInt(t *tiff.Tag, i int) int {
                n, d, err := t.Rat2(i)
                if err != nil {
                        return 0
                }
                if d == 1 {
                        return int(n)
                }
                return int(float64(n) / float64(d))
        }
*/

func getTagSting(x *exif.Exif, tagName exif.FieldName) (string, error) <span class="cov8" title="1">{
        t, err := x.Get(tagName)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">s := strings.TrimRight(strings.TrimLeft(t.String(), `"`), `"`)
        return s, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package exif

import (
        "io"
        "time"

        "github.com/simulot/immich-go/internal/assets"
)

// GetMetaData read metadata from the asset file to  enrich the metadata structure
func GetMetaData(r io.Reader, name string, local *time.Location) (*assets.Metadata, error) <span class="cov0" title="0">{
        return MetadataFromDirectRead(r, name, local)
}</span>

// MetadataFromExiftool call exiftool to get exif data
// func MetadataFromExiftool(f io.Reader, name string, options ExifToolFlags) (*assets.Metadata, error) {
//         // be sure the file is completely extracted in the temp file
//         _, err := io.Copy(io.Discard, f)
//         if err != nil {
//                 return nil, err
//         }

//         return options.et.ReadMetaData(name)
// }
</pre>
		
		<pre class="file" id="file60" style="display: none">package exif

import (
        "encoding/binary"
        "io"
        "time"
)

/*
The mvhd atom contains metadata and information about the entire movie or presentation, such as its duration,
time scale, preferred playback rate, and more.

Here are some of the main attributes found in the mvhd atom:

- Timescale: This value indicates the time scale for the media presentation,
   which represents the number of time units per second. It allows for accurate timing of media content in the file.

- Duration: The duration is the total time the movie or presentation lasts,
        expressed in the time scale units defined in the file.

-  Preferred Rate: The preferred rate is the intended playback rate for the movie.
        It can be used to set the default playback speed when the media is played.

- Preferred Volume: The preferred volume specifies the default audio volume for the media playback.

- Matrix Structure: The mvhd atom may contain a matrix structure
                that defines transformations to be applied when rendering the video content, such as scaling or rotation.

-  Creation and Modification Time: The mvhd atom also stores the creation time and modification time
        of the movie or presentation.

In total, the minimum size of the mvhd atom is 108 bytes (version 0) or 112 bytes (version 1).
If any of the optional fields are present, the size of the atom would increase accordingly.
*/

type MvhdAtom struct {
        Marker           []byte // 4 bytes
        Version          uint8
        Flags            []byte // 3 bytes
        CreationTime     time.Time
        ModificationTime time.Time
        // ignored fields:
        // Timescale        uint32
        // Duration         uint32
        // Rate             float32
        // Volume           float32
        // Matrix           [9]int32
        // NextTrackID      uint32
}

func decodeMvhdAtom(rf io.Reader) (*MvhdAtom, error) <span class="cov8" title="1">{
        r := newSliceReader(rf)
        a := &amp;MvhdAtom{}
        var err error
        // Read the mvhd marker (4 bytes)
        a.Marker, err = r.ReadSlice(4)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read the mvhd version (1 byte)
        <span class="cov8" title="1">a.Version, err = r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read the mvhd flags (3 bytes)
        <span class="cov8" title="1">a.Flags, err = r.ReadSlice(3)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if a.Version == 0 </span><span class="cov8" title="1">{
                // Read the creation time (4 bytes)
                b, err := r.ReadSlice(4)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">a.ModificationTime = convertTime32(binary.BigEndian.Uint32(b))
                b, err = r.ReadSlice(4)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">a.CreationTime = convertTime32(binary.BigEndian.Uint32(b))</span>
        } else<span class="cov0" title="0"> {
                // Read the creation time (4 bytes)
                b, err := r.ReadSlice(8)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">a.ModificationTime = convertTime64(binary.BigEndian.Uint64(b))

                b, err = r.ReadSlice(8)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">a.CreationTime = convertTime64(binary.BigEndian.Uint64(b))</span>
        }

        <span class="cov8" title="1">return a, nil</span>
}

func convertTime32(timestamp uint32) time.Time <span class="cov8" title="1">{
        return time.Unix(int64(timestamp)-int64(2082844800), 0)
}</span>

func convertTime64(timestamp uint64) time.Time <span class="cov0" title="0">{
        // Unix epoch starts on January 1, 1970, subtracting the number of seconds from January 1, 1904 to January 1, 1970.
        epochOffset := int64(2082844800)

        // Convert the creation time to Unix timestamp
        unixTimestamp := int64(timestamp&gt;&gt;32) - epochOffset

        // Convert the Unix timestamp to time.Time
        return time.Unix(unixTimestamp, 0)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package exif

import (
        "bufio"
        "bytes"
        "io"
)

type sliceReader struct {
        bufio.Reader
}

func newSliceReader(r io.Reader) *sliceReader <span class="cov8" title="1">{
        return &amp;sliceReader{
                Reader: *bufio.NewReader(r),
        }
}</span>

func (r *sliceReader) ReadSlice(l int) ([]byte, error) <span class="cov8" title="1">{
        b := make([]byte, l)
        _, err := r.Read(b)
        return b, err
}</span>

func searchPattern(r io.Reader, pattern []byte, buffer []byte) (*sliceReader, error) <span class="cov8" title="1">{
        var err error
        pos := 0
        ofs := 0

        var bytesRead int
        for </span><span class="cov8" title="1">{
                // Read a chunk of data into the buffer
                bytesRead, err = r.Read(buffer[ofs:])
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Search for the pattern within the buffer
                <span class="cov8" title="1">index := bytes.Index(buffer[:ofs+bytesRead], pattern)
                if index &gt;= 0 </span><span class="cov8" title="1">{
                        return newSliceReader(io.MultiReader(bytes.NewReader(buffer[index:]), r)), nil
                }</span>

                // Move the remaining bytes of the current buffer to the beginning
                <span class="cov8" title="1">p := bytesRead + ofs - len(pattern) + 1

                copy(buffer, buffer[p:bytesRead+ofs])
                ofs = len(pattern) - 1
                pos += bytesRead</span>
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package jsonsidecar

import (
        "encoding/json"
        "io"

        "github.com/simulot/immich-go/app"
        "github.com/simulot/immich-go/internal/assets"
)

type meta struct {
        Software string `json:"software"`
        assets.Metadata
}

func Write(md *assets.Metadata, w io.Writer) error <span class="cov0" title="0">{
        v := meta{
                Software: app.GetVersion(),
                Metadata: *md,
        }
        enc := json.NewEncoder(w)
        enc.SetIndent("", "  ")
        return enc.Encode(v)
}</span>

func Read(r io.Reader, md *assets.Metadata) error <span class="cov0" title="0">{
        var v meta
        dec := json.NewDecoder(r)
        if err := dec.Decode(&amp;v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*md = v.Metadata
        return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package xmpsidecar

import "strings"

func BoolToString(b bool) string <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                return "True"
        }</span>
        <span class="cov0" title="0">return "False"</span>
}

func StringToBool(s string) bool <span class="cov0" title="0">{
        return strings.ToLower(s) == "true"
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package xmpsidecar

import (
        "fmt"
        "math"
)

/*
GPSCoordinate
A Text value in the form DDD,MM,SSk or DDD,MM.mmk, where:
        DDD is a number of degrees
        MM is a number of minutes
        SS is a number of seconds
        mm is a fraction of minutes
        k is a single character N, S, E, or W indicating a direction (north, south, east, west)

Leading zeros are not necessary for the for DDD, MM, and SS values. The DDD,MM.mmk form should be used
when any of the native EXIF component rational values has a denominator other than 1. There can be any
number of fractional digits.


*/

// GPSFloatToString converts a float GPS coordinate to a string in the format "48,55.68405768N"
func GPSFloatToString(coordinate float64, isLatitude bool) string <span class="cov0" title="0">{
        neg := coordinate &lt; 0
        if coordinate &lt; 0 </span><span class="cov0" title="0">{
                coordinate = -coordinate
        }</span>

        <span class="cov0" title="0">degrees := int(math.Floor(coordinate))
        minutes := float64(coordinate-float64(degrees)) * 60
        direction := "N"
        if !isLatitude </span><span class="cov0" title="0">{
                direction = "E"
        }</span>
        <span class="cov0" title="0">if neg </span><span class="cov0" title="0">{
                direction = "S"
                if !isLatitude </span><span class="cov0" title="0">{
                        direction = "W"
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%d,%08.5f%s", degrees, minutes, direction)</span>
}

// GPTStringToFloat converts a string GPS coordinate in the format "48,55.68405768N" to a float
func GPTStringToFloat(coordinate string) (float64, error) <span class="cov8" title="1">{
        var degrees int
        var minutes float64
        var direction string

        if len(coordinate) &gt; 0 </span><span class="cov8" title="1">{
                direction = string(coordinate[len(coordinate)-1])
                coordinate = coordinate[:len(coordinate)-1]
        }</span>
        <span class="cov8" title="1">_, err := fmt.Sscanf(coordinate, "%d,%f", &amp;degrees, &amp;minutes)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">decimal := float64(degrees) + float64(minutes)/60

        if direction == "S" || direction == "W" </span><span class="cov8" title="1">{
                decimal = -decimal
        }</span>

        <span class="cov8" title="1">return decimal, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package xmpsidecar

import "strconv"

func IntToString(i int) string <span class="cov0" title="0">{
        return strconv.Itoa(i)
}</span>

func StringToInt(s string) int <span class="cov0" title="0">{
        i, _ := strconv.Atoi(s)
        return i
}</span>

func StringToByte(s string) byte <span class="cov8" title="1">{
        i, _ := strconv.Atoi(s)
        if i &lt; 0 || i &gt; 255 </span><span class="cov0" title="0">{
                return 0 // or handle the error as needed
        }</span>
        <span class="cov8" title="1">return byte(i)</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package xmpsidecar

import (
        "fmt"
        "io"
        "path"
        "regexp"
        "time"

        "github.com/clbanning/mxj/v2"
        "github.com/simulot/immich-go/internal/assets"
)

func ReadXMP(r io.Reader, md *assets.Metadata) error <span class="cov8" title="1">{
        // Read the XMP data from the reader and return an Asset
        m, err := mxj.NewMapXmlReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">walk(m, md, "")
        return nil</span>
}

func walk(m mxj.Map, md *assets.Metadata, path string) <span class="cov8" title="1">{
        for key, value := range m </span><span class="cov8" title="1">{
                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        walk(v, md, path+"/"+key)</span>
                case []interface{}:<span class="cov8" title="1">
                        path = path + "/" + key
                        for i, item := range v </span><span class="cov8" title="1">{
                                p := fmt.Sprintf("%s[%d]", path, i)
                                if itemMap, ok := item.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        walk(itemMap, md, p)
                                }</span> else<span class="cov0" title="0"> {
                                        filter(md, p, item.(string))
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        filter(md, path+"/"+key, value.(string))</span>
                }
        }
}

var reDescription = regexp.MustCompile(`/xmpmeta/RDF/Description\[\d+\]/`)

func filter(md *assets.Metadata, p string, value string) <span class="cov8" title="1">{
        p = reDescription.ReplaceAllString(p, "")
        // debug         fmt.Printf("%s: %s\n", p, value)
        switch p </span>{
        case "DateTimeOriginal":<span class="cov8" title="1">
                if d, err := TimeStringToTime(value, time.UTC); err == nil </span><span class="cov8" title="1">{
                        md.DateTaken = d
                }</span>
        case "ImageDescription/Alt/li/#text":<span class="cov8" title="1">
                md.Description = value</span>
        case "Rating":<span class="cov8" title="1">
                md.Rating = StringToByte(value)</span>
        case "TagsList/Seq/li":<span class="cov8" title="1">
                md.Tags = append(md.Tags,
                        assets.Tag{
                                Name:  path.Base(value),
                                Value: value,
                        })</span>
        case "/xmpmeta/RDF/Description/GPSLatitude":<span class="cov8" title="1">
                if f, err := GPTStringToFloat(value); err == nil </span><span class="cov8" title="1">{
                        md.Latitude = f
                }</span>
        case "/xmpmeta/RDF/Description/GPSLongitude":<span class="cov8" title="1">
                if f, err := GPTStringToFloat(value); err == nil </span><span class="cov8" title="1">{
                        md.Longitude = f
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package xmpsidecar

import "time"

/*
exif:DateTimeOriginalDateInternal

EXIF tags 36867, 0x9003 (primary) and 37521, 0x9291 (subseconds). Date and time when original image was generated, in ISO 8601 format. Includes the EXIF
SubSecTimeOriginal data.

Note that EXIF date-time values have no time zone information.


exif:GPSTimeStampDateInternalGPS tag 29 (date), 0x1D, and, and GPS tag 7 (time), 0x07.

Time stamp of GPS data, in Coordinated Universal

Time.

The GPSDateStamp tag is new in EXIF 2.2. The GPS
timestamp in EXIF 2.1 does not include a date. If not
present, the date component for the XMP should be
taken from exif:DateTimeOriginal, or if that is also
lacking from exif:DateTimeDigitized. If no date is
available, do not write exif:GPSTimeStamp to XMP.

*/

/*
Date
A date-time value which is represented using a subset of ISO RFC 8601 formatting, as described in
http://www.w3.org/TR/Note-datetime.html. The following formats are supported:
        YYYY
        YYYY-MM
        YYYY-MM-DD
        YYYY-MM-DDThh:mmTZD
        YYYY-MM-DDThh:mm:ssTZD
        YYYY-MM-DDThh:mm:ss.sTZD
        YYYY = four-digit year
        MM = two-digit month (01=January)
        DD = two-digit day of month (01 through 31)
        hh = two digits of hour (00 through 23)
        mm = two digits of minute (00 through 59)
        ss = two digits of second (00 through 59)
        s = one or more digits representing a decimal fraction of a second
        TZD = time zone designator (Z or +hh:mm or -hh:mm)

The time zone designator is optional in XMP. When not present, the time zone is unknown, and software
should not assume anything about the missing time zone.

It is recommended, when working with local times, that you use a time zone designator of +hh:mm or
-hh:mm instead of Z, to aid human readability. For example, if you know a file was saved at noon on
October 23 a timestamp of 2004-10-23T12:00:00-06:00 is more understandable than
2004-10-23T18:00:00Z.
*/

const xmpTimeLayout = "2006-01-02T15:04:05Z"

func TimeStringToTime(t string, l *time.Location) (time.Time, error) <span class="cov8" title="1">{
        return time.ParseInLocation(xmpTimeLayout, t, l)
}</span>

func TimeToString(t time.Time) string <span class="cov0" title="0">{
        return t.Format(xmpTimeLayout)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package fakeimmich

import (
        "context"
        "io"

        "github.com/simulot/immich-go/immich"
        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/filetypes"
)

type MockedCLient struct{}

func (c *MockedCLient) GetAllAssetsWithFilter(context.Context, func(*immich.Asset) error) error <span class="cov0" title="0">{
        return nil
}</span>

func (c *MockedCLient) AssetUpload(context.Context, *assets.Asset) (immich.AssetResponse, error) <span class="cov0" title="0">{
        return immich.AssetResponse{}, nil
}</span>

func (c *MockedCLient) DeleteAssets(context.Context, []string, bool) error <span class="cov0" title="0">{
        return nil
}</span>

func (c *MockedCLient) GetAllAlbums(context.Context) ([]immich.AlbumSimplified, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c *MockedCLient) AddAssetToAlbum(context.Context, string, []string) ([]immich.UpdateAlbumResult, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c *MockedCLient) CreateAlbum(context.Context, string, string, []string) (immich.AlbumSimplified, error) <span class="cov0" title="0">{
        return immich.AlbumSimplified{}, nil
}</span>

func (c *MockedCLient) UpdateAssets(ctx context.Context, ids []string, isArchived bool, isFavorite bool, latitude float64, longitude float64, removeParent bool, stackParentID string) error <span class="cov0" title="0">{
        return nil
}</span>

func (c *MockedCLient) StackAssets(ctx context.Context, cover string, ids []string) error <span class="cov0" title="0">{
        return nil
}</span>

func (c *MockedCLient) UpdateAsset(ctx context.Context, id string, a *assets.Asset) (*immich.Asset, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c *MockedCLient) EnableAppTrace(w io.Writer) {<span class="cov0" title="0">}</span>

func (c *MockedCLient) GetServerStatistics(ctx context.Context) (immich.ServerStatistics, error) <span class="cov0" title="0">{
        return immich.ServerStatistics{}, nil
}</span>

func (c *MockedCLient) PingServer(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

func (c *MockedCLient) SetDeviceUUID(string) {<span class="cov0" title="0">}</span>

func (c *MockedCLient) SetEndPoint(string) {<span class="cov0" title="0">}</span>

func (c *MockedCLient) ValidateConnection(ctx context.Context) (immich.User, error) <span class="cov0" title="0">{
        return immich.User{}, nil
}</span>

func (c *MockedCLient) GetAssetAlbums(ctx context.Context, id string) ([]immich.AlbumSimplified, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c *MockedCLient) GetAllAssets(ctx context.Context) ([]*immich.Asset, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c *MockedCLient) DeleteAlbum(ctx context.Context, id string) error <span class="cov0" title="0">{
        return nil
}</span>

func (c *MockedCLient) SupportedMedia() filetypes.SupportedMedia <span class="cov0" title="0">{
        return filetypes.DefaultSupportedMedia
}</span>

func (c *MockedCLient) GetAssetStatistics(ctx context.Context) (immich.UserStatistics, error) <span class="cov0" title="0">{
        return immich.UserStatistics{
                Images: 1,
                Videos: 1,
                Total:  1,
        }, nil
}</span>

func (c *MockedCLient) GetJobs(ctx context.Context) (map[string]immich.Job, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (c *MockedCLient) GetAlbumInfo(context.Context, string, bool) (immich.AlbumContent, error) <span class="cov0" title="0">{
        return immich.AlbumContent{}, nil
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package fakefs

import (
        "crypto/rand"
        "fmt"
        "io"
        "io/fs"
        "path"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/filenames"
        "github.com/simulot/immich-go/internal/gen"
)

/*
        simulate a file system based on the list of files contained into a set of archive.

*/

type FakeDirEntry struct {
        name    string      //  name of the file
        size    int64       // length in bytes for regular files; system-dependent for others
        mode    fs.FileMode // file mode bits
        modTime time.Time   // modification time
}

func (fi FakeDirEntry) Name() string               <span class="cov8" title="1">{ return path.Base(fi.name) }</span>
func (fi FakeDirEntry) Size() int64                <span class="cov8" title="1">{ return fi.size }</span>
func (fi FakeDirEntry) Mode() fs.FileMode          <span class="cov0" title="0">{ return fi.mode }</span>
func (fi FakeDirEntry) ModTime() time.Time         <span class="cov8" title="1">{ return fi.modTime }</span>
func (fi FakeDirEntry) IsDir() bool                <span class="cov8" title="1">{ return fi.mode.IsDir() }</span>
func (fi FakeDirEntry) Sys() any                   <span class="cov0" title="0">{ return nil }</span>
func (fi FakeDirEntry) Type() fs.FileMode          <span class="cov0" title="0">{ return fi.mode }</span>
func (fi FakeDirEntry) Info() (fs.FileInfo, error) <span class="cov8" title="1">{ return fi, nil }</span>

type FakeFile struct {
        fi  FakeDirEntry
        r   io.Reader
        pos int64
}

func (f FakeFile) Stat() (fs.FileInfo, error) <span class="cov0" title="0">{
        return f.fi, nil
}</span>

func (f *FakeFile) Read(b []byte) (int, error) <span class="cov0" title="0">{
        if f.pos &lt; f.fi.size </span><span class="cov0" title="0">{
                n, err := f.r.Read(b)
                f.pos += int64(n)
                return n, err
        }</span>
        <span class="cov0" title="0">return 0, io.EOF</span>
}

func (f *FakeFile) Close() error <span class="cov0" title="0">{
        f.pos = 0
        return nil
}</span>

type FakeFS struct {
        name  string
        files map[string]map[string]FakeDirEntry
}

func (fsys FakeFS) Name() string <span class="cov8" title="1">{
        return fsys.name
}</span>

func normalizeName(name string) string <span class="cov8" title="1">{
        if name != "." &amp;&amp; !strings.HasPrefix(name, "./") </span><span class="cov8" title="1">{
                return "./" + name
        }</span>
        <span class="cov8" title="1">return name</span>
}

func (fsys FakeFS) Stat(name string) (fs.FileInfo, error) <span class="cov8" title="1">{
        name = normalizeName(name)
        name = filepath.ToSlash(name)
        dir, base := path.Split(name)
        dir = strings.TrimSuffix(dir, "/")
        var l map[string]FakeDirEntry
        if dir == "" </span><span class="cov8" title="1">{
                dir = "."
        }</span>
        <span class="cov8" title="1">l = fsys.files[dir]
        if len(l) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s:%s: %w", fsys.name, name, fs.ErrNotExist)
        }</span>
        <span class="cov8" title="1">if e, ok := l[base]; ok </span><span class="cov8" title="1">{
                return e, nil
        }</span>
        <span class="cov0" title="0">return nil, fs.ErrNotExist</span>
}

func (fsys FakeFS) Open(name string) (fs.File, error) <span class="cov0" title="0">{
        name = normalizeName(name)
        info, err := fsys.Stat(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fakeInfo := info.(FakeDirEntry)
        var r io.Reader

        ext := path.Ext(name)
        if strings.ToLower(ext) == ".json" </span><span class="cov0" title="0">{
                base := path.Base(name)
                switch base </span>{
                case "mtadonnes.json", "metadata.json", "metadati.json", "metadta.json", "Metadaten.json":<span class="cov0" title="0">
                        album := path.Base(path.Dir(name))
                        r, fakeInfo.size = fakeAlbumData(album)</span>
                case "print-subscriptions.json", "shared_album_comments.json", "user-generated-memory-titles.json":<span class="cov0" title="0">
                        r, fakeInfo.size = fakeJSON()</span>
                default:<span class="cov0" title="0">
                        d := info.ModTime()
                        if d2 := filenames.TakeTimeFromName(name, time.Local); !d2.IsZero() </span><span class="cov0" title="0">{
                                d = d2
                        }</span>
                        <span class="cov0" title="0">title := strings.TrimSuffix(path.Base(name), path.Ext(base))
                        r, fakeInfo.size = fakePhotoData(title, d)</span>
                }
        } else<span class="cov0" title="0"> {
                r = rand.Reader
        }</span>
        <span class="cov0" title="0">return &amp;FakeFile{fi: fakeInfo, r: r}, nil</span>
}

func (fsys FakeFS) ReadDir(name string) ([]fs.DirEntry, error) <span class="cov8" title="1">{
        name = normalizeName(name)
        info, err := fsys.Stat(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov0" title="0">{
                return nil, fs.ErrNotExist
        }</span>

        <span class="cov8" title="1">entries := fsys.files[name]
        if len(entries) == 0 </span><span class="cov0" title="0">{
                return nil, fs.ErrNotExist
        }</span>

        <span class="cov8" title="1">keys := gen.MapKeys(entries)
        sort.Strings(keys)
        out := []fs.DirEntry{}
        for _, k := range keys </span><span class="cov8" title="1">{
                if k != "." </span><span class="cov8" title="1">{
                        out = append(out, entries[k])
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

func (fsys FakeFS) addFile(name string, size int64, modDate time.Time) <span class="cov8" title="1">{
        name = normalizeName(name)
        dir, base := path.Split(name)
        dir = strings.TrimSuffix(dir, "/")
        parts := strings.Split(dir, "/")

        for i, p := range parts </span><span class="cov8" title="1">{
                // create the entry in the parent
                if i == 0 </span><span class="cov8" title="1">{
                        sub := "."
                        if _, ok := fsys.files[sub]; !ok </span><span class="cov8" title="1">{
                                //
                                e := FakeDirEntry{
                                        name:    ".",
                                        modTime: time.Now(),
                                        size:    0,
                                        mode:    0o777 | fs.ModeDir,
                                }

                                fsys.files[sub] = map[string]FakeDirEntry{
                                        ".": e,
                                }
                        }</span>
                } else<span class="cov8" title="1"> {
                        // add entry in the parent
                        parent := strings.Join(parts[:i], "/")
                        dir := parent + "/" + p
                        if _, ok := fsys.files[parent][p]; !ok </span><span class="cov8" title="1">{
                                fsys.files[parent][p] = FakeDirEntry{
                                        name:    dir,
                                        modTime: time.Now(),
                                        size:    0,
                                        mode:    0o777 | fs.ModeDir,
                                }
                        }</span>
                        // create the dir entry
                        <span class="cov8" title="1">if _, ok := fsys.files[dir]; !ok </span><span class="cov8" title="1">{
                                fsys.files[dir] = map[string]FakeDirEntry{
                                        ".": {
                                                name:    dir + "/.",
                                                modTime: time.Now(),
                                                size:    0,
                                                mode:    0o777 | fs.ModeDir,
                                        },
                                }
                        }</span>
                }
        }
        <span class="cov8" title="1">l := fsys.files[dir]
        l[base] = FakeDirEntry{
                name:    name,
                modTime: modDate,
                size:    size,
                mode:    0o777,
        }</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package fakefs

import (
        "fmt"
        "io"
        "strings"
        "time"
)

const albumTemplate = `{
  "title": "%s",
  "description": "",
  "access": "",
  "date": {
    "timestamp": "0",
    "formatted": "1 janv. 1970, 00:00:00 UTC"
  },
  "geoData": {
    "latitude": 0.0,
    "longitude": 0.0,
    "altitude": 0.0,
    "latitudeSpan": 0.0,
    "longitudeSpan": 0.0
  }
}`

func fakeAlbumData(name string) (io.Reader, int64) <span class="cov0" title="0">{
        t := fmt.Sprintf(albumTemplate, name)
        return strings.NewReader(t), int64(len(t))
}</span>

const pictureTemplate = `{
  "title": "%[1]s",
  "description": "",
  "imageViews": "50",
  "creationTime": {
    "timestamp": "%[2]d"
  },
  "photoTakenTime": {
    "timestamp": "%[2]d"
  },
  "geoData": {
    "latitude": 48.0,
    "longitude": 1.0,
    "altitude": 102.86,
    "latitudeSpan": 0.0,
    "longitudeSpan": 0.0
  },
  "geoDataExif": {
    "latitude": 48.0,
    "longitude": 1.0,
    "altitude": 102.86,
    "latitudeSpan": 0.0,
    "longitudeSpan": 0.0
  },
  "url": "https://photos.google.com/photo/AF1QipMZVTuUYj4K1jaN5vy6mkflX6yiWLQO2GDXSNKl",
  "googlePhotosOrigin": {
    "webUpload": {
      "computerUpload": {
      }
    }
  }
}`

func fakePhotoData(name string, captureDate time.Time) (io.Reader, int64) <span class="cov0" title="0">{
        t := fmt.Sprintf(pictureTemplate, name, captureDate.Unix())
        return strings.NewReader(t), int64(len(t))
}</span>

const fakeJSONTemplate = `{
  "Nothing": ""
}`

func fakeJSON() (io.Reader, int64) <span class="cov0" title="0">{
        t := fakeJSONTemplate
        return strings.NewReader(t), int64(len(t))
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package fakefs

/*
        for f in *.zip; do echo "$f: "; unzip -l $f; done &gt;list.lst
*/
import (
        "archive/zip"
        "bufio"
        "errors"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/gen"
)

// `  2104348  07-20-2023 00:00   Takeout/Google Photos/2020 - Costa Rica/IMG_3235.MP4`

var (
        reZipList  = regexp.MustCompile(`(-rw-r--r-- 0/0\s+)?(\d+)\s+(.{16})\s+(.*)$`)
        reFileLine = regexp.MustCompile(`^(\d+)\s+(\d+)\s+files$`) // 2144740441                     10826 files
)

func readFileLine(l string, dateFormat string) (string, int64, time.Time) <span class="cov8" title="1">{
        if len(l) &lt; 30 </span><span class="cov0" title="0">{
                return "", 0, time.Time{}
        }</span>
        <span class="cov8" title="1">m := reZipList.FindStringSubmatch(l)
        if len(m) &lt; 5 </span><span class="cov8" title="1">{
                return "", 0, time.Time{}
        }</span>
        <span class="cov8" title="1">size, _ := strconv.ParseInt(m[2], 10, 64)
        modTime, _ := time.ParseInLocation(dateFormat, m[3], time.Local)
        return m[4], size, modTime</span>
}

func ScanStringList(dateFormat string, s string) ([]fs.FS, error) <span class="cov0" title="0">{
        r := strings.NewReader(s)

        return ScanFileListReader(r, dateFormat)
}</span>

func ScanFileList(name string, dateFormat string) ([]fs.FS, error) <span class="cov8" title="1">{
        var r io.ReadCloser
        f, err := os.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if strings.ToLower(filepath.Ext(name)) == ".zip" </span><span class="cov0" title="0">{
                i, err := f.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">z, err := zip.NewReader(f, i.Size())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(z.File) == 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("zip file is empty")
                }</span>
                <span class="cov0" title="0">r, err = z.File[0].Open()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer r.Close()</span>
        } else<span class="cov8" title="1"> {
                r = f
        }</span>

        <span class="cov8" title="1">defer f.Close()
        return ScanFileListReader(r, dateFormat)</span>
}

func ScanFileListReader(f io.Reader, dateFormat string) ([]fs.FS, error) <span class="cov8" title="1">{
        fsyss := map[string]*FakeFS{}
        var fsys *FakeFS
        currentZip := ""
        ok := false

        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov8" title="1">{
                l := scanner.Text()
                if strings.HasPrefix(l, "Part:") </span><span class="cov0" title="0">{
                        currentZip = strings.TrimSpace(strings.TrimPrefix(l, "Part:"))
                        fsys, ok = fsyss[currentZip]
                        if !ok </span><span class="cov0" title="0">{
                                fsys = &amp;FakeFS{
                                        name:  currentZip,
                                        files: map[string]map[string]FakeDirEntry{},
                                }

                                fsyss[currentZip] = fsys
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(l, "Archive:") </span><span class="cov8" title="1">{
                        currentZip = strings.TrimSpace(strings.TrimPrefix(l, "Archive:"))
                        fsys, ok = fsyss[currentZip]
                        if !ok </span><span class="cov8" title="1">{
                                fsys = &amp;FakeFS{
                                        name:  currentZip,
                                        files: map[string]map[string]FakeDirEntry{},
                                }

                                fsyss[currentZip] = fsys
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if reFileLine.MatchString(l) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if name, size, modTime := readFileLine(l, dateFormat); name != "" </span><span class="cov8" title="1">{
                        fsys.addFile(name, size, modTime)
                }</span>
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">names := gen.MapKeys(fsyss)
        sort.Strings(names)
        output := make([]fs.FS, len(fsyss))
        i := 0
        for _, name := range names </span><span class="cov8" title="1">{
                output[i] = fsyss[name]
                i++
        }</span>
        <span class="cov8" title="1">return output, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">// Package fileevent provides a mechanism to record and report events related to file processing.

package fileevent

/*
        TODO:
        - rename the package as journal
        - use a filenemame type that keeps the fsys and the name in that fsys

*/
import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "sync/atomic"
)

/*
        Collect all actions done on a given file
*/

type Code int

const (
        NotHandled            Code = iota
        DiscoveredImage            // = "Scanned image"
        DiscoveredVideo            // = "Scanned video"
        DiscoveredSidecar          // = "Scanned side car file"
        DiscoveredDiscarded        // = "Discarded"
        DiscoveredUnsupported      // = "File type not supported"
        DiscoveredUseless          // = "Useless file"

        AnalysisAssociatedMetadata
        AnalysisMissingAssociatedMetadata
        AnalysisLocalDuplicate

        UploadNotSelected
        UploadUpgraded        // = "Server's asset upgraded"
        UploadServerDuplicate // = "Server has photo"
        UploadServerBetter    // = "Server's asset is better"
        UploadAlbumCreated
        UploadAddToAlbum // = "Added to an album"
        UploadLi
        UploadServerError // = "Server error"

        Uploaded  // = "Uploaded"
        Stacked   // = "Stacked"
        LivePhoto // = "Live photo"
        Metadata  // = "Metadata files"
        INFO      // = "Info"

        Written // = "Written"

        Tagged // = "Tagged"

        Error
        MaxCode
)

var _code = map[Code]string{
        NotHandled:            "Not handled",
        DiscoveredImage:       "scanned image file",
        DiscoveredVideo:       "scanned video file",
        DiscoveredSidecar:     "scanned sidecar file",
        DiscoveredDiscarded:   "discarded file",
        DiscoveredUnsupported: "unsupported file",
        DiscoveredUseless:     "useless file",

        AnalysisAssociatedMetadata:        "associated metadata file",
        AnalysisMissingAssociatedMetadata: "missing associated metadata file",
        AnalysisLocalDuplicate:            "file duplicated in the input",

        UploadNotSelected:     "file not selected",
        UploadUpgraded:        "server's asset upgraded with the input",
        UploadAddToAlbum:      "added to an album",
        UploadServerDuplicate: "server has same asset",
        UploadServerBetter:    "server has a better asset",
        UploadAlbumCreated:    "album created/updated",
        UploadServerError:     "upload error",
        Uploaded:              "uploaded",

        Stacked:   "Stacked",
        LivePhoto: "Live photo",
        Metadata:  "Metadata files",
        INFO:      "Info",

        Written: "Written",

        Tagged: "Tagged",
        Error:  "error",
}

var _logLevels = map[Code]slog.Level{
        DiscoveredImage:                   slog.LevelInfo,
        DiscoveredVideo:                   slog.LevelInfo,
        DiscoveredDiscarded:               slog.LevelWarn,
        DiscoveredUnsupported:             slog.LevelWarn,
        DiscoveredUseless:                 slog.LevelWarn,
        AnalysisAssociatedMetadata:        slog.LevelInfo,
        AnalysisMissingAssociatedMetadata: slog.LevelWarn,
        AnalysisLocalDuplicate:            slog.LevelWarn,
        UploadNotSelected:                 slog.LevelWarn,
        UploadUpgraded:                    slog.LevelInfo,
        UploadServerBetter:                slog.LevelInfo,
        UploadAlbumCreated:                slog.LevelInfo,
        UploadServerError:                 slog.LevelError,
        Uploaded:                          slog.LevelInfo,
        Stacked:                           slog.LevelInfo,
        LivePhoto:                         slog.LevelInfo,
        Metadata:                          slog.LevelInfo,
        INFO:                              slog.LevelInfo,
        Written:                           slog.LevelInfo,
        Tagged:                            slog.LevelInfo,
        Error:                             slog.LevelError,
}

func (e Code) String() string <span class="cov0" title="0">{
        if s, ok := _code[e]; ok </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("unknown event code: %d", int(e))</span>
}

type Recorder struct {
        counts counts
        log    *slog.Logger
}

type counts []int64

func NewRecorder(l *slog.Logger) *Recorder <span class="cov0" title="0">{
        r := &amp;Recorder{
                counts: make([]int64, MaxCode),
                log:    l,
        }
        return r
}</span>

func (r *Recorder) Log() *slog.Logger <span class="cov0" title="0">{
        return r.log
}</span>

func (r *Recorder) Record(ctx context.Context, code Code, file slog.LogValuer, args ...any) <span class="cov0" title="0">{
        atomic.AddInt64(&amp;r.counts[code], 1)
        if r.log != nil </span><span class="cov0" title="0">{
                level := _logLevels[code]
                if file != nil </span><span class="cov0" title="0">{
                        args = append([]any{"file", file.LogValue()}, args...)
                }</span>

                <span class="cov0" title="0">for _, a := range args </span><span class="cov0" title="0">{
                        if a == "error" </span><span class="cov0" title="0">{
                                level = slog.LevelError
                                break</span>
                        }
                        <span class="cov0" title="0">if a == "warning" </span><span class="cov0" title="0">{
                                level = slog.LevelWarn
                                break</span>
                        }
                }
                <span class="cov0" title="0">r.log.Log(ctx, level, code.String(), args...)</span>
        }
}

func (r *Recorder) SetLogger(l *slog.Logger) <span class="cov0" title="0">{
        r.log = l
}</span>

func (r *Recorder) Report() <span class="cov0" title="0">{
        sb := strings.Builder{}

        countAnalysis := 0
        for _, c := range []Code{
                DiscoveredImage,
                DiscoveredVideo,
                DiscoveredSidecar,
                DiscoveredDiscarded,
                DiscoveredUnsupported,
                AnalysisLocalDuplicate,
                AnalysisAssociatedMetadata,
                AnalysisMissingAssociatedMetadata,
        } </span><span class="cov0" title="0">{
                countAnalysis += int(r.counts[c])
        }</span>

        <span class="cov0" title="0">if countAnalysis &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("\n")
                sb.WriteString("Input analysis:\n")
                sb.WriteString("---------------\n")
                for _, c := range []Code{
                        DiscoveredImage,
                        DiscoveredVideo,
                        DiscoveredSidecar,
                        DiscoveredDiscarded,
                        DiscoveredUnsupported,
                        AnalysisLocalDuplicate,
                        AnalysisAssociatedMetadata,
                        AnalysisMissingAssociatedMetadata,
                } </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("%-40s: %7d\n", c.String(), r.counts[c]))
                }</span>
                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        <span class="cov0" title="0">countsUpload := 0
        for _, c := range []Code{
                Uploaded,
                UploadServerError,
                UploadNotSelected,
                UploadUpgraded,
                UploadServerDuplicate,
                UploadServerBetter,
        } </span><span class="cov0" title="0">{
                countsUpload += int(r.counts[c])
        }</span>
        <span class="cov0" title="0">if countsUpload &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("Uploading:\n")
                sb.WriteString("----------\n")
                for _, c := range []Code{
                        Uploaded,
                        UploadServerError,
                        UploadNotSelected,
                        UploadUpgraded,
                        UploadServerDuplicate,
                        UploadServerBetter,
                } </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("%-40s: %7d\n", c.String(), r.counts[c]))
                }</span>
                <span class="cov0" title="0">fmt.Println(sb.String())</span>
        }

        <span class="cov0" title="0">if countsUpload &gt; 0 || countAnalysis &gt; 0 </span><span class="cov0" title="0">{
                lines := strings.Split(sb.String(), "\n")
                for _, s := range lines </span><span class="cov0" title="0">{
                        r.log.Info(s)
                }</span>
        }
}

func (r *Recorder) GetCounts() []int64 <span class="cov0" title="0">{
        counts := make([]int64, MaxCode)
        for i := range counts </span><span class="cov0" title="0">{
                counts[i] = atomic.LoadInt64(&amp;r.counts[i])
        }</span>
        <span class="cov0" title="0">return counts</span>
}

func (r *Recorder) TotalAssets() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;r.counts[DiscoveredImage]) + atomic.LoadInt64(&amp;r.counts[DiscoveredVideo])
}</span>

func (r *Recorder) TotalProcessedGP() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;r.counts[AnalysisAssociatedMetadata]) +
                atomic.LoadInt64(&amp;r.counts[AnalysisMissingAssociatedMetadata]) +
                atomic.LoadInt64(&amp;r.counts[DiscoveredDiscarded])
}</span>

func (r *Recorder) TotalProcessed(forcedMissingJSON bool) int64 <span class="cov0" title="0">{
        v := atomic.LoadInt64(&amp;r.counts[Uploaded]) +
                atomic.LoadInt64(&amp;r.counts[UploadServerError]) +
                atomic.LoadInt64(&amp;r.counts[UploadNotSelected]) +
                atomic.LoadInt64(&amp;r.counts[UploadUpgraded]) +
                atomic.LoadInt64(&amp;r.counts[UploadServerDuplicate]) +
                atomic.LoadInt64(&amp;r.counts[UploadServerBetter]) +
                atomic.LoadInt64(&amp;r.counts[DiscoveredDiscarded]) +
                atomic.LoadInt64(&amp;r.counts[AnalysisLocalDuplicate])
        if !forcedMissingJSON </span><span class="cov0" title="0">{
                v += atomic.LoadInt64(&amp;r.counts[AnalysisMissingAssociatedMetadata])
        }</span>
        <span class="cov0" title="0">return v</span>
}

// IsEqualCounts checks if two slices of int64 have the same elements in the same order.
// Used for tests only
func IsEqualCounts(a, b []int64) bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := range a </span><span class="cov0" title="0">{
                if a[i] != b[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// PrepareCountsForTest takes an undefined  number of int arguments and returns a slice of int64
// Used for tests only

func NewCounts() *counts <span class="cov0" title="0">{
        c := counts(make([]int64, MaxCode))
        return &amp;c
}</span>

func (cnt *counts) Set(c Code, v int64) *counts <span class="cov0" title="0">{
        (*cnt)[c] = v
        return cnt
}</span>

func (cnt *counts) Value() []int64 <span class="cov0" title="0">{
        return (*cnt)[:MaxCode]
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package filenames

import (
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/assets"
)

/*
Huawei burst file name pattern
IMG_20231014_183246_BURST001_COVER.jpg
IMG_20231014_183246_BURST002.jpg
IMG_20231014_183246_BURST003.jpg
*/
var huaweiRE = regexp.MustCompile(`^(IMG_\d{8}_\d{6})_BURST(\d{3})(?:_(\w+))?(\..+)$`)

func (ic InfoCollector) Huawei(name string) (bool, assets.NameInfo) <span class="cov8" title="1">{
        parts := huaweiRE.FindStringSubmatch(name)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return false, assets.NameInfo{}
        }</span>
        <span class="cov8" title="1">ext := parts[4]
        info := assets.NameInfo{
                Radical: parts[1],
                Base:    name,
                IsCover: strings.HasSuffix(parts[3], "COVER"),
                Ext:     strings.ToLower(ext),
                Type:    ic.SM.TypeFromExt(ext),
                Kind:    assets.KindBurst,
        }
        info.Index, _ = strconv.Atoi(parts[2])
        info.Taken, _ = time.ParseInLocation("20060102_150405", parts[1][4:19], ic.TZ)
        return true, info</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package filenames

import (
        "path"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/filetypes"
)

type InfoCollector struct {
        TZ *time.Location
        SM filetypes.SupportedMedia
}

// NewInfoCollector creates a new InfoCollector
func NewInfoCollector(tz *time.Location, sm filetypes.SupportedMedia) *InfoCollector <span class="cov0" title="0">{
        return &amp;InfoCollector{
                TZ: tz,
                SM: sm,
        }
}</span>

// nameMatcher analyze the name and return
// bool -&gt; true when name is a part of a burst
// NameInfo -&gt; the information extracted from the name
type nameMatcher func(name string) (bool, assets.NameInfo)

// GetInfo analyze the name and return the information extracted from the name
func (ic InfoCollector) GetInfo(name string) assets.NameInfo <span class="cov8" title="1">{
        base := path.Base(name)
        for _, m := range []nameMatcher{ic.Pixel, ic.Samsung, ic.Nexus, ic.Huawei, ic.SonyXperia} </span><span class="cov8" title="1">{
                if ok, i := m(base); ok </span><span class="cov8" title="1">{
                        return i
                }</span>
        }

        // no matcher found, return a basic info
        <span class="cov8" title="1">t := TakeTimeFromPath(name, ic.TZ)
        ext := path.Ext(base)

        return assets.NameInfo{
                Base:    base,
                Radical: strings.TrimSuffix(base, ext),
                Ext:     strings.ToLower(ext),
                Taken:   t,
                Type:    ic.SM.TypeFromExt(ext),
        }</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package filenames

import (
        "os"
        "regexp"
        "strconv"
        "strings"
        "time"
)

var timeRe = regexp.MustCompile(`(19[89]\d|20\d\d)\D?(0\d|1[0-2])\D?([0-3]\d)\D{0,1}([01]\d|2[0-4])?\D?([0-5]\d)?\D?([0-5]\d)?`)

// TakeTimeFromPath takes the full path of a file and returns a time.Time value that is extracted
// from the given full path. At first it tries to extract from filename, then from each folder
// name (end to start), If no time is found - it will try to extract from the path itself as a
// last resort (e.g. /something/2024/06/06/file123.png).
func TakeTimeFromPath(fullpath string, tz *time.Location) time.Time <span class="cov8" title="1">{
        parts := strings.Split(fullpath, string(os.PathSeparator))

        for i := len(parts) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if t := TakeTimeFromName(parts[i], tz); !t.IsZero() </span><span class="cov8" title="1">{
                        return t
                }</span>
        }

        <span class="cov8" title="1">return TakeTimeFromName(fullpath, tz)</span>
}

// TakeTimeFromName takes the name of a file and returns a time.Time value that is extracted
// from the given file name. It uses the given Timezone to parse the time.
func TakeTimeFromName(s string, tz *time.Location) time.Time <span class="cov8" title="1">{
        timeSegments := timeRe.FindStringSubmatch(s)
        if len(timeSegments) &lt; 4 </span><span class="cov8" title="1">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">m := make([]int, 6)
        for i := 1; i &lt; len(timeSegments); i++ </span><span class="cov8" title="1">{
                m[i-1], _ = strconv.Atoi(timeSegments[i])
        }</span>
        <span class="cov8" title="1">t := time.Date(m[0], time.Month(m[1]), m[2], m[3], m[4], m[5], 0, tz)

        if t.Year() != m[0] || t.Month() != time.Month(m[1]) || t.Day() != m[2] ||
                t.Hour() != m[3] || t.Minute() != m[4] || t.Second() != m[5] </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov8" title="1">if time.Since(t) &lt; -24*time.Hour </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        // Below is not needed as it is enforced by Regex
        // if t.Year() &lt; 1980 {
        //         continue
        // }
        <span class="cov8" title="1">return t</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package filenames

import (
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/assets"
)

/*

Nexus burst file name pattern
#100 stack: Huawei Nexus 6P

Burst
00001IMG_00001_BURST20171111030039.jpg
...
00014IMG_00014_BURST20171111030039.jpg
00015IMG_00015_BURST20171111030039_COVER.jpg
00000PORTRAIT_00000_BURST20190828181853475.jpg
00100lPORTRAIT_00100_BURST20181229213517346_COVER.jpg
00000IMG_00000_BURST20200607093330363_COVER.jpg
00000IMG_00000_BURST20190830164840873_COVER.jpg
00000IMG_00000_BURST20190830164840873.jpg


Regular
IMG_20171111_030055.jpg
IMG_20171111_030128.jpg
*/

var nexusRE = regexp.MustCompile(`^(\d+)\D+_\d+_(BURST\d+)(\D+)?(\..+)$`)

func (ic InfoCollector) Nexus(name string) (bool, assets.NameInfo) <span class="cov8" title="1">{
        parts := nexusRE.FindStringSubmatch(name)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return false, assets.NameInfo{}
        }</span>
        <span class="cov8" title="1">ext := parts[4]
        info := assets.NameInfo{
                Radical: parts[2],
                Base:    name,
                IsCover: strings.Contains(parts[3], "COVER"),
                Ext:     strings.ToLower(ext),
                Type:    ic.SM.TypeFromExt(ext),
                Kind:    assets.KindBurst,
        }
        info.Index, _ = strconv.Atoi(parts[1])
        info.Taken, _ = time.ParseInLocation("20060102150405", parts[2][5:19], ic.TZ)
        return true, info</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package filenames

import (
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/assets"
)

/*
Pixel burst file name pattern
#94 stack: for Pixel 5 and Pixel 8 Pro naming schemes
Google Pixel 5
Normal - STACKS
PXL_20231026_210642603.dng
PXL_20231026_210642603.jpg

Burst - DOES NOT STACK
PXL_20231026_205755225.dng
PXL_20231026_205755225.MP.jpg

Google Pixel 8 Pro
Normal - DOES NOT STACK
PXL_20231207_032111247.RAW-02.ORIGINAL.dng
PXL_20231207_032111247.RAW-01.COVER.jpg

Burst - DOES NOT STACK
PXL_20231207_032108788.RAW-02.ORIGINAL.dng
PXL_20231207_032108788.RAW-01.MP.COVER.jpg

PXL_20230330_184138390.MOTION-01.COVER.jpg
PXL_20230330_184138390.MOTION-02.ORIGINAL.jpg
PXL_20230330_201207251.jpg
PXL_20230816_132648337.NIGHT.jpg
PXL_20230817_175514506.PANO.jpg
PXL_20230809_203029471.LONG_EXPOSURE-01.COVER.jpg
PXL_20230809_203055470.LONG_EXPOSURE-01.COVER.jpg
PXL_20231220_170358366.RAW-01.COVER.jpg
PXL_20231220_170358366.RAW-02.ORIGINAL.dng

PXL_20211014_171433750.MP.jpg
PXL_20211015_192314061.PORTRAIT.jpg
PXL_20211012_171937656.NIGHT.jpg
*/
var pixelRE = regexp.MustCompile(`^(PXL_\d{8}_\d{9})((.*)?(\d{2}))?(.*)?(\..*)$`)

func (ic InfoCollector) Pixel(name string) (bool, assets.NameInfo) <span class="cov8" title="1">{
        parts := pixelRE.FindStringSubmatch(name)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return false, assets.NameInfo{}
        }</span>
        <span class="cov8" title="1">ext := parts[6]
        info := assets.NameInfo{
                Radical: parts[1],
                Base:    name,
                IsCover: strings.HasSuffix(parts[5], "COVER"),
                Ext:     strings.ToLower(ext),
                Type:    ic.SM.TypeFromExt(ext),
        }
        if parts[4] != "" </span><span class="cov8" title="1">{
                info.Index, _ = strconv.Atoi(parts[4])
        }</span>
        <span class="cov8" title="1">switch </span>{
        case strings.Contains(parts[3], "PORTRAIT"):<span class="cov0" title="0">
                info.Kind = assets.KindPortrait</span>
        case strings.Contains(parts[3], "NIGHT"):<span class="cov8" title="1">
                info.Kind = assets.KindNight</span>
        case strings.Contains(parts[3], "LONG_EXPOSURE"):<span class="cov8" title="1">
                info.Kind = assets.KindLongExposure</span>
        case strings.Contains(parts[3], "MOTION"):<span class="cov8" title="1">
                info.Kind = assets.KindMotion</span>
        }
        <span class="cov8" title="1">info.Taken, _ = time.ParseInLocation("20060102_150405", parts[1][4:19], time.UTC)
        return true, info</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package filenames

import (
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/assets"
)

// Samsung burst file name pattern
// #99  stack: Samsung #99
// 20231207_101605_001.jpg
// 20231207_101605_002.jpg
// 20231207_101605_xxx.jpg

var samsungRE = regexp.MustCompile(`^(\d{8}_\d{6})_(\d{3})(\..+)$`)

func (ic InfoCollector) Samsung(name string) (bool, assets.NameInfo) <span class="cov8" title="1">{
        parts := samsungRE.FindStringSubmatch(name)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return false, assets.NameInfo{}
        }</span>
        <span class="cov8" title="1">info := assets.NameInfo{
                Radical: parts[1],
                Base:    name,
                Ext:     strings.ToLower(parts[3]),
                Type:    ic.SM.TypeFromExt(parts[3]),
                Kind:    assets.KindBurst,
        }
        info.Index, _ = strconv.Atoi(parts[2])
        info.IsCover = info.Index == 1
        info.Taken, _ = time.ParseInLocation("20060102_150405", parts[1], ic.TZ)
        return true, info</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package filenames

import (
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/simulot/immich-go/internal/assets"
)

var sonyXperiaRE = regexp.MustCompile(`^DSC_(\d+)_BURST(\d+)(\D+)?(\..+)$`)

func (ic InfoCollector) SonyXperia(name string) (bool, assets.NameInfo) <span class="cov8" title="1">{
        parts := sonyXperiaRE.FindStringSubmatch(name)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return false, assets.NameInfo{}
        }</span>
        <span class="cov8" title="1">ext := parts[4]
        info := assets.NameInfo{
                Radical: "BURST" + parts[2],
                Base:    name,
                IsCover: strings.Contains(parts[3], "COVER"),
                Ext:     strings.ToLower(ext),
                Type:    ic.SM.TypeFromExt(ext),
                Kind:    assets.KindBurst,
        }
        info.Index, _ = strconv.Atoi(parts[1])

        info.Taken, _ = time.ParseInLocation("20060102150405.000", parts[2][:14]+"."+parts[2][14:], ic.TZ)
        return true, info</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package filetypes

import (
        "path"
        "slices"
        "sort"
        "strings"
        "sync"
)

type SupportedMedia map[string]string

const (
        TypeVideo   = "video"
        TypeImage   = "image"
        TypeSidecar = "sidecar"
        TypeUseless = "useless"
        TypeUnknown = ""
)

var DefaultSupportedMedia = SupportedMedia{
        ".3gp": TypeVideo, ".avi": TypeVideo, ".flv": TypeVideo, ".insv": TypeVideo, ".m2ts": TypeVideo, ".m4v": TypeVideo, ".mkv": TypeVideo, ".mov": TypeVideo, ".mp4": TypeVideo, ".mpg": TypeVideo, ".mts": TypeVideo, ".webm": TypeVideo, ".wmv": TypeVideo,
        ".3fr": TypeImage, ".ari": TypeImage, ".arw": TypeImage, ".avif": TypeImage, ".bmp": TypeImage, ".cap": TypeImage, ".cin": TypeImage, ".cr2": TypeImage, ".cr3": TypeImage, ".crw": TypeImage, ".dcr": TypeImage, ".dng": TypeImage, ".erf": TypeImage,
        ".fff": TypeImage, ".gif": TypeImage, ".heic": TypeImage, ".heif": TypeImage, ".hif": TypeImage, ".iiq": TypeImage, ".insp": TypeImage, ".jpe": TypeImage, ".jpeg": TypeImage, ".jpg": TypeImage,
        ".jxl": TypeImage, ".k25": TypeImage, ".kdc": TypeImage, ".mrw": TypeImage, ".nef": TypeImage, ".orf": TypeImage, ".ori": TypeImage, ".pef": TypeImage, ".png": TypeImage, ".psd": TypeImage, ".raf": TypeImage, ".raw": TypeImage, ".rw2": TypeImage,
        ".rwl": TypeImage, ".sr2": TypeImage, ".srf": TypeImage, ".srw": TypeImage, ".tif": TypeImage, ".tiff": TypeImage, ".webp": TypeImage, ".x3f": TypeImage,
        ".xmp":  TypeSidecar,
        ".json": TypeSidecar,
        ".mp":   TypeUseless,
}

func (sm SupportedMedia) TypeFromName(name string) string <span class="cov0" title="0">{
        ext := name[strings.LastIndex(name, "."):]
        return sm.TypeFromExt(ext)
}</span>

func (sm SupportedMedia) TypeFromExt(ext string) string <span class="cov0" title="0">{
        ext = strings.ToLower(ext)
        if strings.HasPrefix(ext, ".mp~") </span><span class="cov0" title="0">{
                // #405
                ext = ".mp"
        }</span>
        <span class="cov0" title="0">return sm[ext]</span>
}

func (sm SupportedMedia) IsMedia(ext string) bool <span class="cov0" title="0">{
        t := sm.TypeFromExt(ext)
        return t == TypeVideo || t == TypeImage
}</span>

var (
        _supportedExtension    []string
        initSupportedExtension sync.Once
)

func (sm SupportedMedia) IsExtensionPrefix(ext string) bool <span class="cov0" title="0">{
        initSupportedExtension.Do(func() </span><span class="cov0" title="0">{
                _supportedExtension = make([]string, len(sm))
                i := 0
                for k := range sm </span><span class="cov0" title="0">{
                        _supportedExtension[i] = k[:len(k)-2]
                        i++
                }</span>
                <span class="cov0" title="0">sort.Strings(_supportedExtension)</span>
        })
        <span class="cov0" title="0">ext = strings.ToLower(ext)
        _, b := slices.BinarySearch(_supportedExtension, ext)
        return b</span>
}

func (sm SupportedMedia) IsIgnoredExt(ext string) bool <span class="cov0" title="0">{
        t := sm.TypeFromExt(ext)
        return t == ""
}</span>

// rawExtensions defines the supported RAW file extensions
// https://github.com/immich-app/immich/blob/39b571a95c99cbc4183e5d389e6d682cd8e903d9/server/src/utils/mime-types.ts#L1-L55
// source: https://en.wikipedia.org/wiki/Raw_image_format
var rawExtensions = map[string]bool{
        ".3fr": true, ".ari": true, ".arw": true, ".cap": true,
        ".cin": true, ".cr2": true, ".cr3": true, ".crw": true,
        ".dcr": true, ".dng": true, ".erf": true, ".fff": true,
        ".iiq": true, ".k25": true, ".kdc": true, ".mrw": true,
        ".nef": true, ".nrw": true, ".orf": true, ".ori": true,
        ".pef": true, ".psd": true, ".raf": true, ".raw": true,
        ".rw2": true, ".rwl": true, ".sr2": true, ".srf": true,
        ".srw": true, ".x3f": true,
}

// IsRawFile checks if the given filename has a RAW file extension
func IsRawFile(ext string) bool <span class="cov0" title="0">{
        ext = strings.ToLower(ext)
        return rawExtensions[ext]
}</span>

func (sm SupportedMedia) IsUseLess(name string) bool <span class="cov0" title="0">{
        ext := strings.ToLower(path.Ext(name))
        if sm.IsIgnoredExt(ext) </span><span class="cov0" title="0">{
                return true
        }</span>

        // MVIMG* is a Google Motion Photo movie part, not useful
        <span class="cov0" title="0">if ext == "" &amp;&amp; strings.HasPrefix(strings.ToUpper(name), "MVIMG") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package filters

import (
        "fmt"
        "strings"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/filetypes"
)

type BurstFlag int

const (
        BurstNothing  BurstFlag = iota
        BurstStack              // Stack burst photos, all the photos in the burst are kept
        BurstkKeepRaw           // Stack burst, keep raw photos when when have JPEG and raw
        BurstKeepJPEG           // Stack burst, keep JPEG photos when when have JPEG and raw
)

func (b BurstFlag) GroupFilter() Filter <span class="cov0" title="0">{
        switch b </span>{
        case BurstNothing:<span class="cov0" title="0">
                return unGroupBurst</span>
        case BurstStack:<span class="cov0" title="0">
                return groupBurst</span>
        case BurstkKeepRaw:<span class="cov0" title="0">
                return groupBurstKeepRaw</span>
        case BurstKeepJPEG:<span class="cov0" title="0">
                return stackBurstKeepJPEG</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func unGroupBurst(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByBurst </span><span class="cov8" title="1">{
                return g
        }</span>
        <span class="cov8" title="1">g.Grouping = assets.GroupByNone
        return g</span>
}

func groupBurst(g *assets.Group) *assets.Group <span class="cov0" title="0">{
        return g
}</span>

func groupBurstKeepRaw(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByBurst </span><span class="cov8" title="1">{
                return g
        }</span>
        // Keep only raw files
        <span class="cov8" title="1">removedAssets := []*assets.Asset{}
        keep := 0
        for _, a := range g.Assets </span><span class="cov8" title="1">{
                if filetypes.IsRawFile(a.Ext) </span><span class="cov8" title="1">{
                        keep++
                }</span> else<span class="cov8" title="1"> {
                        removedAssets = append(removedAssets, a)
                }</span>
        }
        <span class="cov8" title="1">if keep &gt; 0 </span><span class="cov8" title="1">{
                for _, a := range removedAssets </span><span class="cov8" title="1">{
                        g.RemoveAsset(a, "Keep only RAW files in burst")
                }</span>
        }
        <span class="cov8" title="1">if len(g.Assets) &lt; 2 </span><span class="cov8" title="1">{
                g.Grouping = assets.GroupByNone
        }</span>
        <span class="cov8" title="1">return g</span>
}

func stackBurstKeepJPEG(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByBurst </span><span class="cov8" title="1">{
                return g
        }</span>
        // Keep only jpe files
        <span class="cov8" title="1">removedAssets := []*assets.Asset{}
        keep := 0
        for _, a := range g.Assets </span><span class="cov8" title="1">{
                if a.Ext == ".jpg" || a.Ext == ".jpeg" </span><span class="cov8" title="1">{ // nolint: goconst
                        keep++
                }</span> else<span class="cov8" title="1"> {
                        removedAssets = append(removedAssets, a)
                }</span>
        }
        <span class="cov8" title="1">if keep &gt; 0 </span><span class="cov8" title="1">{
                for _, a := range removedAssets </span><span class="cov8" title="1">{
                        g.RemoveAsset(a, "Keep only JPEG files in burst")
                }</span>
        }
        <span class="cov8" title="1">if len(g.Assets) &lt; 2 </span><span class="cov8" title="1">{
                g.Grouping = assets.GroupByNone
        }</span>
        <span class="cov8" title="1">return g</span>
}

// Implement spf13 flag.Value interface

func (b *BurstFlag) Set(value string) error <span class="cov0" title="0">{
        switch strings.ToLower(value) </span>{
        case "":<span class="cov0" title="0">
                *b = BurstNothing</span>
        case "stack":<span class="cov0" title="0">
                *b = BurstStack</span>
        case "stackkeepraw":<span class="cov0" title="0">
                *b = BurstkKeepRaw</span>
        case "stackkeepjpeg":<span class="cov0" title="0">
                *b = BurstKeepJPEG</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid value %q for BurstFlag", value)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (b BurstFlag) String() string <span class="cov0" title="0">{
        switch b </span>{
        case BurstNothing:<span class="cov0" title="0">
                return ""</span>
        case BurstStack:<span class="cov0" title="0">
                return "Stack"</span>
        case BurstkKeepRaw:<span class="cov0" title="0">
                return "StackKeepRaw"</span>
        case BurstKeepJPEG:<span class="cov0" title="0">
                return "StackKeepJPEG"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span> // nolint: goconst
        }
}

func (b BurstFlag) Type() string <span class="cov0" title="0">{
        return "BurstFlag"
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package filters

import (
        "fmt"
        "strings"

        "github.com/simulot/immich-go/internal/assets"
)

type HeicJpgFlag int

const (
        HeicJpgNothing   HeicJpgFlag = iota
        HeicJpgKeepHeic              // Keep only HEIC files
        HeicJpgKeepJPG               // Keep only JPEG files
        HeicJpgStackHeic             // Stack HEIC and JPEG files, with the HEIC file as the cover
        HeicJpgStackJPG              // Stack HEIC and JPEG files, with the JPEG file as the cover
)

func (h HeicJpgFlag) GroupFilter() Filter <span class="cov0" title="0">{
        switch h </span>{
        case HeicJpgNothing:<span class="cov0" title="0">
                return unGroupHeicJpeg</span>
        case HeicJpgKeepHeic:<span class="cov0" title="0">
                return groupHeicJpgKeepHeic</span>
        case HeicJpgKeepJPG:<span class="cov0" title="0">
                return groupHeicJpgKeepJPG</span>
        case HeicJpgStackHeic:<span class="cov0" title="0">
                return groupHeicJpgStackHeic</span>
        case HeicJpgStackJPG:<span class="cov0" title="0">
                return groupHeicJpgStackJPG</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func unGroupHeicJpeg(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByHeicJpg </span><span class="cov8" title="1">{
                return g
        }</span>
        <span class="cov8" title="1">g.Grouping = assets.GroupByNone
        return g</span>
}

func groupHeicJpgKeepHeic(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByHeicJpg </span><span class="cov0" title="0">{
                return g
        }</span>
        // Keep only heic files
        <span class="cov8" title="1">removedAssets := []*assets.Asset{}
        keep := 0
        for _, a := range g.Assets </span><span class="cov8" title="1">{
                if a.Ext == ".heic" </span><span class="cov8" title="1">{
                        keep++
                }</span> else<span class="cov8" title="1"> {
                        removedAssets = append(removedAssets, a)
                }</span>
        }

        <span class="cov8" title="1">if keep &gt; 0 </span><span class="cov8" title="1">{
                for _, a := range removedAssets </span><span class="cov8" title="1">{
                        g.RemoveAsset(a, "Keep only HEIC files in HEIC/JPEG group")
                }</span>
        }
        <span class="cov8" title="1">if len(g.Assets) &lt; 2 </span><span class="cov8" title="1">{
                g.Grouping = assets.GroupByNone
        }</span>
        <span class="cov8" title="1">return g</span>
}

func groupHeicJpgKeepJPG(g *assets.Group) *assets.Group <span class="cov0" title="0">{
        if g.Grouping != assets.GroupByHeicJpg </span><span class="cov0" title="0">{
                return g
        }</span>
        // Keep only heic files
        <span class="cov0" title="0">removedAssets := []*assets.Asset{}
        keep := 0
        for _, a := range g.Assets </span><span class="cov0" title="0">{
                if a.Ext == ".jpg" || a.Ext == ".jpeg" </span><span class="cov0" title="0">{
                        keep++
                }</span> else<span class="cov0" title="0"> {
                        removedAssets = append(removedAssets, a)
                }</span>
        }
        <span class="cov0" title="0">if keep &gt; 0 </span><span class="cov0" title="0">{
                for _, a := range removedAssets </span><span class="cov0" title="0">{
                        g.RemoveAsset(a, "Keep only HEIC files in HEIC/JPEG group")
                }</span>
        }
        <span class="cov0" title="0">if len(g.Assets) &lt; 2 </span><span class="cov0" title="0">{
                g.Grouping = assets.GroupByNone
        }</span>
        <span class="cov0" title="0">return g</span>
}

func groupHeicJpgStackHeic(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByHeicJpg </span><span class="cov0" title="0">{
                return g
        }</span>
        // Set the cover index to the first HEIC file
        <span class="cov8" title="1">for i, a := range g.Assets </span><span class="cov8" title="1">{
                if a.Ext == ".heic" </span><span class="cov8" title="1">{
                        g.CoverIndex = i
                        break</span>
                }
        }
        <span class="cov8" title="1">return g</span>
}

func groupHeicJpgStackJPG(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByHeicJpg </span><span class="cov0" title="0">{
                return g
        }</span>
        // Set the cover index to the first JPEG file
        <span class="cov8" title="1">for i, a := range g.Assets </span><span class="cov8" title="1">{
                if a.Ext == ".jpg" || a.Ext == ".jpeg" </span><span class="cov8" title="1">{
                        g.CoverIndex = i
                        break</span>
                }
        }
        <span class="cov8" title="1">return g</span>
}

func (h *HeicJpgFlag) Set(value string) error <span class="cov0" title="0">{
        switch strings.ToLower(value) </span>{
        case "":<span class="cov0" title="0">
                *h = HeicJpgNothing</span>
        case "keepheic":<span class="cov0" title="0">
                *h = HeicJpgKeepHeic</span>
        case "keepjpg":<span class="cov0" title="0">
                *h = HeicJpgKeepJPG</span>
        case "stackcoverheic":<span class="cov0" title="0">
                *h = HeicJpgStackHeic</span>
        case "stackcoverjpg":<span class="cov0" title="0">
                *h = HeicJpgStackJPG</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid value %q for HeicJpgFlag", value)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (h HeicJpgFlag) String() string <span class="cov0" title="0">{
        switch h </span>{
        case HeicJpgNothing:<span class="cov0" title="0">
                return ""</span>
        case HeicJpgKeepHeic:<span class="cov0" title="0">
                return "KeepHeic"</span>
        case HeicJpgKeepJPG:<span class="cov0" title="0">
                return "KeepJPG"</span>
        case HeicJpgStackHeic:<span class="cov0" title="0">
                return "StackCoverHeic"</span>
        case HeicJpgStackJPG:<span class="cov0" title="0">
                return "StackCoverJPG"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

func (h HeicJpgFlag) Type() string <span class="cov0" title="0">{
        return "HeicJpgFlag"
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package filters

import (
        "fmt"
        "strings"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/filetypes"
)

type RawJPGFlag int

const (
        RawJPGNothing  RawJPGFlag = iota
        RawJPGKeepRaw             // Keep only raw files
        RawJPGKeepJPG             // Keep only JPEG files
        RawJPGStackRaw            // Stack raw and JPEG files, with the raw file as the cover
        RawJPGStackJPG            // Stack raw and JPEG files, with the JPEG file as the cover
)

func (r RawJPGFlag) GroupFilter() Filter <span class="cov0" title="0">{
        switch r </span>{
        case RawJPGNothing:<span class="cov0" title="0">
                return unGroupRawJPGNothing</span>
        case RawJPGKeepRaw:<span class="cov0" title="0">
                return groupRawJPGKeepRaw</span>
        case RawJPGKeepJPG:<span class="cov0" title="0">
                return groupRawJPGKeepJPG</span>
        case RawJPGStackRaw:<span class="cov0" title="0">
                return groupRawJPGStackRaw</span>
        case RawJPGStackJPG:<span class="cov0" title="0">
                return groupRawJPGStackJPG</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func unGroupRawJPGNothing(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByRawJpg </span><span class="cov8" title="1">{
                return g
        }</span>
        <span class="cov8" title="1">g.Grouping = assets.GroupByNone
        return g</span>
}

func groupRawJPGKeepRaw(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByRawJpg </span><span class="cov0" title="0">{
                return g
        }</span>
        // Keep only raw files
        <span class="cov8" title="1">removedAssets := []*assets.Asset{}
        keep := 0
        for _, a := range g.Assets </span><span class="cov8" title="1">{
                if filetypes.IsRawFile(a.Ext) </span><span class="cov8" title="1">{
                        keep++
                }</span> else<span class="cov8" title="1"> {
                        removedAssets = append(removedAssets, a)
                }</span>
        }
        <span class="cov8" title="1">if keep &gt; 0 </span><span class="cov8" title="1">{
                for _, a := range removedAssets </span><span class="cov8" title="1">{
                        g.RemoveAsset(a, "Keep only RAW files in RAW/JPEG group")
                }</span>
        }
        <span class="cov8" title="1">if len(g.Assets) &lt; 2 </span><span class="cov8" title="1">{
                g.Grouping = assets.GroupByNone
        }</span>
        <span class="cov8" title="1">return g</span>
}

func groupRawJPGKeepJPG(g *assets.Group) *assets.Group <span class="cov8" title="1">{
        if g.Grouping != assets.GroupByRawJpg </span><span class="cov0" title="0">{
                return g
        }</span>
        // Keep only JPEG files
        <span class="cov8" title="1">removedAssets := []*assets.Asset{}
        keep := 0
        for _, a := range g.Assets </span><span class="cov8" title="1">{
                if a.Ext == ".jpg" || a.Ext == ".jpeg" </span><span class="cov8" title="1">{
                        keep++
                }</span> else<span class="cov8" title="1"> {
                        removedAssets = append(removedAssets, a)
                }</span>
        }
        <span class="cov8" title="1">if keep &gt; 0 </span><span class="cov8" title="1">{
                for _, a := range removedAssets </span><span class="cov8" title="1">{
                        g.RemoveAsset(a, "Keep only JPEG files in RAW/JPEG group")
                }</span>
        }
        <span class="cov8" title="1">if len(g.Assets) &lt; 2 </span><span class="cov8" title="1">{
                g.Grouping = assets.GroupByNone
        }</span>
        <span class="cov8" title="1">return g</span>
}

func groupRawJPGStackRaw(g *assets.Group) *assets.Group <span class="cov0" title="0">{
        if g.Grouping != assets.GroupByRawJpg </span><span class="cov0" title="0">{
                return g
        }</span>
        // Set the cover index to the first RAW file
        <span class="cov0" title="0">for i, a := range g.Assets </span><span class="cov0" title="0">{
                if filetypes.IsRawFile(a.Ext) </span><span class="cov0" title="0">{
                        g.CoverIndex = i
                        break</span>
                }
        }
        <span class="cov0" title="0">return g</span>
}

func groupRawJPGStackJPG(g *assets.Group) *assets.Group <span class="cov0" title="0">{
        if g.Grouping != assets.GroupByRawJpg </span><span class="cov0" title="0">{
                return g
        }</span>
        // Set the cover index to the first JPEG file
        <span class="cov0" title="0">for i, a := range g.Assets </span><span class="cov0" title="0">{
                if a.Ext == ".jpg" || a.Ext == ".jpeg" </span><span class="cov0" title="0">{
                        g.CoverIndex = i
                        break</span>
                }
        }
        <span class="cov0" title="0">return g</span>
}

func (r *RawJPGFlag) Set(value string) error <span class="cov0" title="0">{
        switch strings.ToLower(value) </span>{
        case "":<span class="cov0" title="0">
                *r = RawJPGNothing</span>
        case "keepraw":<span class="cov0" title="0">
                *r = RawJPGKeepRaw</span>
        case "keepjpg":<span class="cov0" title="0">
                *r = RawJPGKeepJPG</span>
        case "stackcoverraw":<span class="cov0" title="0">
                *r = RawJPGStackRaw</span>
        case "stackcoverjpg":<span class="cov0" title="0">
                *r = RawJPGStackJPG</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid value %q for RawJPGFlag", value)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r RawJPGFlag) String() string <span class="cov0" title="0">{
        switch r </span>{
        case RawJPGNothing:<span class="cov0" title="0">
                return ""</span>
        case RawJPGKeepRaw:<span class="cov0" title="0">
                return "KeepRaw"</span>
        case RawJPGKeepJPG:<span class="cov0" title="0">
                return "KeepJPG"</span>
        case RawJPGStackRaw:<span class="cov0" title="0">
                return "StackCoverRaw"</span>
        case RawJPGStackJPG:<span class="cov0" title="0">
                return "StackCoverJPG"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

func (r RawJPGFlag) Type() string <span class="cov0" title="0">{
        return "RawJPGFlag"
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package filters

import (
        "github.com/simulot/immich-go/internal/assets"
)

/*
Applies filters to a group of assets.
*/

type Filter func(g *assets.Group) *assets.Group

func ApplyFilters(g *assets.Group, filters ...Filter) *assets.Group <span class="cov0" title="0">{
        if g.Grouping != assets.GroupByNone </span><span class="cov0" title="0">{
                for _, f := range filters </span><span class="cov0" title="0">{
                        g = f(g)
                }</span>
        }
        <span class="cov0" title="0">return g</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package cachereader

import (
        "io"
        "os"
        "path/filepath"

        "github.com/simulot/immich-go/internal/fshelper/debugfiles"
        "github.com/simulot/immich-go/internal/fshelper/osfs"
        "github.com/simulot/immich-go/internal/loghelper"
)

// CacheReader is a reader that caches the data in a temporary file to allow multiple reads
type CacheReader struct {
        tmpFile      osfs.OSFS //*os.File // tmpFile is the temporary file or the original file
        name         string
        shouldRemove bool
}

// NewCacheReader creates a new CacheReader from an io.ReadCloser
// When the reader is an os.File, it will be used directly
// Otherwise, the content will be copied into a temporary file, and the original reader will be closed
func NewCacheReader(name string, rc io.ReadCloser) (*CacheReader, error) <span class="cov8" title="1">{
        var err error
        c := &amp;CacheReader{}
        if f, ok := rc.(osfs.OSFS); ok </span><span class="cov8" title="1">{
                c.name = f.Name()
                c.tmpFile = f
        }</span> else<span class="cov8" title="1"> {
                d := os.Getenv("IMMICHGO_TEMPDIR")
                if d == "" </span><span class="cov8" title="1">{
                        d, err = os.UserCacheDir()
                        if err != nil </span><span class="cov0" title="0">{
                                d = os.TempDir()
                        }</span>
                }
                <span class="cov8" title="1">d = filepath.Join(d, "immich-go", "temp")

                err = os.MkdirAll(d, 0o700)
                if err != nil </span><span class="cov0" title="0">{
                        d = os.TempDir()
                }</span>
                <span class="cov8" title="1">c.tmpFile, err = os.CreateTemp(d, "immich-go_*")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">debugfiles.TrackOpenFile(c.tmpFile, c.tmpFile.Name())
                c.name = c.tmpFile.Name()
                // be sure to copy the reader content into the temporary file
                _, err = io.Copy(c.tmpFile, rc)
                if err != nil </span><span class="cov0" title="0">{
                        c.tmpFile.Close()
                        _ = os.Remove(c.name)
                        return nil, err
                }</span>
                <span class="cov8" title="1">rc.Close()
                debugfiles.TrackCloseFile(rc)
                c.shouldRemove = true</span>
        }
        <span class="cov8" title="1">return c, err</span>
}

// OpenFile creates a new file handler based on the temporary file
func (cr *CacheReader) OpenFile() (*tempFile, error) <span class="cov8" title="1">{
        f, err := os.Open(cr.name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">debugfiles.TrackOpenFile(f, cr.name)
        return &amp;tempFile{File: f, cr: cr}, nil</span>
}

// Close closes the temporary file only if it was created by NewCacheReader
func (cr *CacheReader) Close() error <span class="cov8" title="1">{
        debugfiles.TrackCloseFile(cr.tmpFile)
        err := cr.tmpFile.Close()
        if err == nil &amp;&amp; cr.shouldRemove </span><span class="cov8" title="1">{
                // the source is already closed
                loghelper.Debug("CacheReader: remove temporary file", "name", cr.name)
                return os.Remove(cr.name)
        }</span>
        <span class="cov8" title="1">return err</span>
}

type tempFile struct {
        *os.File
        cr *CacheReader
}

func (t *tempFile) Close() error <span class="cov8" title="1">{
        debugfiles.TrackCloseFile(t.File)
        err := t.File.Close()
        return err
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package debugfiles

import (
        "io"
        "log/slog"
        "runtime"
        "strings"
        "sync/atomic"

        "github.com/simulot/immich-go/internal/gen/syncmap"
)

type _fileOpenTacker struct {
        name       string
        sourceFile string
        line       int
}

func (f _fileOpenTacker) LogValue() slog.Value <span class="cov0" title="0">{
        source := f.sourceFile
        if p := strings.Index(source, "immich-go/"); p &gt; 0 </span><span class="cov0" title="0">{
                source = source[p:]
        }</span>
        <span class="cov0" title="0">return slog.GroupValue(
                slog.String("name", f.name),
                slog.String("sourceFile", source),
                slog.Int("line", f.line),
        )</span>
}

type _fileTracker struct {
        openFiles       *syncmap.SyncMap[io.Closer, _fileOpenTacker]
        countOpenFiles  int64
        countCloseFiles int64
        log             *slog.Logger
}

var fileTracker *_fileTracker

func EnableTrackFiles(log *slog.Logger) <span class="cov0" title="0">{
        fileTracker = &amp;_fileTracker{
                openFiles: syncmap.New[io.Closer, _fileOpenTacker](),
                log:       log,
        }
        fileTracker.log.Debug("enable track files")
}</span>

func TrackOpenFile(c io.Closer, name string) <span class="cov0" title="0">{
        if fileTracker != nil </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;fileTracker.countOpenFiles, 1)
                t := _fileOpenTacker{
                        name: name,
                }
                _, file, line, ok := runtime.Caller(1)
                if ok </span><span class="cov0" title="0">{
                        t.sourceFile = file
                        t.line = line
                }</span>

                <span class="cov0" title="0">fileTracker.openFiles.Store(c, t)
                fileTracker.log.Debug("open file", "file", t)</span>
        }
}

func TrackCloseFile(c io.Closer) <span class="cov0" title="0">{
        if fileTracker != nil </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;fileTracker.countCloseFiles, 1)
                t, ok := fileTracker.openFiles.LoadAndDelete(c)
                if !ok </span><span class="cov0" title="0">{
                        fileTracker.log.Error("file was not tracked", "file", c)
                }</span>
                <span class="cov0" title="0">fileTracker.log.Debug("close file", "file", t)</span>
        }
}

func ReportTrackedFiles() <span class="cov0" title="0">{
        if fileTracker != nil </span><span class="cov0" title="0">{
                fileTracker.log.Debug("report tracked files", "openFiles", fileTracker.countOpenFiles, "closeFiles", fileTracker.countCloseFiles)
                fileTracker.openFiles.Range(func(key io.Closer, value _fileOpenTacker) bool </span><span class="cov0" title="0">{
                        fileTracker.log.Error("file was not closed", "file", value)
                        return true
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package fshelper

import (
        "errors"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "strings"

        "github.com/simulot/immich-go/internal/fshelper/debugfiles"
)

type FSCanWrite interface {
        OpenFile(name string, flag int, perm fs.FileMode) (WFile, error)
        Mkdir(name string, perm fs.FileMode) error
}

type FSCanMkdirAll interface {
        MkdirAll(path string, perm fs.FileMode) error
}
type FSCanRemove interface {
        Remove(name string) error
}

type FSCanStat interface {
        Stat(name string) (fs.FileInfo, error)
}

type FSCanLink interface {
        Lstat(name string) (fs.FileInfo, error)
        Readlink(name string) (string, error)
        MkSymlink(name, target string) error
}

type FileCanWrite interface {
        Write(b []byte) (ret int, err error)
}

type WFile interface {
        fs.File
        Write(b []byte) (ret int, err error)
}

func OpenFile(fsys fs.FS, name string, flag int, perm fs.FileMode) (WFile, error) <span class="cov0" title="0">{
        if fsys, ok := fsys.(FSCanWrite); ok </span><span class="cov0" title="0">{
                return fsys.OpenFile(name, flag, perm)
        }</span>
        <span class="cov0" title="0">return nil, errors.New("openFile not supported")</span>
}

func Mkdir(fsys fs.FS, name string, perm fs.FileMode) error <span class="cov0" title="0">{
        if fsys, ok := fsys.(FSCanWrite); ok </span><span class="cov0" title="0">{
                return fsys.Mkdir(name, perm)
        }</span>
        <span class="cov0" title="0">return errors.New("mkdir not supported")</span>
}

func MkdirAll(fsys fs.FS, path string, perm fs.FileMode) error <span class="cov0" title="0">{
        if fsys, ok := fsys.(FSCanMkdirAll); ok </span><span class="cov0" title="0">{
                return fsys.MkdirAll(path, perm)
        }</span>
        <span class="cov0" title="0">if fsys, ok := fsys.(FSCanWrite); ok </span><span class="cov0" title="0">{
                parts := strings.Split(path, "/")

                // parts := strings.Split(path, string(filepath.Separator))
                path = ""
                for i := 0; i &lt; len(parts); i++ </span><span class="cov0" title="0">{
                        path = filepath.Join(path, parts[i])
                        if err := fsys.Mkdir(path, perm); err != nil &amp;&amp; !errors.Is(err, os.ErrExist) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                return errors.New("mkdirAll not supported")
        }</span>
}

func Remove(fsys fs.FS, name string) error <span class="cov0" title="0">{
        if fsys, ok := fsys.(FSCanRemove); ok </span><span class="cov0" title="0">{
                return fsys.Remove(name)
        }</span>
        <span class="cov0" title="0">return errors.New("remove not supported")</span>
}

func Stat(fsys fs.FS, name string) (fs.FileInfo, error) <span class="cov0" title="0">{
        if fsys, ok := fsys.(FSCanStat); ok </span><span class="cov0" title="0">{
                return fsys.Stat(name)
        }</span>
        <span class="cov0" title="0">return nil, errors.New("stat not supported")</span>
}

func Lstat(fsys fs.FS, name string) (fs.FileInfo, error) <span class="cov0" title="0">{
        if fsys, ok := fsys.(FSCanLink); ok </span><span class="cov0" title="0">{
                return fsys.Lstat(name)
        }</span>
        <span class="cov0" title="0">return nil, errors.New("lstat not supported")</span>
}

func Readlink(fsys fs.FS, name string) (string, error) <span class="cov0" title="0">{
        if fsys, ok := fsys.(FSCanLink); ok </span><span class="cov0" title="0">{
                return fsys.Readlink(name)
        }</span>
        <span class="cov0" title="0">return "", errors.New("readlink not supported")</span>
}

func WriteFile(fsys fs.FS, name string, r io.Reader) error <span class="cov0" title="0">{
        if fsys, ok := fsys.(FSCanWrite); ok </span><span class="cov0" title="0">{
                f, err := fsys.OpenFile(name, os.O_CREATE|os.O_WRONLY, 0o644)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">debugfiles.TrackOpenFile(f, name)
                defer f.Close()
                defer debugfiles.TrackCloseFile(f)
                if f, ok := f.(FileCanWrite); ok </span><span class="cov0" title="0">{
                        _, err = io.Copy(f, r)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return errors.New("write not supported")</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package fshelper

import (
        "io/fs"
        "log/slog"
)

type FSAndName struct {
        fsys fs.FS
        name string
}

func FSName(fsys fs.FS, name string) FSAndName <span class="cov0" title="0">{
        return FSAndName{fsys: fsys, name: name}
}</span>

func (fn FSAndName) LogValue() slog.Value <span class="cov0" title="0">{
        return slog.StringValue(fn.FullName())
}</span>

func (fn FSAndName) FS() fs.FS <span class="cov0" title="0">{
        return fn.fsys
}</span>

func (fn FSAndName) Name() string <span class="cov0" title="0">{
        return fn.name
}</span>

func (fn FSAndName) FullName() string <span class="cov0" title="0">{
        fsys := fn.fsys
        if fsys, ok := fsys.(NameFS); ok </span><span class="cov0" title="0">{
                return fsys.Name() + ":" + fn.name
        }</span>
        <span class="cov0" title="0">return fn.name</span>
}

func (fn FSAndName) Open() (fs.File, error) <span class="cov0" title="0">{
        return fn.fsys.Open(fn.name)
}</span>

func (fn FSAndName) Stat() (fs.FileInfo, error) <span class="cov0" title="0">{
        return fs.Stat(fn.fsys, fn.name)
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package fshelper

import (
        "fmt"
        "io/fs"
        "os"
        "path"
        "path/filepath"
        "strings"
)

//  GlobWalkFS create a FS that limits the WalkDir function to the
//  list of files that match the glob expression, and cheats to
//  matches *.XMP files in all circumstances
//
//  It implements ReadDir and Stat to filter the file list
//

type GlobWalkFS struct {
        rootFS fs.FS
        dir    string
        parts  []string
}

func NewGlobWalkFS(pattern string) (fs.FS, error) <span class="cov8" title="1">{
        dir, magic := FixedPathAndMagic(pattern)
        if magic == "" </span><span class="cov8" title="1">{
                s, err := os.Stat(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if !s.IsDir() </span><span class="cov8" title="1">{
                        magic = strings.ToLower(path.Base(dir))
                        dir = path.Dir(dir)
                        if dir == "" </span><span class="cov0" title="0">{
                                dir, _ = os.Getwd()
                        }</span>
                        <span class="cov8" title="1">return &amp;GlobWalkFS{
                                rootFS: NewFSWithName(os.DirFS(dir), filepath.Base(dir)),
                                dir:    dir,
                                parts:  []string{magic},
                        }, nil</span>
                } else<span class="cov8" title="1"> {
                        name := filepath.Base(dir)
                        if name == "." </span><span class="cov0" title="0">{
                                name, _ = os.Getwd()
                                name = filepath.Base(name)
                        }</span>

                        <span class="cov8" title="1">return &amp;GlobWalkFS{
                                rootFS: NewFSWithName(os.DirFS(dir), name),
                                dir:    dir,
                        }, nil</span>
                }
        }
        <span class="cov8" title="1">if dir == "" </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span>
        <span class="cov8" title="1">parts := strings.Split(magic, string(os.PathSeparator))
        for i := range parts </span><span class="cov8" title="1">{
                parts[i] = strings.ToLower(parts[i])
        }</span>

        <span class="cov8" title="1">return &amp;GlobWalkFS{
                rootFS: NewFSWithName(os.DirFS(dir), filepath.Base(dir)),
                dir:    dir,
                parts:  parts,
        }, nil</span>
}

// match the current file name with the pattern
// matches files having a path starting by the patten
//
//        ex:  file /path/to/file matches with the pattern /*/to
func (gw GlobWalkFS) match(name string) bool <span class="cov8" title="1">{
        if name == "." </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">parts := strings.Split(name, string(os.PathSeparator))
        for i := range parts </span><span class="cov8" title="1">{
                parts[i] = strings.ToLower(parts[i])
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; min(len(gw.parts), len(parts)); i++ </span><span class="cov8" title="1">{
                if m, err := path.Match(gw.parts[i], parts[i]); err != nil || !m </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">parts = strings.Split(name, string(os.PathSeparator))
        if len(gw.parts) &gt; len(parts) </span><span class="cov8" title="1">{
                s, err := fs.Stat(gw, path.Join(parts[:min(len(gw.parts), len(parts))]...))
                if err != nil || !s.IsDir() </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Open the name only if the name matches with the pattern
func (gw GlobWalkFS) Open(name string) (fs.File, error) <span class="cov0" title="0">{
        return gw.rootFS.Open(name)
}</span>

// Stat the name only if the name matches with the pattern
func (gw GlobWalkFS) Stat(name string) (fs.FileInfo, error) <span class="cov8" title="1">{
        return fs.Stat(gw.rootFS, name)
}</span>

// ReadDir return all DirEntries that match with the pattern or .XMP files
func (gw GlobWalkFS) ReadDir(name string) ([]fs.DirEntry, error) <span class="cov8" title="1">{
        match := gw.match(name)
        if !match </span><span class="cov0" title="0">{
                return nil, fs.ErrNotExist
        }</span>
        <span class="cov8" title="1">entries, err := fs.ReadDir(gw.rootFS, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ReadDir %s: %w", name, err)
        }</span>

        <span class="cov8" title="1">returned := []fs.DirEntry{}
        for _, e := range entries </span><span class="cov8" title="1">{
                p := path.Join(name, e.Name())

                // Always matches .XMP files...
                if !e.IsDir() </span><span class="cov8" title="1">{
                        ext := strings.ToUpper(path.Ext(e.Name()))
                        if ext == ".XMP" </span><span class="cov0" title="0">{
                                returned = append(returned, e)
                                continue</span>
                        }
                }
                <span class="cov8" title="1">match = gw.match(p)
                if match </span><span class="cov8" title="1">{
                        returned = append(returned, e)
                }</span>
        }
        <span class="cov8" title="1">return returned, nil</span>
}

// FSName gives the folder name when argument was .
func (gw GlobWalkFS) Name() string <span class="cov0" title="0">{
        if fsys, ok := gw.rootFS.(NameFS); ok </span><span class="cov0" title="0">{
                return fsys.Name()
        }</span>
        <span class="cov0" title="0">return filepath.Base(gw.dir)</span>
}

// FixedPathAndMagic split the path with the fixed part and the variable part
func FixedPathAndMagic(name string) (string, string) <span class="cov8" title="1">{
        if !HasMagic(name) </span><span class="cov8" title="1">{
                return name, ""
        }</span>
        <span class="cov8" title="1">name = filepath.ToSlash(name)
        parts := strings.Split(name, "/")
        p := 0
        for p = range parts </span><span class="cov8" title="1">{
                if HasMagic(parts[p]) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">fixed := ""
        if name[0] == '/' </span><span class="cov0" title="0">{
                fixed = "/"
        }</span>
        <span class="cov8" title="1">return fixed + path.Join(parts[:p]...), path.Join(parts[p:]...)</span>
}

type FSWithName struct {
        name string
        fsys fs.FS
}

func NewFSWithName(fsys fs.FS, name string) fs.FS <span class="cov8" title="1">{
        return &amp;FSWithName{
                name: name,
                fsys: fsys,
        }
}</span>

func (f FSWithName) Open(name string) (fs.File, error) <span class="cov0" title="0">{
        return f.fsys.Open(name)
}</span>

func (f FSWithName) Name() string <span class="cov0" title="0">{
        return f.name
}</span>

func (f FSWithName) ReadDir(name string) ([]fs.DirEntry, error) <span class="cov8" title="1">{
        if fsys, ok := f.fsys.(fs.ReadDirFS); ok </span><span class="cov8" title="1">{
                return fsys.ReadDir(name)
        }</span>
        <span class="cov0" title="0">return fs.ReadDir(f.fsys, name)</span>
}

func (f FSWithName) Stat(name string) (fs.FileInfo, error) <span class="cov8" title="1">{
        if fsys, ok := f.fsys.(fs.StatFS); ok </span><span class="cov8" title="1">{
                return fsys.Stat(name)
        }</span>
        <span class="cov0" title="0">return fs.Stat(f.fsys, name)</span>
}

func (f FSWithName) ReadFile(name string) ([]byte, error) <span class="cov0" title="0">{
        if fsys, ok := f.fsys.(fs.ReadFileFS); ok </span><span class="cov0" title="0">{
                return fsys.ReadFile(name)
        }</span>
        <span class="cov0" title="0">return fs.ReadFile(f.fsys, name)</span>
}

type NameFS interface {
        Name() string
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package hash

import "encoding/base64"

func Base64Encode(hash []byte, err error) (string, error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(hash), nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package hash

import (
        "crypto/sha1"
        "fmt"
        "io"
        "io/fs"
)

func GetSHA1Hash(r io.Reader) ([]byte, error) <span class="cov0" title="0">{
        h := sha1.New()
        if _, err := io.Copy(h, r); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return h.Sum(nil), nil</span>
}

func FileSHA1Hash(fsys fs.FS, filePath string) ([]byte, error) <span class="cov0" title="0">{
        f, err := fsys.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't get SHA1: %w", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()
        return GetSHA1Hash(f)</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package fshelper

import (
        "runtime"
        "strings"
)

// hasMeta reports whether path contains any of the magic characters
// recognized by Match.
// shamelessly copied from stdlib/os
func HasMagic(path string) bool <span class="cov8" title="1">{
        magicChars := `*?[`
        if runtime.GOOS != "windows" </span><span class="cov8" title="1">{
                magicChars = `*?[\`
        }</span>
        <span class="cov8" title="1">return strings.ContainsAny(path, magicChars)</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package osfs

import (
        "io/fs"
        "os"
        "path/filepath"

        "github.com/simulot/immich-go/internal/fshelper"
        "github.com/simulot/immich-go/internal/fshelper/debugfiles"
)

/*
  Define a file system that can write, remove, stats,etc...
*/

func DirFS(name string) fs.FS <span class="cov0" title="0">{
        return dirFS(name)
}</span>

// check that dirFS implements the interfaces
var (
        _ fshelper.FSCanWrite = dirFS("")
        // _ fshelper.FSCanMkdirAll = dirFS("")
        _ fshelper.FSCanRemove = dirFS("")
        _ fshelper.FSCanStat   = dirFS("")
        _ fshelper.FSCanLink   = dirFS("")
)

type dirFS string

func (dir dirFS) Open(name string) (fs.File, error) <span class="cov0" title="0">{
        f, err := os.Open(filepath.Join(string(dir), name))
        if err != nil </span><span class="cov0" title="0">{
                debugfiles.TrackOpenFile(f, name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (dir dirFS) Stat(name string) (fs.FileInfo, error) <span class="cov0" title="0">{
        return os.Stat(filepath.Join(string(dir), name))
}</span>

func (dir dirFS) OpenFile(name string, flag int, perm fs.FileMode) (fshelper.WFile, error) <span class="cov0" title="0">{
        f, err := os.OpenFile(filepath.Join(string(dir), name), flag, perm)
        if err != nil </span><span class="cov0" title="0">{
                debugfiles.TrackOpenFile(f, name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (dir dirFS) Mkdir(name string, perm fs.FileMode) error <span class="cov0" title="0">{
        return os.Mkdir(filepath.Join(string(dir), name), perm)
}</span>

func (dir dirFS) Readlink(name string) (string, error) <span class="cov0" title="0">{
        return os.Readlink(filepath.Join(string(dir), name))
}</span>

func (dir dirFS) Lstat(name string) (fs.FileInfo, error) <span class="cov0" title="0">{
        return os.Lstat(filepath.Join(string(dir), name))
}</span>

func (dir dirFS) MkSymlink(name, target string) error <span class="cov0" title="0">{
        return os.Symlink(filepath.Join(string(dir), name), filepath.Join(string(dir), target))
}</span>

func (dir dirFS) Remove(name string) error <span class="cov0" title="0">{
        return os.Remove(filepath.Join(string(dir), name))
}</span>

type OSFS interface {
        fs.File
        Name() string
        ReadAt(b []byte, off int64) (n int, err error)
        Seek(offset int64, whence int) (ret int64, err error)
        Stat() (fs.FileInfo, error)
        Write(b []byte) (n int, err error)
        WriteAt(b []byte, off int64) (n int, err error)
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package fshelper

import (
        "errors"
        "fmt"
        "io/fs"
        "path/filepath"
        "strings"

        zipname "github.com/simulot/immich-go/internal/fshelper/zipName"
)

// ParsePath return a list of FS bases on args
//
// Zip files are opened and returned as FS
// Manage wildcards in path
//
// TODO: Implement a tgz reader for non google-photos archives

func ParsePath(args []string) ([]fs.FS, error) <span class="cov0" title="0">{
        var errs error
        fsyss := []fs.FS{}

        for _, a := range args </span><span class="cov0" title="0">{
                a = filepath.ToSlash(a)
                files, err := expandNames(a)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                        lowF := strings.ToLower(f)
                        switch </span>{
                        case strings.HasSuffix(lowF, ".tgz") || strings.HasSuffix(lowF, ".tar.gz"):<span class="cov0" title="0">
                                errs = errors.Join(fmt.Errorf("immich-go can't use tgz archives: %s", filepath.Base(a)))</span>
                        case strings.HasSuffix(lowF, ".zip"):<span class="cov0" title="0">
                                fsys, err := zipname.OpenReader(f) //   zip.OpenReader(f)
                                if err != nil </span><span class="cov0" title="0">{
                                        errs = errors.Join(errs, fmt.Errorf("%s: %w", a, err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">fsyss = append(fsyss, fsys)</span>
                        default:<span class="cov0" title="0">
                                fsys, err := NewGlobWalkFS(f)
                                if err != nil </span><span class="cov0" title="0">{
                                        errs = errors.Join(errs, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">fsyss = append(fsyss, fsys)</span>
                        }
                }
        }
        <span class="cov0" title="0">if errs != nil </span><span class="cov0" title="0">{
                return nil, errs
        }</span>
        <span class="cov0" title="0">return fsyss, nil</span>
}

func expandNames(name string) ([]string, error) <span class="cov0" title="0">{
        if HasMagic(name) </span><span class="cov0" title="0">{
                return filepath.Glob(name)
        }</span>
        <span class="cov0" title="0">return []string{name}, nil</span>
}

// CloseFSs closes each FS that provides a Close() error  interface
func CloseFSs(fsyss []fs.FS) error <span class="cov0" title="0">{
        var errs error
        for _, fsys := range fsyss </span><span class="cov0" title="0">{
                if closer, ok := fsys.(interface{ Close() error }); ok </span><span class="cov0" title="0">{
                        errs = errors.Join(errs, closer.Close())
                }</span>
        }
        <span class="cov0" title="0">return errs</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package fshelper

import (
        "encoding/json"
        "io/fs"
)

// readJSON reads a JSON file from the provided file system (fs.FS)
// with the given name and unmarshals it into the provided type T.

func ReadJSON[T any](fsys fs.FS, name string) (*T, error) <span class="cov0" title="0">{
        var object T
        b, err := fs.ReadFile(fsys, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(b, &amp;object)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;object, nil</span>
}

func UnmarshalJSON[T any](b []byte) (*T, error) <span class="cov0" title="0">{
        var object T
        err := json.Unmarshal(b, &amp;object)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;object, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package fshelper

import "io"

type teeReadCloser struct {
        r io.ReadCloser
        w io.Writer
}

func (t *teeReadCloser) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        n, err = t.r.Read(p)
        if n &gt; 0 </span><span class="cov0" title="0">{
                if n, err := t.w.Write(p[:n]); err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (t *teeReadCloser) Close() error <span class="cov0" title="0">{
        return t.r.Close()
}</span>

func TeeReadCloser(r io.ReadCloser, w io.Writer) io.ReadCloser <span class="cov0" title="0">{
        return &amp;teeReadCloser{r: r, w: w}
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package zipname

import (
        stdZip "archive/zip"
        "os"
        "path/filepath"
        "strings"

        "github.com/simulot/immich-go/internal/fshelper/debugfiles"
)

type ZipReadCloser struct {
        *stdZip.Reader
        f    *os.File
        name string
}

func OpenReader(name string) (*ZipReadCloser, error) <span class="cov0" title="0">{
        f, err := os.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">s, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if s.IsDir() </span><span class="cov0" title="0">{
                return nil, stdZip.ErrFormat
        }</span>
        <span class="cov0" title="0">z, err := stdZip.NewReader(f, s.Size())
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">debugfiles.TrackOpenFile(f, name)
        name = filepath.Base(name)
        name = strings.TrimSuffix(name, filepath.Ext(name))
        return &amp;ZipReadCloser{
                Reader: z,
                name:   name,
                f:      f,
        }, nil</span>
}

func (z ZipReadCloser) Close() error <span class="cov0" title="0">{
        debugfiles.TrackCloseFile(z.f)
        return z.f.Close()
}</span>

func (z ZipReadCloser) Name() string <span class="cov0" title="0">{
        return z.name
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package gen

import (
        "sort"
        "sync"

        "golang.org/x/exp/constraints"
)

func MapKeys[K comparable, T any](m map[K]T) []K <span class="cov0" title="0">{
        r := make([]K, len(m))
        i := 0
        for k := range m </span><span class="cov0" title="0">{
                r[i] = k
                i++
        }</span>
        <span class="cov0" title="0">return r</span>
}

func MapKeysSorted[K constraints.Ordered, T any](m map[K]T) []K <span class="cov0" title="0">{
        r := make([]K, len(m))
        i := 0
        for k := range m </span><span class="cov0" title="0">{
                r[i] = k
                i++
        }</span>
        <span class="cov0" title="0">sort.Slice(r, func(i, j int) bool </span><span class="cov0" title="0">{
                return r[i] &lt; r[j]
        }</span>)
        <span class="cov0" title="0">return r</span>
}

func MapFilterKeys[K comparable, T any](m map[K]T, f func(i T) bool) []K <span class="cov0" title="0">{
        r := make([]K, 0, len(m))
        for k, v := range m </span><span class="cov0" title="0">{
                if f(v) </span><span class="cov0" title="0">{
                        r = append(r, k)
                }</span>
        }
        <span class="cov0" title="0">return r</span>
}

type SyncMap[K comparable, V any] struct {
        mu sync.RWMutex
        m  map[K]V
}

func NewSyncMap[K comparable, V any]() *SyncMap[K, V] <span class="cov0" title="0">{
        return &amp;SyncMap[K, V]{m: make(map[K]V)}
}</span>

func (m *SyncMap[K, V]) Load(k K) (V, bool) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        v, ok := m.m[k]
        return v, ok
}</span>

func (m *SyncMap[K, V]) Store(k K, v V) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.m[k] = v
}</span>

func (m *SyncMap[K, V]) Delete(k K) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.m, k)
}</span>

func (m *SyncMap[K, V]) Keys() []K <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        r := make([]K, len(m.m))
        i := 0
        for k := range m.m </span><span class="cov0" title="0">{
                r[i] = k
                i++
        }</span>
        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package gen

func DeleteItem[T comparable](s []T, item T) []T <span class="cov0" title="0">{
        r := make([]T, 0, len(s))
        for i := range s </span><span class="cov0" title="0">{
                if s[i] != item </span><span class="cov0" title="0">{
                        r = append(r, s[i])
                }</span>
        }
        <span class="cov0" title="0">return r</span>
}

func Filter[T any](s []T, f func(i T) bool) []T <span class="cov0" title="0">{
        var r []T
        for _, i := range s </span><span class="cov0" title="0">{
                if f(i) </span><span class="cov0" title="0">{
                        r = append(r, i)
                }</span>
        }
        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package syncmap

// SyncMap is a thread-safe and type-safe map based on sync.Map.

import "sync"

type SyncMap[K comparable, V any] struct {
        m sync.Map
}

// New creates a new SyncMap.
// ex:
// var m *syncmap.SyncMap[string, int]
// m := New[string, int]()
func New[K comparable, V any]() *SyncMap[K, V] <span class="cov0" title="0">{
        return &amp;SyncMap[K, V]{
                m: sync.Map{},
        }
}</span>

// Clear deletes all the entries, resulting in an empty Map.
func (m *SyncMap[K, V]) Clear() <span class="cov0" title="0">{
        m.m.Clear()
}</span>

// CompareAndDelete deletes the entry for key if its value is equal to old.
//
// If there is no current value for key in the map, CompareAndDelete returns false .
func (m *SyncMap[K, V]) CompareAndDelete(key K, old V) bool <span class="cov0" title="0">{
        return m.m.CompareAndDelete(key, old)
}</span>

// CompareAndSwap swaps the old and new values for key
// if the value stored in the map is equal to old.
func (m *SyncMap[K, V]) CompareAndSwap(key K, old V, new V) (swapped bool) <span class="cov0" title="0">{ // nolint: predeclared
        return m.m.CompareAndSwap(key, old, new)
}</span>

// Delete deletes the value for a key.
func (m *SyncMap[K, V]) Delete(key K) <span class="cov0" title="0">{
        m.m.Delete(key)
}</span>

// Load returns the value stored in the map for a key, or a zero value if no value is present.
// The ok result indicates whether value was found in the map.
func (m *SyncMap[K, V]) Load(key K) (V, bool) <span class="cov0" title="0">{
        v, ok := m.m.Load(key)
        if !ok </span><span class="cov0" title="0">{
                var zero V
                return zero, false
        }</span>
        <span class="cov0" title="0">return v.(V), true</span>
}

// LoadAndDelete deletes the value for a key, returning the previous value if any.
// The loaded result reports whether the key was present.

func (m *SyncMap[K, V]) LoadAndDelete(key K) (value V, loaded bool) <span class="cov0" title="0">{
        v, ok := m.m.LoadAndDelete(key)
        if !ok </span><span class="cov0" title="0">{
                var zero V
                return zero, false
        }</span>
        <span class="cov0" title="0">return v.(V), true</span>
}

// LoadOrStore returns the existing value for the key if present.
// Otherwise, it stores and returns the given value.
// The loaded result is true if the value was loaded, false if stored.

func (m *SyncMap[K, V]) LoadOrStore(key K, value V) (V, bool) <span class="cov0" title="0">{
        v, ok := m.m.LoadOrStore(key, value)
        if !ok </span><span class="cov0" title="0">{
                return value, false
        }</span>
        <span class="cov0" title="0">return v.(V), true</span>
}

// Range calls f sequentially for each key and value present in the map.
// If f returns false, range stops the iteration.
//
// Range does not necessarily correspond to any consistent snapshot of the Map's
// contents: no key will be visited more than once, but if the value for any key
// is stored or deleted concurrently (including by f), Range may reflect any
// mapping for that key from any point during the Range call. Range does not
// block other methods on the receiver; even f itself may call any method on m.
//
// Range may be O(N) with the number of elements in the map even if f returns
// false after a constant number of calls.
func (m *SyncMap[K, V]) Range(f func(key K, value V) bool) <span class="cov0" title="0">{
        m.m.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                return f(key.(K), value.(V))
        }</span>)
}

// Store sets the value for a key.
func (m *SyncMap[K, V]) Store(key K, value V) <span class="cov0" title="0">{
        m.m.Store(key, value)
}</span>

// Swap swaps the value for a key and returns the previous value if any.
// The loaded result reports whether the key was present.
func (m *SyncMap[K, V]) Swap(key K, value V) (previous V, loaded bool) <span class="cov0" title="0">{
        v, ok := m.m.Swap(key, value)
        if !ok </span><span class="cov0" title="0">{
                var zero V
                return zero, false
        }</span>
        <span class="cov0" title="0">return v.(V), true</span>
}

// Keys returns all the keys in the map.
func (m *SyncMap[K, V]) Keys() []K <span class="cov0" title="0">{
        all := make([]K, 0)
        m.Range(func(key K, value V) bool </span><span class="cov0" title="0">{
                all = append(all, key)
                return true
        }</span>)
        <span class="cov0" title="0">return all</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package burst

import (
        "context"
        "time"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/filetypes"
        "golang.org/x/exp/constraints"
)

const frameInterval = 500 * time.Millisecond

// Group groups photos taken within a period of less than 1 second with a digital camera.
// This addresses photos taken with a digital camera when there isn't any burst indication in the file namee
//
// Ex: IMG_0001.JPG, IMG_0002.JPG, etc. and the date taken is different by a fraction of second
// Ex: IMG_0001.JPG, IMG_0001.RAW, IMG_0002.JPG, IMG_0002.RAW, etc.
//
// Edited images, images identified as as burst already are not considered.
// The in channel receives assets sorted by date taken.
func Group(ctx context.Context, in &lt;-chan *assets.Asset, out chan&lt;- *assets.Asset, gOut chan&lt;- *assets.Group) <span class="cov8" title="1">{
        var currentGroup []*assets.Asset
        var lastTaken time.Time

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case a, ok := &lt;-in:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                if len(currentGroup) &gt; 0 </span><span class="cov8" title="1">{
                                        sendBurstGroup(ctx, out, gOut, currentGroup)
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }

                        // exclude movies, edited or burst images
                        // exclude images without a date taken
                        // exclude images taken more than 500ms apart
                        <span class="cov8" title="1">ni := a.NameInfo
                        dontGroupMe := ni.Type != filetypes.TypeImage ||
                                a.CaptureDate.IsZero() ||
                                ni.Kind == assets.KindBurst ||
                                ni.Kind == assets.KindEdited ||
                                abs(a.CaptureDate.Sub(lastTaken)) &gt; frameInterval

                        if dontGroupMe </span><span class="cov8" title="1">{
                                if len(currentGroup) &gt; 0 </span><span class="cov8" title="1">{
                                        sendBurstGroup(ctx, out, gOut, currentGroup)
                                }</span>
                                <span class="cov8" title="1">currentGroup = []*assets.Asset{a}
                                lastTaken = a.CaptureDate</span>
                        } else<span class="cov8" title="1"> {
                                currentGroup = append(currentGroup, a)
                                lastTaken = a.CaptureDate
                        }</span>
                }
        }
}

// abs returns the absolute value of a given integer.
func abs[T constraints.Integer](x T) T <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}

func sendBurstGroup(ctx context.Context, out chan&lt;- *assets.Asset, outg chan&lt;- *assets.Group, as []*assets.Asset) <span class="cov8" title="1">{
        if len(as) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if len(as) &lt; 2 </span><span class="cov8" title="1">{
                select </span>{
                case out &lt;- as[0]:<span class="cov8" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">g := assets.NewGroup(assets.GroupByBurst, as...)
        g.CoverIndex = 0 // Assuming the first asset is the cover

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        case outg &lt;- g:<span class="cov8" title="1"></span>
        }
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package epsonfastfoto

import (
        "context"
        "regexp"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/filetypes"
)

var epsonFastFotoRegex = regexp.MustCompile(`^(.*_\d+)(_[ab])?(\.[a-z]+)$`)

type Group struct {
        lastRadical string
        coverIndex  int
        group       []*assets.Asset
}

func (g Group) Group(ctx context.Context, in &lt;-chan *assets.Asset, out chan&lt;- *assets.Asset, gOut chan&lt;- *assets.Group) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case a, ok := &lt;-in:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                g.sendGroup(ctx, out, gOut)
                                return
                        }</span>
                        <span class="cov8" title="1">ni := a.NameInfo
                        matches := epsonFastFotoRegex.FindStringSubmatch(a.File.Name())
                        if matches == nil </span><span class="cov0" title="0">{
                                g.sendGroup(ctx, out, gOut)
                                select </span>{
                                case out &lt;- a:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                                }
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov8" title="1">radical := matches[1]
                        // exclude movies,  burst images
                        dontGroupMe := ni.Type != filetypes.TypeImage ||
                                ni.Kind == assets.KindBurst

                        if dontGroupMe </span><span class="cov0" title="0">{
                                g.sendGroup(ctx, out, gOut)
                                continue</span>
                        }
                        <span class="cov8" title="1">if g.lastRadical != radical </span><span class="cov8" title="1">{
                                g.sendGroup(ctx, out, gOut)
                        }</span>
                        <span class="cov8" title="1">g.group = append(g.group, a)
                        g.lastRadical = radical
                        if matches[2] == "_a" </span><span class="cov8" title="1">{
                                g.coverIndex = len(g.group) - 1
                        }</span>
                }
        }
}

func (g *Group) sendGroup(ctx context.Context, out chan&lt;- *assets.Asset, outg chan&lt;- *assets.Group) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                g.group = nil
                g.lastRadical = ""
                g.coverIndex = 0
        }</span>()
        <span class="cov8" title="1">if len(g.group) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if len(g.group) &lt; 2 </span><span class="cov8" title="1">{
                select </span>{
                case out &lt;- g.group[0]:<span class="cov8" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">gr := assets.NewGroup(assets.GroupByOther, g.group...)
        gr.CoverIndex = g.coverIndex

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        case outg &lt;- gr:<span class="cov8" title="1"></span>
        }
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package groups

import (
        "context"
        "sync"

        "github.com/simulot/immich-go/internal/assets"
)

// A group of assets link assets that are linked together. This
// allows a specific treatment of the group.
//
// Groups can be:
//   - A photo and a movie as for motion picture or live photo
//   - A couple of RAW and JPG image
//   - A burst of photos
//   - A photo and its edited version
//
// A group has an asset that represents the group:
//   - for Raw/JPG --&gt; the JPG
//         - for Bursts: the photo identified as the cover
//   - not relevant for live photo
//
// All group's assets can be added to 0 or more albums

// Grouper is an interface for a type that can group assets.
type Grouper func(ctx context.Context, in &lt;-chan *assets.Asset, out chan&lt;- *assets.Asset, gOut chan&lt;- *assets.Group)

/*
A grouper pipeline is a chain of groupers that process assets in sequence.
The 1st grouper should be the one that detects the most specific groups, and the last one should detect the most generic ones.
This way, the most specific groups are detected first, and the most generic ones are detected last.
*/

type GrouperPipeline struct {
        groupers []Grouper
}

func NewGrouperPipeline(ctx context.Context, gs ...Grouper) *GrouperPipeline <span class="cov8" title="1">{
        g := &amp;GrouperPipeline{
                groupers: gs,
        }
        return g
}</span>

// PipeGrouper groups assets in a pipeline of groupers.
// Group opens and closes intermediate channels as required.
func (p *GrouperPipeline) PipeGrouper(ctx context.Context, in chan *assets.Asset) chan *assets.Group <span class="cov8" title="1">{
        // Create channels
        gOut := make(chan *assets.Group) // output channel for groups
        out := make(chan *assets.Asset)  // output channel for the last grouper

        inChans := make([]chan *assets.Asset, len(p.groupers))
        outChans := make([]chan *assets.Asset, len(p.groupers))

        // initialize channels for each grouper
        for i := range p.groupers </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        inChans[i] = in
                }</span> else<span class="cov8" title="1"> {
                        inChans[i] = outChans[i-1]
                }</span>
                <span class="cov8" title="1">if i &lt; len(p.groupers)-1 </span><span class="cov8" title="1">{
                        outChans[i] = make(chan *assets.Asset) // intermediate channels between groupers
                }</span> else<span class="cov8" title="1"> {
                        outChans[i] = out
                }</span>
        }

        // call groupers with the appropriate channels
        <span class="cov8" title="1">wg := sync.WaitGroup{}
        for i := range p.groupers </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(i int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        p.groupers[i](ctx, inChans[i], outChans[i], gOut)
                        if i &lt; len(p.groupers)-1 </span><span class="cov8" title="1">{
                                close(outChans[i]) // close intermediate channels
                        }</span>
                }(i)
        }

        // wait for all groupers to finish and close the output channel
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(out)
        }</span>()

        // groups standalone assets
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer close(gOut)
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov8" title="1">
                                a, ok := &lt;-out
                                if !ok </span><span class="cov8" title="1">{
                                        return
                                }</span>
                                <span class="cov8" title="1">if a != nil </span><span class="cov8" title="1">{
                                        gOut &lt;- assets.NewGroup(assets.GroupByNone, a)
                                }</span>
                        }
                }
        }()

        <span class="cov8" title="1">return gOut</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package series

/* This package implements a group builder for series of images.
A series is a group of images with the same radical part in their name.
*/

import (
        "context"
        "time"

        "github.com/simulot/immich-go/internal/assets"
        "github.com/simulot/immich-go/internal/filetypes"
        "golang.org/x/exp/constraints"
)

const (
        threshold = 1 * time.Second
)

// Group groups assets by series, based on the radical part of the name.
// the in channel receives assets sorted by radical, then by date taken.
func Group(ctx context.Context, in &lt;-chan *assets.Asset, out chan&lt;- *assets.Asset, gOut chan&lt;- *assets.Group) <span class="cov8" title="1">{
        currentRadical := ""
        currentCaptureDate := time.Time{}
        currentGroup := []*assets.Asset{}

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case a, ok := &lt;-in:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                if len(currentGroup) &gt; 0 </span><span class="cov8" title="1">{
                                        sendGroup(ctx, out, gOut, currentGroup)
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }
                        <span class="cov8" title="1">r := a.Radical
                        cd := a.CaptureDate
                        if r != currentRadical || a.Type != filetypes.TypeImage || cd.IsZero() || abs(cd.Sub(currentCaptureDate)) &gt; threshold </span><span class="cov8" title="1">{
                                if len(currentGroup) &gt; 0 </span><span class="cov8" title="1">{
                                        sendGroup(ctx, out, gOut, currentGroup)
                                        currentGroup = []*assets.Asset{}
                                }</span>
                                <span class="cov8" title="1">currentRadical = r
                                currentCaptureDate = cd</span>
                        }
                        <span class="cov8" title="1">currentGroup = append(currentGroup, a)</span>
                }
        }
}

func sendGroup(ctx context.Context, out chan&lt;- *assets.Asset, outg chan&lt;- *assets.Group, as []*assets.Asset) <span class="cov8" title="1">{
        if len(as) &lt; 2 </span><span class="cov8" title="1">{
                // Not a series
                sendAsset(ctx, out, as)
                return
        }</span>
        <span class="cov8" title="1">grouping := assets.GroupByOther

        gotJPG := false
        gotRAW := false
        gotHEIC := false
        gotMP4 := false
        gotMOV := false

        cover := 0
        // determine if the group is a burst
        for i, a := range as </span><span class="cov8" title="1">{
                gotMP4 = gotMP4 || a.Ext == ".mp4"
                gotMOV = gotMOV || a.Ext == ".mov"
                gotJPG = gotJPG || a.Ext == ".jpg"
                gotRAW = gotRAW || filetypes.IsRawFile(a.Ext)
                gotHEIC = gotHEIC || a.Ext == ".heic" || a.Ext == ".heif"
                if grouping == assets.GroupByOther </span><span class="cov8" title="1">{
                        switch a.Kind </span>{
                        case assets.KindBurst:<span class="cov8" title="1">
                                grouping = assets.GroupByBurst</span>
                        }
                }
                <span class="cov8" title="1">if a.IsCover </span><span class="cov8" title="1">{
                        cover = i
                }</span>
        }

        // If we have only two assets, we can try to group them as raw/jpg or heic/jpg
        <span class="cov8" title="1">if len(as) == 2 </span><span class="cov8" title="1">{
                if grouping == assets.GroupByOther </span><span class="cov8" title="1">{
                        if gotJPG &amp;&amp; gotRAW &amp;&amp; !gotHEIC </span><span class="cov8" title="1">{
                                grouping = assets.GroupByRawJpg
                        }</span> else<span class="cov8" title="1"> if gotJPG &amp;&amp; !gotRAW &amp;&amp; gotHEIC </span><span class="cov8" title="1">{
                                grouping = assets.GroupByHeicJpg
                        }</span> else<span class="cov0" title="0"> if (gotMP4 || gotMOV) &amp;&amp; (gotJPG || gotHEIC) </span><span class="cov0" title="0">{
                                grouping = assets.GroupByNone
                        }</span>
                }
                <span class="cov8" title="1">if grouping == assets.GroupByNone </span><span class="cov0" title="0">{
                        for _, a := range as </span><span class="cov0" title="0">{
                                select </span>{
                                case out &lt;- a:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                        <span class="cov0" title="0">return</span>
                }
        }

        // good to go
        <span class="cov8" title="1">g := assets.NewGroup(grouping, as...)
        g.CoverIndex = cover

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return</span>
        case outg &lt;- g:<span class="cov8" title="1"></span>
        }
}

// sendAsset sends assets of the group as individual assets to the output channel
func sendAsset(ctx context.Context, out chan&lt;- *assets.Asset, assets []*assets.Asset) <span class="cov8" title="1">{
        for _, a := range assets </span><span class="cov8" title="1">{
                select </span>{
                case out &lt;- a:<span class="cov8" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func abs[T constraints.Integer](x T) T <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package immichfs

import (
        "context"
        "io"
        "io/fs"
        "time"

        "github.com/simulot/immich-go/immich"
)

/*
Implement the immichfs package let read assets from an immich server

*/

var _ fs.FS = (*ImmichFS)(nil)

type ImmichFS struct {
        ctx    context.Context
        client immich.ImmichInterface
        url    string
}

// NewImmichFS creates a new ImmichFS using the client
func NewImmichFS(ctx context.Context, url string, client immich.ImmichInterface) *ImmichFS <span class="cov8" title="1">{
        return &amp;ImmichFS{
                ctx:    ctx,
                client: client,
                url:    url,
        }
}</span>

var _ fs.File = (*ImmichFile)(nil)

type ImmichFile struct {
        ctx    context.Context
        cancel func(err error)
        info   *fsFileInfo

        rc io.ReadCloser
}

// Open opens the named file for reading.
// name is the ID of the asset
func (ifs *ImmichFS) Open(name string) (fs.File, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithCancelCause(ifs.ctx)

        fi, err := ifs.Stat(name)
        if err != nil </span><span class="cov0" title="0">{
                cancel(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">rc, err := ifs.client.DownloadAsset(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                cancel(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">file := &amp;ImmichFile{
                ctx:    ctx,
                cancel: cancel,
                info:   fi,
                rc:     rc,
        }
        return file, nil</span>
}

func (ifs *ImmichFS) Name() string <span class="cov0" title="0">{
        return ifs.url
}</span>

// Read reads up to len(b) bytes from the file. It returns the number of bytes read and an error, if any.
func (file *ImmichFile) Read(b []byte) (n int, err error) <span class="cov8" title="1">{
        return file.rc.Read(b)
}</span>

// Close closes the file, rendering it unusable for I/O.
func (file *ImmichFile) Close() error <span class="cov0" title="0">{
        if file.rc != nil </span><span class="cov0" title="0">{
                file.cancel(file.rc.Close())
                file.rc = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Stat returns a FileInfo describing the file.
// name is the ID of the asset
func (file *ImmichFile) Stat() (fs.FileInfo, error) <span class="cov0" title="0">{
        return file.info, nil
}</span>

// Stat returns a FileInfo describing the file.
// Name is the ID of the asset
func (ifs *ImmichFS) Stat(name string) (*fsFileInfo, error) <span class="cov8" title="1">{
        a, err := ifs.client.GetAssetInfo(ifs.ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;fsFileInfo{
                name:    a.OriginalFileName,
                size:    a.ExifInfo.FileSizeInByte,
                mode:    fs.FileMode(0o444), // read-only mode
                modTime: a.ExifInfo.DateTimeOriginal.Unix(),
                isDir:   false,
        }, nil</span>
}

var _ fs.FileInfo = (*fsFileInfo)(nil)

type fsFileInfo struct {
        name    string
        size    int64
        mode    fs.FileMode
        modTime int64
        isDir   bool
}

func (fi *fsFileInfo) Name() string       <span class="cov0" title="0">{ return fi.name }</span>
func (fi *fsFileInfo) Size() int64        <span class="cov0" title="0">{ return fi.size }</span>
func (fi *fsFileInfo) Mode() fs.FileMode  <span class="cov0" title="0">{ return fi.mode }</span>
func (fi *fsFileInfo) ModTime() time.Time <span class="cov0" title="0">{ return time.Unix(fi.modTime, 0) }</span>
func (fi *fsFileInfo) IsDir() bool        <span class="cov0" title="0">{ return fi.isDir }</span>
func (fi *fsFileInfo) Sys() interface{}   <span class="cov0" title="0">{ return nil }</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">package journal

import (
        "strings"
        "sync"
)

type Journal struct {
        mut    sync.Mutex
        counts map[Action]int
        Log    Logger
}

type Action string

const (
        DiscoveredFile     Action = "File"
        ScannedImage       Action = "Scanned image"
        ScannedVideo       Action = "Scanned video"
        Discarded          Action = "Discarded"
        Uploaded           Action = "Uploaded"
        Upgraded           Action = "Server's asset upgraded"
        ERROR              Action = "Error"
        LocalDuplicate     Action = "Local duplicate"
        ServerDuplicate    Action = "Server has photo"
        Stacked            Action = "Stacked"
        ServerBetter       Action = "Server's asset is better"
        Album              Action = "Added to an album"
        LivePhoto          Action = "Live photo"
        FailedVideo        Action = "Failed video"
        Unsupported        Action = "File type not supported"
        Metadata           Action = "Metadata files"
        AssociatedMetadata Action = "Associated with metadata"
        INFO               Action = "Info"
        NotSelected        Action = "Not selected because options"
        ServerError        Action = "Server error"
)

func NewJournal(log Logger) *Journal <span class="cov0" title="0">{
        return &amp;Journal{
                // files:  map[string]Entries{},
                Log:    log,
                counts: map[Action]int{},
        }
}</span>

func (j *Journal) AddEntry(file string, action Action, comment ...string) <span class="cov0" title="0">{
        if j == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">c := strings.Join(comment, ", ")
        if j.Log != nil </span><span class="cov0" title="0">{
                switch action </span>{
                case ERROR, ServerError:<span class="cov0" title="0">
                        j.Log.Error("%-25s: %s: %s", action, file, c)</span>
                case DiscoveredFile:<span class="cov0" title="0">
                        j.Log.Debug("%-25s: %s: %s", action, file, c)</span>
                case Uploaded:<span class="cov0" title="0">
                        j.Log.OK("%-25s: %s: %s", action, file, c)</span>
                default:<span class="cov0" title="0">
                        j.Log.Info("%-25s: %s: %s", action, file, c)</span>
                }
        }
        <span class="cov0" title="0">j.mut.Lock()
        j.counts[action]++
        if action == Upgraded </span><span class="cov0" title="0">{
                j.counts[Uploaded]--
        }</span>
        <span class="cov0" title="0">j.mut.Unlock()</span>
}

func (j *Journal) Report() <span class="cov0" title="0">{
        checkFiles := j.counts[ScannedImage] + j.counts[ScannedVideo] + j.counts[Metadata] + j.counts[Unsupported] + j.counts[FailedVideo] + j.counts[Discarded]
        handledFiles := j.counts[NotSelected] + j.counts[LocalDuplicate] + j.counts[ServerDuplicate] + j.counts[ServerBetter] + j.counts[Uploaded] + j.counts[Upgraded] + j.counts[ServerError]
        j.Log.OK("Scan of the sources:")
        j.Log.OK("%6d files in the input", j.counts[DiscoveredFile])
        j.Log.OK("--------------------------------------------------------")
        j.Log.OK("%6d photos", j.counts[ScannedImage])
        j.Log.OK("%6d videos", j.counts[ScannedVideo])
        j.Log.OK("%6d metadata files", j.counts[Metadata])
        j.Log.OK("%6d files with metadata", j.counts[AssociatedMetadata])
        j.Log.OK("%6d discarded files", j.counts[Discarded])
        j.Log.OK("%6d files having a type not supported", j.counts[Unsupported])
        j.Log.OK("%6d discarded files because in folder failed videos", j.counts[FailedVideo])

        j.Log.OK("%6d input total (difference %d)", checkFiles, j.counts[DiscoveredFile]-checkFiles)
        j.Log.OK("--------------------------------------------------------")

        j.Log.OK("%6d uploaded files on the server", j.counts[Uploaded])
        j.Log.OK("%6d upgraded files on the server", j.counts[Upgraded])
        j.Log.OK("%6d files already on the server", j.counts[ServerDuplicate])
        j.Log.OK("%6d discarded files because of options", j.counts[NotSelected])
        j.Log.OK("%6d discarded files because duplicated in the input", j.counts[LocalDuplicate])
        j.Log.OK("%6d discarded files because server has a better image", j.counts[ServerBetter])
        j.Log.OK("%6d errors when uploading", j.counts[ServerError])

        j.Log.OK("%6d handled total (difference %d)", handledFiles, j.counts[ScannedImage]+j.counts[ScannedVideo]-handledFiles)
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">package journal

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/ttacon/chalk"
)

type Level int

const (
        Fatal Level = iota
        Error
        Warning
        OK
        Info
        Debug
)

func (l Level) String() string <span class="cov0" title="0">{
        switch l </span>{
        case Fatal:<span class="cov0" title="0">
                return "Fatal"</span>
        case Error:<span class="cov0" title="0">
                return "Error"</span>
        case Warning:<span class="cov0" title="0">
                return "Warning"</span>
        case OK:<span class="cov0" title="0">
                return "OK"</span>
        case Info:<span class="cov0" title="0">
                return "Info"</span>
        case Debug:<span class="cov0" title="0">
                return "Debug"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Log Level %d", l)</span>
        }
}

func StringToLevel(s string) (Level, error) <span class="cov0" title="0">{
        s = strings.ToLower(s)
        for l := Fatal; l &lt;= Debug; l++ </span><span class="cov0" title="0">{
                if strings.ToLower(l.String()) == s </span><span class="cov0" title="0">{
                        return l, nil
                }</span>
        }
        <span class="cov0" title="0">return Error, fmt.Errorf("unknown log level: %s", s)</span>
}

var colorLevel = map[Level]string{
        Fatal:   chalk.Red.String(),
        Error:   chalk.Red.String(),
        Warning: chalk.Yellow.String(),
        OK:      chalk.Green.String(),
        Info:    chalk.White.String(),
        Debug:   chalk.Cyan.String(),
}

type Log struct {
        needCR       bool
        needSpace    bool
        displayLevel Level
        noColors     bool
        colorStrings map[Level]string
        debug        bool
        out          io.WriteCloser
}

func NewLogger(displayLevel Level, noColors bool, debug bool) *Log <span class="cov0" title="0">{
        l := Log{
                displayLevel: displayLevel,
                noColors:     noColors,
                colorStrings: map[Level]string{},
                debug:        debug,
                out:          os.Stdout,
        }
        if !noColors </span><span class="cov0" title="0">{
                l.colorStrings = colorLevel
        }</span>
        <span class="cov0" title="0">return &amp;l</span>
}

func (l *Log) Close() error <span class="cov0" title="0">{
        if l.out != os.Stdout </span><span class="cov0" title="0">{
                return l.out.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (l *Log) SetDebugFlag(flag bool) <span class="cov0" title="0">{
        l.debug = flag
}</span>

func (l *Log) SetLevel(level Level) <span class="cov0" title="0">{
        l.displayLevel = level
}</span>

func (l *Log) SetColors(flag bool) <span class="cov0" title="0">{
        if l.out != os.Stdout </span><span class="cov0" title="0">{
                flag = false
        }</span>
        <span class="cov0" title="0">if flag </span><span class="cov0" title="0">{
                l.colorStrings = colorLevel
                l.noColors = false
        }</span> else<span class="cov0" title="0"> {
                l.colorStrings = map[Level]string{}
                l.noColors = true
        }</span>
}

func (l *Log) SetWriter(w io.WriteCloser) <span class="cov0" title="0">{
        if l != nil &amp;&amp; w != nil </span><span class="cov0" title="0">{
                l.out = w
                l.noColors = true
                l.colorStrings = map[Level]string{}
        }</span>
}

func (l *Log) Debug(f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">l.Message(Debug, f, v...)</span>
}

type DebugObject interface {
        DebugObject() any
}

func (l *Log) DebugObject(name string, v any) <span class="cov0" title="0">{
        if l == nil || !l.debug </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if l.out == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if d, ok := v.(DebugObject); ok </span><span class="cov0" title="0">{
                v = d.DebugObject()
        }</span>
        <span class="cov0" title="0">b := bytes.NewBuffer(nil)
        enc := json.NewEncoder(b)
        enc.SetIndent("", " ")
        err := enc.Encode(v)
        if err != nil </span><span class="cov0" title="0">{
                l.Error("can't display object %s: %s", name, err)
                return
        }</span>
        <span class="cov0" title="0">if l.needCR </span><span class="cov0" title="0">{
                fmt.Println()
                l.needCR = false
        }</span>
        <span class="cov0" title="0">l.needSpace = false
        fmt.Fprint(l.out, l.colorStrings[Debug])
        fmt.Fprintf(l.out, "%s:\n%s", name, b.String())
        if !l.noColors </span><span class="cov0" title="0">{
                fmt.Fprint(l.out, chalk.ResetColor)
        }</span>
        <span class="cov0" title="0">fmt.Fprintln(l.out)</span>
}

func (l *Log) Info(f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                fmt.Printf(f, v...)
                fmt.Println()
                return
        }</span>
        <span class="cov0" title="0">l.Message(Info, f, v...)</span>
}

func (l *Log) OK(f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                fmt.Printf(f, v...)
                fmt.Println()
                return
        }</span>
        <span class="cov0" title="0">l.Message(OK, f, v...)</span>
}

func (l *Log) Warning(f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                fmt.Printf(f, v...)
                fmt.Println()
                return
        }</span>
        <span class="cov0" title="0">l.Message(Warning, f, v...)</span>
}

func (l *Log) Error(f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                fmt.Printf(f, v...)
                fmt.Println()
                return
        }</span>
        <span class="cov0" title="0">l.Message(Error, f, v...)</span>
}

func (l *Log) Fatal(f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                fmt.Printf(f, v...)
                fmt.Println()
                return
        }</span>
        <span class="cov0" title="0">l.Message(Fatal, f, v...)</span>
}

func (l *Log) Message(level Level, f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if level &gt; l.displayLevel </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if l.needCR </span><span class="cov0" title="0">{
                fmt.Fprintln(l.out)
                l.needCR = false
        }</span>
        <span class="cov0" title="0">l.needSpace = false
        fmt.Fprint(l.out, l.colorStrings[level])
        fmt.Fprintf(l.out, f, v...)
        if !l.noColors </span><span class="cov0" title="0">{
                fmt.Fprint(l.out, chalk.ResetColor)
        }</span>
        <span class="cov0" title="0">fmt.Fprintln(l.out)</span>
}

func (l *Log) Progress(level Level, f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if level &gt; l.displayLevel </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(l.out, "\r\033[2K"+f, v...)
        l.needCR = true</span>
}

func (l *Log) MessageContinue(level Level, f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if level &gt; l.displayLevel </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if l.needCR </span><span class="cov0" title="0">{
                fmt.Fprintln(l.out)
                l.needCR = false
        }</span>
        <span class="cov0" title="0">if l.needSpace </span><span class="cov0" title="0">{
                fmt.Print(" ")
        }</span>
        <span class="cov0" title="0">fmt.Fprint(l.out, l.colorStrings[level])
        fmt.Fprintf(l.out, f, v...)
        l.needSpace = true
        l.needCR = false</span>
}

func (l *Log) MessageTerminate(level Level, f string, v ...any) <span class="cov0" title="0">{
        if l == nil || l.out == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if level &gt; l.displayLevel </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">fmt.Fprint(l.out, l.colorStrings[level])
        fmt.Fprintf(l.out, f, v...)
        if !l.noColors </span><span class="cov0" title="0">{
                fmt.Fprint(l.out, chalk.ResetColor)
        }</span>
        <span class="cov0" title="0">fmt.Fprintln(l.out)
        l.needSpace = false
        l.needCR = false</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package journal

import "io"

type NoLog struct{}

func (NoLog) Debug(f string, v ...any)                         {<span class="cov0" title="0">}</span>
func (NoLog) DebugObject(name string, v any)                   {<span class="cov0" title="0">}</span>
func (NoLog) Info(f string, v ...any)                          {<span class="cov0" title="0">}</span>
func (NoLog) OK(f string, v ...any)                            {<span class="cov0" title="0">}</span>
func (NoLog) Warning(f string, v ...any)                       {<span class="cov0" title="0">}</span>
func (NoLog) Error(f string, v ...any)                         {<span class="cov0" title="0">}</span>
func (NoLog) Fatal(f string, v ...any)                         {<span class="cov0" title="0">}</span>
func (NoLog) Message(level Level, f string, v ...any)          {<span class="cov0" title="0">}</span>
func (NoLog) Progress(level Level, f string, v ...any)         {<span class="cov0" title="0">}</span>
func (NoLog) MessageContinue(level Level, f string, v ...any)  {<span class="cov0" title="0">}</span>
func (NoLog) MessageTerminate(level Level, f string, v ...any) {<span class="cov0" title="0">}</span>
func (NoLog) SetWriter(io.WriteCloser)                         {<span class="cov0" title="0">}</span>
func (NoLog) SetLevel(Level)                                   {<span class="cov0" title="0">}</span>
func (NoLog) SetColors(bool)                                   {<span class="cov0" title="0">}</span>
func (NoLog) SetDebugFlag(bool)                                {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">package loghelper

import (
        "log/slog"
        "sync/atomic"
)

var globalLogger atomic.Pointer[slog.Logger]

func SetGlobalLogger(l *slog.Logger) <span class="cov0" title="0">{
        globalLogger.Store(l)
}</span>

func Log(message string, values ...interface{}) <span class="cov0" title="0">{
        if l := globalLogger.Load(); l != nil </span><span class="cov0" title="0">{
                l.Info(message, values...)
        }</span>
}

func Info(message string, values ...interface{}) <span class="cov0" title="0">{
        if l := globalLogger.Load(); l != nil </span><span class="cov0" title="0">{
                l.Info(message, values...)
        }</span>
}

func Error(message string, values ...interface{}) <span class="cov0" title="0">{
        if l := globalLogger.Load(); l != nil </span><span class="cov0" title="0">{
                l.Error(message, values...)
        }</span>
}

func Warn(message string, values ...interface{}) <span class="cov0" title="0">{
        if l := globalLogger.Load(); l != nil </span><span class="cov0" title="0">{
                l.Warn(message, values...)
        }</span>
}

func Debug(message string, values ...interface{}) <span class="cov0" title="0">{
        if l := globalLogger.Load(); l != nil </span><span class="cov0" title="0">{
                l.Debug(message, values...)
        }</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package namematcher

import (
        "errors"
        "fmt"
        "regexp"
        "strings"
        "unicode"
        "unicode/utf8"
)

// List of file patterns used to ban unwanted files
// Pattern can be a part of the path, a file name..

type List struct {
        re       []*regexp.Regexp
        patterns []string
}

func New(patterns ...string) (List, error) <span class="cov8" title="1">{
        l := List{}
        for _, name := range patterns </span><span class="cov8" title="1">{
                err := l.Set(name)
                if err != nil </span><span class="cov0" title="0">{
                        return List{}, err
                }</span>
        }
        <span class="cov8" title="1">return l, nil</span>
}

func MustList(patterns ...string) List <span class="cov0" title="0">{
        l, err := New(patterns...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov0" title="0">return l</span>
}

func (l List) Match(name string) bool <span class="cov8" title="1">{
        for _, re := range l.re </span><span class="cov8" title="1">{
                if re.MatchString(name) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func fetchRune(b []byte) ([]byte, rune) <span class="cov8" title="1">{
        r, size := utf8.DecodeRune(b)
        b = b[size:]
        return b, r
}</span>

// transform a glob styled pattern into a regular expression
func patternToRe(pattern string) (*regexp.Regexp, error) <span class="cov8" title="1">{
        var r strings.Builder
        var inBrackets bool
        var b rune
        buf := []byte(pattern)

        r.WriteString("(?i)") // make the pattern case insensitive
        isFirstRune := true

        for len(buf) &gt; 0 </span><span class="cov8" title="1">{
                buf, b = fetchRune(buf)
                switch b </span>{
                case '/':<span class="cov8" title="1">
                        if isFirstRune </span><span class="cov8" title="1">{
                                r.WriteString(`(^|/)`)
                        }</span> else<span class="cov8" title="1"> {
                                r.WriteRune('/')
                        }</span>
                case '*':<span class="cov8" title="1">
                        r.WriteString(`[^/]*`)</span>
                case '?':<span class="cov8" title="1">
                        r.WriteString(`[^/]`)</span>
                case '.', '^', '$', '(', ')', '|':<span class="cov8" title="1">
                        r.WriteRune('\\')
                        r.WriteRune(b)</span>
                case '\\':<span class="cov8" title="1">
                        r.WriteRune(b)
                        buf, b = fetchRune(buf)
                        r.WriteRune(b)</span>
                case '[':<span class="cov8" title="1">
                        inBrackets = true
                        r.WriteRune(b)
                brackets:
                        for len(buf) &gt; 0 </span><span class="cov8" title="1">{
                                buf, b = fetchRune(buf)
                                switch b </span>{
                                case ']':<span class="cov8" title="1">
                                        inBrackets = false
                                        r.WriteRune(b)
                                        break brackets</span>
                                default:<span class="cov8" title="1">
                                        lCase, uCase := unicode.ToLower(b), unicode.ToUpper(b)
                                        r.WriteRune(lCase)
                                        if lCase != uCase </span><span class="cov8" title="1">{
                                                r.WriteRune(uCase)
                                        }</span>
                                }
                        }
                default:<span class="cov8" title="1">
                        r.WriteRune(b)</span>
                }
                <span class="cov8" title="1">isFirstRune = false</span>
        }
        <span class="cov8" title="1">if inBrackets </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file name pattern: %s", pattern)
        }</span>
        <span class="cov8" title="1">re, err := regexp.Compile(r.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file name pattern: %s", pattern)
        }</span>
        <span class="cov8" title="1">return re, nil</span>
}

/*
        Implements the flag.Value interface for the list of banned files
        Check the validity of the pattern
*/

func (l *List) Set(s string) error <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return errors.New("namematcher  list not initialized")
        }</span>
        <span class="cov8" title="1">if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">re, err := patternToRe(s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">l.re = append(l.re, re)
        l.patterns = append(l.patterns, s)
        return nil</span>
}

func (l List) String() string <span class="cov0" title="0">{
        var s strings.Builder
        for i, pattern := range l.patterns </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        s.WriteString(", ")
                }</span>
                <span class="cov0" title="0">s.WriteRune('\'')
                s.WriteString(pattern)
                s.WriteRune('\'')</span>
        }
        <span class="cov0" title="0">return s.String()</span>
}

func (l *List) Get() any <span class="cov0" title="0">{
        return *l
}</span>

func (l List) Type() string <span class="cov0" title="0">{
        return "FileList"
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package main

import (
        "context"
        "fmt"
        "path"

        "github.com/joho/godotenv"
        "github.com/simulot/immich-go/internal/tester"
)

const EnvFile = "../../../e2e.env"

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        err := run(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
        }</span>
}

func run(ctx context.Context) error <span class="cov0" title="0">{
        var err error
        myEnv, err := godotenv.Read(EnvFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't read .env file: %w", err)
        }</span>

        <span class="cov0" title="0">tester := tester.ImmichController{
                Env:            myEnv,
                ComposePath:    path.Join(myEnv["IMMICH_PATH"], "docker-compose.yml"),
                ComposeEnvPath: path.Join(myEnv["IMMICH_PATH"], ".env"),
                AppPath:        myEnv["IMMICH_PATH"],
                AppURL:         myEnv["IMMICH_HOST"],
        }
        err = tester.FactoryReset(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">myEnv["IMMICH_KEY"] = tester.APIKey
        err = godotenv.Write(myEnv, EnvFile)

        return err</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package tester

import (
        "context"
        "fmt"
        "os/exec"
        "strings"
)

// run the docker command
func (s *ImmichController) DockerRun(ctx context.Context, args ...string) ([]byte, error) <span class="cov0" title="0">{
        return exec.CommandContext(ctx, "docker", args...).CombinedOutput()
}</span>

// run the docker compose command
func (s *ImmichController) DockerCompose(ctx context.Context, args ...string) error <span class="cov0" title="0">{
        o, err := s.DockerRun(ctx, append([]string{"compose", "--file=" + s.ComposePath, "--env-file=" + s.ComposeEnvPath}, args...)...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("DockerCompose error:\n%s\n%w", string(o), err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// run the docker volume ls command
func (s *ImmichController) DockerVolumes(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        out, err := s.DockerRun(ctx, "volume", "ls", `--format={{.Name}}`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't get docker volumes:\n%s\n%w", string(out), err)
        }</span>
        <span class="cov0" title="0">volumes := strings.Split(string(out), "\n")
        return volumes, err</span>
}

func SudoRun(ctx context.Context, args ...string) ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.Command("sudo", args...)
        return cmd.CombinedOutput()
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">// Package tester implement some test functions in real immich server
//
//

package tester

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "path"
        "strings"
        "time"
)

type ImmichController struct {
        Env            map[string]string
        ComposePath    string
        ComposeEnvPath string
        AppPath        string
        AppURL         string
        UploadLocation string
        APIKey         string
        AccessToken    string
}

func (s *ImmichController) Down(ctx context.Context) error <span class="cov0" title="0">{
        return s.DockerCompose(ctx, "down")
}</span>

func (s *ImmichController) Up(ctx context.Context) error <span class="cov0" title="0">{
        return s.DockerCompose(ctx, "up", "-d")
}</span>

// FactoryReset recreates a fresh install of the immich server
// - It removes existing docker volumes
// - It removes existing images in
//                - encoded-video
//                - library
//                - thumbs
//                - upload
// - It creates an API Key

func (s *ImmichController) FactoryReset(ctx context.Context) error <span class="cov0" title="0">{
        _ = s.Down(ctx)

        err := s.RemoveDockerVolumes(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.Up(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.WaitImmich(ctx, 1*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.CreateAdminLogin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = s.CreateAPIKey(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ImmichController) RemoveDockerVolumes(ctx context.Context) error <span class="cov0" title="0">{
        appName := path.Base(s.AppPath)

        volumes, err := s.DockerVolumes(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, v := range volumes </span><span class="cov0" title="0">{
                if strings.HasPrefix(v, appName) </span><span class="cov0" title="0">{
                        fmt.Println("removing volume", v)
                        o, err := s.DockerRun(ctx, "volume", "rm", v)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("-&gt;", err.Error(), "\n", string(o))
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">o, err := s.DockerRun(ctx, "system", "prune", "-f")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(string(o))
                return fmt.Errorf("can't prune docker: %w", err)
        }</span>
        //        rm := "rm -rf " + strings.Join([]string{"encoded-video", "library", "thumbs", "upload"}, " ")
        <span class="cov0" title="0">o, err = SudoRun(ctx, "rm", "-rf", "encoded-video", "library", "thumbs", "upload")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(string(o))
                return fmt.Errorf("can't remove files: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *ImmichController) WaitImmich(ctx context.Context, wait time.Duration) error <span class="cov0" title="0">{
        stopAt := time.Now().Add(wait)
        for time.Now().Before(stopAt) </span><span class="cov0" title="0">{
                r, err := http.Get(s.AppURL + "/api/server-info/ping")
                if err == nil </span><span class="cov0" title="0">{
                        r.Body.Close()
                        if r.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">time.Sleep(2 * time.Second)</span>
        }
        <span class="cov0" title="0">return errors.New("can't join the immich server in the given time")</span>
}

func (s *ImmichController) CreateAdminLogin(ctx context.Context) error <span class="cov0" title="0">{
        r, err := http.Post(s.AppURL+"/api/auth/admin-sign-up", "application/json", strings.NewReader(`{
                "email": "demo@immich.app",
                "password": "demo",
                "name": "John Doe"
        }`))
        if err == nil </span><span class="cov0" title="0">{
                r.Body.Close()
                if r.StatusCode == http.StatusCreated </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("can't create admin login: %s", r.Status)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("can't create admin login: %w", err)</span>
}

func (s *ImmichController) CreateAPIKey(ctx context.Context) error <span class="cov0" title="0">{
        client := http.Client{}

        resp, err := client.Post(s.AppURL+"/api/auth/login", "application/json", strings.NewReader(`{"email": "demo@immich.app", "password": "demo"}`))
        if err == nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                if resp.StatusCode == http.StatusCreated </span><span class="cov0" title="0">{
                        for _, c := range resp.Cookies() </span><span class="cov0" title="0">{
                                if c.Name == "immich_access_token" </span><span class="cov0" title="0">{
                                        s.AccessToken = c.Value
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if s.AccessToken == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("can't get the accessToken")
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("can't get the accessToken: %s", resp.Status)
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't get the accessToken: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest(http.MethodPost, s.AppURL+"/api/api-key", strings.NewReader(`{"name": "Test controller"}`))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("can't get the API Key: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Add("Authorization", "Bearer "+s.AccessToken)
        req.Header.Add("Content-Type", "application/json")

        resp, err = client.Do(req)
        if err == nil </span><span class="cov0" title="0">{
                if resp.StatusCode == http.StatusCreated </span><span class="cov0" title="0">{
                        k := struct {
                                Secret string `json:"secret"`
                        }{}
                        err = json.NewDecoder(resp.Body).Decode(&amp;k)
                        s.APIKey = k.Secret
                        resp.Body.Close()
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("can't get the API Key: %s", resp.Status)
                }</span>
        }
        <span class="cov0" title="0">if err != nil || s.APIKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("can't get the API Key: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("APIKey = ", s.APIKey)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package ui

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strings"
)

func ConfirmYesNo(ctx context.Context, prompt string, defaultAnswer string) (string, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        reader := bufio.NewReader(os.Stdin)
        defaultAnswer = strings.ToLower(defaultAnswer)
        other := "n"
        if defaultAnswer == "n" </span><span class="cov0" title="0">{
                other = "y"
        }</span>

        <span class="cov0" title="0">runeChan := make(chan (rune))

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        r, _, _ := reader.ReadRune()
                        select </span>{
                        case runeChan &lt;- r:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                fmt.Printf("%s [%s]/%s: ", prompt, defaultAnswer, other)
                select </span>{
                case r := &lt;-runeChan:<span class="cov0" title="0">
                        userInput := strings.ToLower(string(r))
                        switch userInput </span>{
                        case "":<span class="cov0" title="0">
                                return defaultAnswer, nil</span>
                        case "y", "n":<span class="cov0" title="0">
                                return userInput, nil</span>
                        }
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return "", ctx.Err()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package ui

import (
        "fmt"
        "math"
)

func FormatBytes(s int64) string <span class="cov0" title="0">{
        suffixes := []string{"B", "KB", "MB", "GB"}
        bytes := float64(s)
        base := 1024.0
        if bytes &lt; base </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.0f %s", bytes, suffixes[0])
        }</span>
        <span class="cov0" title="0">exp := int64(0)
        for bytes &gt;= base &amp;&amp; exp &lt; int64(len(suffixes)-1) </span><span class="cov0" title="0">{
                bytes /= base
                exp++
        }</span>
        <span class="cov0" title="0">roundedSize := math.Round(bytes*10) / 10
        return fmt.Sprintf("%.1f %s", roundedSize, suffixes[exp])</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package worker

import (
        "sync"
)

// Task represents a unit of work to be processed by the worker pool.
type Task func()

// Pool manages a pool of worker goroutines.
type Pool struct {
        tasks chan Task
        wg    sync.WaitGroup
        quit  chan struct{}
}

// NewPool creates a new Pool with a specified number of workers.
func NewPool(numWorkers int) *Pool <span class="cov8" title="1">{
        pool := &amp;Pool{
                tasks: make(chan Task),
                quit:  make(chan struct{}),
        }

        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                pool.wg.Add(1)
                go pool.worker()
        }</span>

        <span class="cov8" title="1">return pool</span>
}

// worker is the function that each worker goroutine runs.
func (p *Pool) worker() <span class="cov8" title="1">{
        defer p.wg.Done()
        for </span><span class="cov8" title="1">{
                select </span>{
                case task := &lt;-p.tasks:<span class="cov8" title="1">
                        task()</span>
                case &lt;-p.quit:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// Submit adds a task to the worker pool.
func (p *Pool) Submit(task Task) <span class="cov8" title="1">{
        p.tasks &lt;- task
}</span>

// Stop stops all the workers and waits for them to finish.
func (p *Pool) Stop() <span class="cov8" title="1">{
        close(p.quit)
        p.wg.Wait()
        close(p.tasks)
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "os"
        "os/signal"

        "github.com/simulot/immich-go/app/cmd"
)

// immich-go entry point
func main() <span class="cov0" title="0">{
        ctx := context.Background()
        err := immichGoMain(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if e := context.Cause(ctx); e != nil </span><span class="cov0" title="0">{
                        err = e
                }</span>
                <span class="cov0" title="0">_, _ = fmt.Fprintln(os.Stderr, err)
                os.Exit(1)</span>
        }
}

// makes immich-go breakable with ^C and run it
func immichGoMain(ctx context.Context) error <span class="cov0" title="0">{
        // Create a context with cancel function to gracefully handle Ctrl+C events
        ctx, cancel := context.WithCancelCause(ctx)

        // Handle Ctrl+C signal (SIGINT)
        signalChannel := make(chan os.Signal, 1)
        signal.Notify(signalChannel, os.Interrupt)

        // Watch for ^C to be pressed
        go func() </span><span class="cov0" title="0">{
                &lt;-signalChannel
                fmt.Println("\nCtrl+C received. Shutting down...")
                cancel(errors.New("Ctrl+C received")) // Cancel the context when Ctrl+C is received
        }</span>()

        <span class="cov0" title="0">c, a := cmd.RootImmichGoCommand(ctx)
        // let's start
        err := c.ExecuteContext(ctx)
        if err != nil &amp;&amp; a.Log().GetSLog() != nil </span><span class="cov0" title="0">{
                a.Log().Error(err.Error())
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
