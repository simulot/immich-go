name: CI

on:
  pull_request:
    branches:
      - main
      - develop
    paths:
      - "**.go"
      - "go.mod"
      - "go.sum"
      - ".github/workflows/ci.yml"
      - "main.go"
      - "e2e-immich/**"
  push:
    branches:
      - main
      - develop
    paths:
      - "**.go"
      - "go.mod"
      - "go.sum"
      - ".github/workflows/ci.yml"
      - "main.go"
      - "e2e-immich/**"
  workflow_dispatch:

permissions:
  contents: read

env:
  project_dir: /home/runner/work/immich-go/immich-go
  e2e_folder: /home/runner/work/immich-go/immich-go/e2e-immich
  e2e_users: /home/runner/work/immich-go/immich-go/e2e-immich/e2eusers.env
  e2e_compose: /home/runner/work/immich-go/immich-go/e2e-immich/docker-compose.yml
  e2e_server: e2e-immich-${{ github.run_id }}
  e2e_url: http://e2e-immich-${{ github.run_id }}:2283
  e2e_ssh: root@e2e-immich-${{ github.run_id }}
  runner_timeout: 900
  RED: \033[0;31m
  GREEN: \033[0;32m
  YELLOW: \033[1;33m
  BLUE: \033[0;34m
  NC: \033[0m

jobs:
  validate-branch:
    name: Validate Branch Rules
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Check branch name and target
        run: |
          source_branch="${{ github.head_ref }}"
          target_branch="${{ github.base_ref }}"

          # Allow certain system/integration branches to bypass naming convention
          if [[ "$source_branch" =~ ^(main|develop|master)$ ]]; then
            echo "System branch '$source_branch' is exempt from naming convention."
          else
            # Check if the source branch name is valid (feature/bugfix/hotfix)
            if ! [[ "$source_branch" =~ ^(feature|bugfix|hotfix)/.+$ ]]; then
              echo "::error::Branch name '$source_branch' does not follow the naming convention (feature/, bugfix/, hotfix/)."
              exit 1
            fi
          fi

          # Check if a feature or bugfix branch is targeting the correct branch (develop)
          if [[ "$source_branch" =~ ^(feature|bugfix)/.+ ]] && [ "$target_branch" != "develop" ]; then
            echo "::error::'feature/*' and 'bugfix/*' branches must only be merged into 'develop'."
            exit 1
          fi

          # Check if a hotfix branch is targeting the correct branch (main)
          if [[ "$source_branch" =~ ^hotfix/.+ ]] && [ "$target_branch" != "main" ]; then
            echo "::error::'hotfix/*' branches must only be merged into 'main'."
            exit 1
          fi

          echo "‚úÖ Branch rules validated successfully."

  validate:
    name: Validate Code Quality
    runs-on: ubuntu-latest
    needs: validate-branch
    if: always() && (needs.validate-branch.result == 'success' || needs.validate-branch.result == 'skipped')
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "go.sum"

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v8
        with:
          version: latest

  test-linux:
    name: Unit Tests (Linux)
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "go.sum"

      - name: Run tests with coverage
        run: |
          go test -race -v -count=1 -coverprofile=coverage.out ./...

      - name: Generate coverage report
        run: |
          go tool cover -func=coverage.out

  build-check:
    name: Build Validation
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "go.sum"

      - name: Build primary binary
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o immich-linux-amd64 -ldflags="-s -w -extldflags=-static" main.go

      - name: Verify binary
        run: |
          ./immich-linux-amd64 version || echo "Binary built successfully"

  fast-feedback-complete:
    name: Fast Feedback Complete
    runs-on: ubuntu-latest
    needs: [validate, test-linux, build-check]
    outputs:
      should-run-e2e: ${{ steps.check-e2e.outputs.run-e2e }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5
        with:
          fetch-depth: 2

      - name: Check if E2E tests should run
        id: check-e2e
        run: |
          echo "‚úÖ All fast feedback checks passed!"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual trigger - will run E2E tests"
            echo "run-e2e=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")

          if [[ -z "$CHANGED_FILES" ]]; then
            echo "Could not determine changed files - skipping E2E tests"
            echo "run-e2e=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          if echo "$CHANGED_FILES" | grep -qE '^(app|adapters|immich|internal)/|^main\.go$|^go\.(mod|sum)$|^e2e-immich/'; then
            echo "‚úÖ E2E-relevant changes detected - will run E2E tests"
            echo "run-e2e=true" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è No E2E-relevant changes - skipping E2E tests"
            echo "run-e2e=false" >> $GITHUB_OUTPUT
          fi

  e2e_server:
    name: E2E Server (Tailscale)
    runs-on: ubuntu-latest
    needs: fast-feedback-complete
    if: needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    timeout-minutes: 10
    steps:
      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-immich-go
          hostname: ${{ env.e2e_server }}
          args: --ssh

      - name: Prepare the server environment
        run: |
          mkdir -p ${{ env.e2e_folder}}
          touch ${{ env.e2e_users}}

      - name: Deploy Immich
        run: |
          echo -e "--"
          echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
          echo -e "${BLUE}  Immich E2E Provisioning${NC}"
          echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
          echo ""
          echo -e "  ${BLUE}Installation Directory:${NC} ${e2e_folder}"
          echo ""

          mkdir -p "${e2e_folder}"
          cd "${e2e_folder}"

          echo -e "${YELLOW}üì• Downloading docker-compose.yml...${NC}"
          if ! curl -fsSL "https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml" -o docker-compose.yml; then
              echo -e "${RED}‚ùå Failed to download docker-compose.yml${NC}"
              exit 1
          fi

          echo -e "üì• Downloading .env file..."
          if ! curl -fsSL "https://github.com/immich-app/immich/releases/latest/download/example.env" -o .env; then
              echo -e "‚ùå Failed to download .env file"
              exit 1
          fi

          echo -e "${YELLOW}üì• Pull Immich images...${NC}"
          if ! docker compose pull -q; then
              echo -e "${RED}‚ùå Failed to pull Immich images${NC}"
              docker compose logs
              exit 1
          fi

          echo -e "${YELLOW}üöÄ Starting Immich services...${NC}"
          if ! docker compose up -d --build --renew-anon-volumes --force-recreate --remove-orphans; then
              echo -e "${RED}‚ùå Failed to start Immich services${NC}"
              docker compose logs
              exit 1
          fi

      - name: Show Immich containers status
        run: |
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml ps

      - name: Wait for Immich API to be ready
        run: |
          echo -e "${YELLOW}‚è≥ Waiting for Immich API to be ready...${NC}"
          TIMEOUT=180
          ELAPSED=0
          READY=false

          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -sf "${{ env.e2e_url }}/api/server/ping" > /dev/null 2>&1; then
              READY=true
              break
            fi
            echo -e "  ${BLUE}‚è±${NC}  Still waiting... (${ELAPSED}s / ${TIMEOUT}s)"
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done

          if [ "$READY" = false ]; then
            echo -e "${RED}‚ùå Immich API did not become ready within ${TIMEOUT} seconds${NC}"
            echo ""
            echo -e "${YELLOW}Container status:${NC}"
            docker compose -f ${{env.e2e_folder}}/docker-compose.yml ps
            echo ""
            echo -e "${YELLOW}Recent logs:${NC}"
            docker compose -f ${{env.e2e_folder}}/docker-compose.yml logs --tail=50 immich-server
            exit 1
          fi

          sleep 1
          echo -e "${GREEN}‚úÖ API is ready${NC}"

      - name: Keep server running for tests
        run: |
          echo "Server is running and accessible via Tailscale"
          echo "Waiting for client tests to complete..."
          max_wait=${{ env.runner_timeout}}
          elapsed=0
          done_marker="${{ env.e2e_folder }}/done"

          while [ $elapsed -lt $max_wait ]; do
            if [ -f "$done_marker" ]; then
              echo "‚úÖ Done marker found! Tests completed."
              echo "Server ran for ${elapsed}s"
              exit 0
            fi
            
            sleep 5
            elapsed=$((elapsed + 5))
            echo "Waited ${elapsed}s / ${max_wait}s for tests..."
          done

          echo "‚ö†Ô∏è Maximum wait time reached without done marker, shutting down server"
          exit 1

      - name: Show Immich logs on failure
        if: failure()
        run: |
          echo "=== Immich Server Logs ==="
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml logs
          echo "=== All Container Status ==="
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml ps

      - name: Cleanup Immich Instance
        if: always()
        run: |
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml down --volumes --remove-orphans || true
          docker system prune -f || true

  e2e-linux:
    name: E2E Tests (Linux Client)
    runs-on: ubuntu-latest
    needs: fast-feedback-complete
    if: needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    timeout-minutes: 10
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "go.sum"

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-immich-go
          hostname: e2e-linux-${{ github.run_id }}
          args: --ssh

      - name: Wait for Immich API to be ready
        run: |
          echo -e "${YELLOW}‚è≥ Waiting for Immich API to be ready...${NC}"
          TIMEOUT=180
          ELAPSED=0
          READY=false

          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -sf "${{ env.e2e_url }}/api/server/ping" > /dev/null 2>&1; then
              READY=true
              break
            fi
            echo -e "  ${BLUE}‚è±${NC}  Still waiting... (${ELAPSED}s / ${TIMEOUT}s)"
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done

      - name: Provision of the admin user
        run: |
          mkdir -p "${e2e_folder}"
          echo -e "${YELLOW}üë• Creating test users...${NC}"
          cd ${{env.project_dir}}/internal/e2e/e2eUtils/cmd/createUser
          go run createUser.go create-admin > "${e2e_folder}/e2eusers.env"
          cat "${e2e_folder}/e2eusers.env"

      - name: Copy the e2eusers.env to the server for later use
        run: |
          echo "Copying e2eusers.env to the server..."
          scp -o StrictHostKeyChecking=no ${{ env.e2e_folder }}/e2eusers.env ${{ env.e2e_ssh }}:${{ env.e2e_folder }}/e2eusers.env

      - name: Run E2E Tests on Linux
        run: |
          cd ${{ env.project_dir}}/internal/e2e/client
          go test -v -tags=e2e -timeout=30m ./...
        env:
          CGO_ENABLED: 0

  e2e-windows:
    name: E2E Tests (Windows Client)
    runs-on: windows-latest
    needs: [fast-feedback-complete, e2e-linux]
    if: needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    timeout-minutes: 10
    env:
      project_dir: d:\a\immich-go\immich-go
      e2e_folder: d:\a\immich-go\immich-go\e2e-immich
      e2e_users: d:\a\immich-go\immich-go\e2e-immich\e2eusers.env
      e2e_compose: d:\a\immich-go\immich-go\e2e-immich\docker-compose.yml
      e2e_users_server: /home/runner/work/immich-go/immich-go/e2e-immich/e2eusers.env

    steps:
      - name: Checkout Code
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "go.sum"

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-immich-go
          hostname: e2e-windows-${{ github.run_id }}

      - name: Wait for Immich API to be ready
        shell: pwsh
        run: |
          Write-Host "‚è≥ Waiting for Immich API to be ready..." -ForegroundColor Yellow
          $TIMEOUT = 180
          $ELAPSED = 0
          $READY = $false

          while ($ELAPSED -lt $TIMEOUT) {
            try {
              $response = Invoke-WebRequest -Uri "${{ env.e2e_url }}/api/server/ping" -Method Get -UseBasicParsing -ErrorAction SilentlyContinue
              if ($response.StatusCode -eq 200) {
                $READY = $true
                break
              }
            }
            catch {
              # API not ready yet, continue waiting
            }
            Write-Host "  ‚è±  Still waiting... ($ELAPSED`s / $TIMEOUT`s)" -ForegroundColor Blue
            Start-Sleep -Seconds 2
            $ELAPSED += 2
          }

          if (-not $READY) {
            Write-Host "‚ùå Immich API did not become ready within $TIMEOUT seconds" -ForegroundColor Red
            exit 1
          }

          Write-Host "‚úÖ API is ready" -ForegroundColor Green

      - name: Copy the e2eusers.env from the server
        shell: pwsh
        run: |
          Write-Host "Copying e2eusers.env from the server..." -ForegroundColor Yellow
          New-Item -Path "${{ env.e2e_folder }}" -ItemType Directory -Force | Out-Null
          scp -o StrictHostKeyChecking=no ${{ env.e2e_ssh }}:${{ env.e2e_users_server }} ${{ env.e2e_folder }}\e2eusers.env
          Get-Content "${{ env.e2e_folder }}\e2eusers.env"

      - name: Run E2E Tests on Windows
        shell: pwsh
        run: |
          Set-Location -Path "${{ env.project_dir }}\internal\e2e\client"
          go test -v -tags=e2e -timeout=30m ./...
        env:
          CGO_ENABLED: 0

  e2e-cleanup:
    name: E2E Cleanup
    runs-on: ubuntu-latest
    timeout-minutes: 2
    needs: [fast-feedback-complete, e2e-linux, e2e-windows]
    if: always() && needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    steps:
      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-immich-go
          args: --ssh
          hostname: e2e-cleanup-${{ github.run_id }}

      - name: Create done marker file
        run: |
          echo "Creating done marker file on server..."
          ssh -o StrictHostKeyChecking=no ${{ env.e2e_ssh }} "touch ${{ env.e2e_folder }}/done"
          echo "‚úÖ Done marker created"

  e2e-cancel-on-failure:
    name: Cancel on E2E Server Failure
    runs-on: ubuntu-latest
    timeout-minutes: 2
    needs: [fast-feedback-complete, e2e_server]
    if: failure() && needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    steps:
      - name: Cancel all jobs in this workflow
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚ùå E2E server deploy failed ‚Äî cancelling remaining jobs..."
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/cancel
