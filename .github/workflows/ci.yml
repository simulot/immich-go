name: CI

on:
  pull_request:
    branches:
      - main
      - develop
    paths:
      - "**.go"
      - "go.mod"
      - "go.sum"
      - ".github/workflows/ci.yml"
      - "main.go"
      - "internal/e2e/testdata/immich-server/**"
  push:
    branches:
      - main
      - develop
    paths:
      - "**.go"
      - "go.mod"
      - "go.sum"
      - ".github/workflows/ci.yml"
      - "main.go"
      - "internal/e2e/testdata/immich-server/**"
  workflow_dispatch:

permissions:
  contents: read

env:
  project_dir: /home/runner/work/immich-go/immich-go
  e2e_folder: /home/runner/work/immich-go/immich-go/internal/e2e/testdata/immich-server
  e2e_users: /home/runner/work/immich-go/immich-go/internal/e2e/testdata/immich-server/e2eusers.env
  e2e_server: e2e-immich-${{ github.run_id }}
  e2e_url: http://e2e-immich-${{ github.run_id }}:2283
  e2e_ssh: root@e2e-immich-${{ github.run_id }}
  runner_timeout: 900

jobs:
  validate-branch:
    name: Validate Branch Rules
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Check branch name and target
        run: |
          source_branch="${{ github.head_ref }}"
          target_branch="${{ github.base_ref }}"

          # Allow dependency management bot PRs to bypass naming convention
          # Matches: dependabot/*, renovate/*, etc.
          if [[ "${{ github.actor }}" == "dependabot[bot]" ]] || [[ "${{ github.actor }}" == "renovate[bot]" ]] || [[ "$source_branch" =~ ^(dependabot|renovate)/ ]]; then
            echo "Dependency management bot PR '$source_branch' is exempt from naming convention."
            exit 0
          fi

          # Allow certain system/integration branches to bypass naming convention
          if [[ "$source_branch" =~ ^(main|develop|master)$ ]]; then
            echo "System branch '$source_branch' is exempt from naming convention."
          else
            # Check if the source branch name is valid (feature/bugfix/hotfix/chore)
            if ! [[ "$source_branch" =~ ^(feature|bugfix|hotfix|chore)/.+$ ]]; then
              echo "::error::Branch name '$source_branch' does not follow the naming convention (feature/, bugfix/, hotfix/, chore/)."
              exit 1
            fi
          fi

          # Check if a feature, bugfix, or chore branch is targeting the correct branch (develop)
          if [[ "$source_branch" =~ ^(feature|bugfix|chore)/.+ ]] && [ "$target_branch" != "develop" ]; then
            echo "::error::'feature/*', 'bugfix/*', and 'chore/*' branches must only be merged into 'develop'."
            exit 1
          fi

          # Check if a hotfix branch is targeting the correct branch (main)
          if [[ "$source_branch" =~ ^hotfix/.+ ]] && [ "$target_branch" != "main" ]; then
            echo "::error::'hotfix/*' branches must only be merged into 'main'."
            exit 1
          fi

          echo "‚úÖ Branch rules validated successfully."

  validate:
    name: Code Quality & Tests
    runs-on: ubuntu-latest
    needs: validate-branch
    if: always() && (needs.validate-branch.result == 'success' || needs.validate-branch.result == 'skipped')
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "go.sum"

      - name: Lint
        uses: golangci/golangci-lint-action@v9
        with:
          version: latest

      - name: Unit Tests
        run: go test -race -v -count=1 -coverprofile=coverage.out ./...

      - name: Coverage Report
        run: go tool cover -func=coverage.out

      - name: Build Check
        run: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o immich-linux-amd64 -ldflags="-s -w -extldflags=-static" main.go

      - name: Verify Binary
        run: ./immich-linux-amd64 version || echo "‚úÖ Binary built successfully"

  fast-feedback-complete:
    name: Fast Feedback Complete
    runs-on: ubuntu-latest
    needs: validate
    outputs:
      should-run-e2e: ${{ steps.check-e2e.outputs.run-e2e }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5
        with:
          fetch-depth: 2

      - name: Check if E2E tests should run
        id: check-e2e
        run: |
          echo "‚úÖ All fast feedback checks passed!"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual trigger - will run E2E tests"
            echo "run-e2e=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")

          if [[ -z "$CHANGED_FILES" ]]; then
            echo "Could not determine changed files - skipping E2E tests"
            echo "run-e2e=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check if only documentation files were changed
          NON_DOC_FILES=$(echo "$CHANGED_FILES" | grep -vE '\.md$|^docs/|^README|^CONTRIBUTING|^LICENSE')

          if [[ -z "$NON_DOC_FILES" ]]; then
            echo "‚è≠Ô∏è Only documentation files changed - skipping E2E tests"
            echo "run-e2e=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if echo "$CHANGED_FILES" | grep -qE '^(app|adapters|immich|internal)/|^main\.go$|^go\.(mod|sum)$|^internal/e2e/testdata/immich-server/'; then
            echo "‚úÖ E2E-relevant changes detected - will run E2E tests"
            echo "run-e2e=true" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è No E2E-relevant changes - skipping E2E tests"
            echo "run-e2e=false" >> $GITHUB_OUTPUT
          fi

  e2e_server:
    name: E2E Server (Tailscale)
    runs-on: ubuntu-latest
    needs: fast-feedback-complete
    if: needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    timeout-minutes: 10
    steps:
      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-immich-go
          hostname: ${{ env.e2e_server }}
          args: --ssh

      - name: Prepare the server environment
        run: |
          mkdir -p ${{ env.e2e_folder}}
          touch ${{ env.e2e_users}}

      - name: Deploy Immich
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "  Immich E2E Provisioning"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          mkdir -p "${e2e_folder}"
          cd "${e2e_folder}"

          echo "üì• Downloading docker-compose.yml..."
          curl -fsSL "https://github.com/immich-app/immich/releases/latest/download/docker-compose.yml" -o docker-compose.yml
          curl -fsSL "https://github.com/immich-app/immich/releases/latest/download/example.env" -o .env

          echo "üì• Pulling Immich images..."
          docker compose pull -q

          echo "üöÄ Starting Immich services..."
          docker compose up -d --build --renew-anon-volumes --force-recreate --remove-orphans

      - name: Show Immich containers status
        run: |
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml ps

      - name: Wait for Immich API to be ready
        run: |
          echo "‚è≥ Waiting for Immich API to be ready..."
          TIMEOUT=180
          ELAPSED=0

          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -sf "${{ env.e2e_url }}/api/server/ping" > /dev/null 2>&1; then
              echo "‚úÖ API is ready (took ${ELAPSED}s)"
              exit 0
            fi
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done

          echo "‚ùå Immich API did not become ready within ${TIMEOUT} seconds"
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml ps
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml logs --tail=50 immich-server
          exit 1

      - name: Keep server running for tests
        run: |
          echo "Server is running and accessible via Tailscale"
          echo "Waiting for client tests to complete..."
          max_wait=${{ env.runner_timeout}}
          elapsed=0
          done_marker="${{ env.e2e_folder }}/done"

          while [ $elapsed -lt $max_wait ]; do
            if [ -f "$done_marker" ]; then
              echo "‚úÖ Done marker found! Tests completed."
              echo "Server ran for ${elapsed}s"
              exit 0
            fi
            
            sleep 5
            elapsed=$((elapsed + 5))
            echo "Waited ${elapsed}s / ${max_wait}s for tests..."
          done

          echo "‚ö†Ô∏è Maximum wait time reached without done marker, shutting down server"
          exit 1

      - name: Show Immich logs on failure
        if: failure()
        run: |
          echo "=== Immich Server Logs ==="
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml logs
          echo "=== All Container Status ==="
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml ps

      - name: Cleanup Immich Instance
        if: always()
        run: |
          docker compose -f ${{env.e2e_folder}}/docker-compose.yml down --volumes --remove-orphans || true
          docker system prune -f || true

  e2e-linux:
    name: E2E Tests (Linux Client)
    runs-on: ubuntu-latest
    needs: fast-feedback-complete
    if: needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    timeout-minutes: 10
    steps:
      - name: Checkout Code
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "go.sum"

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-immich-go
          hostname: e2e-linux-${{ github.run_id }}
          args: --ssh

      - name: Wait for Immich API to be ready
        run: |
          echo "‚è≥ Waiting for Immich API..."
          TIMEOUT=180
          ELAPSED=0

          while [ $ELAPSED -lt $TIMEOUT ]; do
            if curl -sf "${{ env.e2e_url }}/api/server/ping" > /dev/null 2>&1; then
              echo "‚úÖ API ready (${ELAPSED}s)"
              exit 0
            fi
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done

          echo "‚ùå API timeout after ${TIMEOUT}s"
          exit 1

      - name: Create admin user
        run: |
          mkdir -p "${e2e_folder}"
          echo "üë• Creating admin user..."
          cd ${{env.project_dir}}/internal/e2e/e2eUtils/cmd/createUser
          go run createUser.go create-admin > "${e2e_folder}/e2eusers.env"
          cat "${e2e_folder}/e2eusers.env"

      - name: Copy the e2eusers.env to the server for later use
        run: |
          echo "Copying e2eusers.env to the server..."
          scp -o StrictHostKeyChecking=no ${{ env.e2e_folder }}/e2eusers.env ${{ env.e2e_ssh }}:${{ env.e2e_folder }}/e2eusers.env

      - name: Run E2E Tests on Linux
        run: |
          cd ${{ env.project_dir}}/internal/e2e/client
          go test -v -tags=e2e -timeout=30m ./...
        env:
          CGO_ENABLED: 0

  e2e-windows:
    name: E2E Tests (Windows Client)
    runs-on: windows-latest
    needs: [fast-feedback-complete, e2e-linux]
    if: needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    timeout-minutes: 10
    env:
      project_dir: d:\a\immich-go\immich-go
      e2e_folder: d:\a\immich-go\immich-go\e2e-immich
      #e2e_compose: d:\a\immich-go\immich-go\e2e-immich\docker-compose.yml
      e2e_users_folder: d:\a\immich-go\immich-go\internal\e2e\testdata\immich-server
      e2e_users: d:\a\immich-go\immich-go\internal\e2e\testdata\immich-server\e2eusers.env
      e2e_users_server: /home/runner/work/immich-go/immich-go/internal/e2e/testdata/immich-server/e2eusers.env

    steps:
      - name: Checkout Code
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: "go.mod"
          cache-dependency-path: "go.sum"

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-immich-go
          hostname: e2e-windows-${{ github.run_id }}

      - name: Wait for Immich API to be ready
        shell: pwsh
        run: |
          Write-Host "‚è≥ Waiting for Immich API to be ready..." -ForegroundColor Yellow
          $TIMEOUT = 180
          $ELAPSED = 0
          $READY = $false

          while ($ELAPSED -lt $TIMEOUT) {
            try {
              $response = Invoke-WebRequest -Uri "${{ env.e2e_url }}/api/server/ping" -Method Get -UseBasicParsing -ErrorAction SilentlyContinue
              if ($response.StatusCode -eq 200) {
                $READY = $true
                break
              }
            }
            catch {
              # API not ready yet, continue waiting
            }
            Write-Host "  ‚è±  Still waiting... ($ELAPSED`s / $TIMEOUT`s)" -ForegroundColor Blue
            Start-Sleep -Seconds 2
            $ELAPSED += 2
          }

          if (-not $READY) {
            Write-Host "‚ùå Immich API did not become ready within $TIMEOUT seconds" -ForegroundColor Red
            exit 1
          }

          Write-Host "‚úÖ API is ready" -ForegroundColor Green

      - name: Copy the e2eusers.env from the server
        shell: pwsh
        run: |
          Write-Host "Copying e2eusers.env from the server..." -ForegroundColor Yellow
          New-Item -Path "${{ env.e2e_users_folder }}" -ItemType Directory -Force | Out-Null
          scp -o StrictHostKeyChecking=no "${{ env.e2e_ssh }}:${{ env.e2e_users_server }}" "${{ env.e2e_users }}"
          Get-Content "${{ env.e2e_users }}"

      - name: Run E2E Tests on Windows
        shell: pwsh
        run: |
          Set-Location -Path "${{ env.project_dir }}\internal\e2e\client"
          go test -v -tags=e2e -timeout=30m ./...
        env:
          CGO_ENABLED: 0

  e2e-cleanup:
    name: E2E Cleanup
    runs-on: ubuntu-latest
    timeout-minutes: 2
    needs: [fast-feedback-complete, e2e-linux, e2e-windows]
    if: always() && needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    steps:
      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci-immich-go
          args: --ssh
          hostname: e2e-cleanup-${{ github.run_id }}

      - name: Create done marker file
        run: |
          echo "Creating done marker file on server..."
          ssh -o StrictHostKeyChecking=no ${{ env.e2e_ssh }} "touch ${{ env.e2e_folder }}/done"
          echo "‚úÖ Done marker created"

  e2e-cancel-on-failure:
    name: Cancel on E2E Server Failure
    runs-on: ubuntu-latest
    timeout-minutes: 2
    needs: [fast-feedback-complete, e2e_server]
    if: failure() && needs.fast-feedback-complete.outputs.should-run-e2e == 'true'
    steps:
      - name: Cancel all jobs in this workflow
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "‚ùå E2E server deploy failed ‚Äî cancelling remaining jobs..."
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/cancel
